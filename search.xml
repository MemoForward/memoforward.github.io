<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>NIO基础</title>
    <url>/2022/07/08/NIO%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="NIO基础"><a href="#NIO基础" class="headerlink" title="NIO基础"></a>NIO基础</h1><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>目前互联网环境下，分布式系统十分重要，而分布式的根基在于网络编程。Netty是java领域网络编程的佼佼者。而要学好Netty，首先就必须要会NIO编程。本笔记旨在学习NIO的概念、使用及原理，并附带一些代码实现。</p>
<h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>NIO：non-blocking io 非阻塞IO。NIO有三大组件：<strong>Channel，Bugger， Selector</strong>。</p>
<h1 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h1><h2 id="Channel-amp-amp-Buffer"><a href="#Channel-amp-amp-Buffer" class="headerlink" title="Channel &amp;&amp; Buffer"></a>Channel &amp;&amp; Buffer</h2><p>Channel相当与一个stream，它就是读写数据的<strong>双向通道</strong>，channel可以把数据写入buffer，也可以把数据从buffer读出。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">	channel--&gt;buffer</span><br><span class="line">	buffer--&gt;channel</span><br></pre></td></tr></table></figure>
<p>常见的channel和buffer</p>
<blockquote>
<ul>
<li><p>FileChannel</p>
</li>
<li><p>DatagramChannel</p>
</li>
<li><p>SocketChannel</p>
</li>
<li><p>ServerSocketChannel</p>
</li>
</ul>
</blockquote>
<p>常见的buffer：</p>
<blockquote>
<ul>
<li>ByteBuffer（最常用）<ul>
<li>MappedByteBuffer</li>
<li>DirectByteBuffer</li>
<li>HeapByteBuffer</li>
</ul>
</li>
<li>ShortBuffer</li>
<li>……</li>
<li>CharBuffer</li>
</ul>
</blockquote>
<h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>以下是常用的几种多线程实现：</p>
<h3 id="多线程版"><a href="#多线程版" class="headerlink" title="多线程版"></a>多线程版</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">	subgraph 多线程版</span><br><span class="line">		thread1--&gt;socket1</span><br><span class="line">		thread2--&gt;socket2</span><br><span class="line">		thread3--&gt;socket3</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>
<font color="red">**缺点：**</font>

<ul>
<li>内存占用高</li>
<li>线程上下文切换成本高（因为CPU并发线程并没有那么多）</li>
<li>只适合连接数较小的情况</li>
</ul>
<h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">	subgraph 线程池版</span><br><span class="line">		thread1--&gt;socket1</span><br><span class="line">		thread1-.-&gt;socket3</span><br><span class="line">		thread2--&gt;socket2</span><br><span class="line">		thread2-.-&gt;socket4</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>
<font color="red">**缺点：**</font>

<ul>
<li>阻塞模式下，线程仅能处理一个socket连接</li>
<li>仅适用于短连接的场景</li>
</ul>
<h3 id="Selector-1"><a href="#Selector-1" class="headerlink" title="Selector"></a>Selector</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph TD</span><br><span class="line">	subgraph Selector版</span><br><span class="line">		thread--&gt;selector</span><br><span class="line">		selector--&gt;channel1</span><br><span class="line">		selector--&gt;channel2</span><br><span class="line">		selector--&gt;channel3</span><br><span class="line">	end</span><br></pre></td></tr></table></figure>
<p>Selector的作用就是配合<strong>一个</strong>线程来管理多个channel，获取这些channel上发生的事件，这些channel工作在非阻塞模下，线程不会吊死在一个channel上。适合连接数多，但是流量低的场景（low traffic）。</p>
<p>调用selector的select()会阻塞，直到channel发生了读写就绪事件，一但这些事件发生，select方法就会赶回这些事件交给thread处理。</p>
<h1 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h1><p>ByteBuffer可以理解成一个byte数组，然后封装了一些参数和API。</p>
<h2 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h2><ul>
<li>position：指针，通过指针位置来进行读写，因此同一个ByteBuffer读写模式下，position位置会不一样。</li>
<li>limit：可读或可写的最大索引位置。</li>
<li>capacity：ByteBuffer中数组的容量。</li>
</ul>
<h2 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h2><h4 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h4><ul>
<li><code>ByteBuffer buff = ByteBuffer.allocate(int capacity)</code>：获取一个<code>ByteBuffer ==&gt; HeapByteBuffer</code>，使用java堆内存<ul>
<li>读写效率较低</li>
<li>受垃圾回收影响，会改变内存位置</li>
</ul>
</li>
<li><code>ByteBuffer buff = ByteBuffer.allocateDirect(int capacity)</code><ul>
<li>直接内存，操作系统内存</li>
<li>分配效率差</li>
<li>操作不当容易内存泄漏</li>
</ul>
</li>
</ul>
<h4 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h4><ul>
<li><code>byte b = buff.get()</code>：获取缓存中一个字节（pos后移）</li>
<li><code>buff.get(int idx)</code>：获取指定位置的字节（pos不变）</li>
<li><code>int writeBytes = channel.write(buff)</code>：从buff中读数据，通过channel写入其他<ul>
<li>返回读入的字节数（channel一次可能读不完）</li>
</ul>
</li>
</ul>
<h4 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h4><ul>
<li><code>buff.put(byte b) || buff.put(byte[] bs)</code>：存入字节或字节数组（pos变化）</li>
<li><code>int readBytes = channel.read(buff)</code>：把channel中的数据写入buff<ul>
<li>返回写入的字节数，会受到buff容量的限制</li>
<li>返回-1表示没有东西可以写了</li>
</ul>
</li>
</ul>
<h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ul>
<li><code>buff.flip()</code>：切换读模式（pos变0）</li>
<li><code>buff.rewind()</code>：读模式下，pos置0，即从头开始读</li>
<li><code>buff.clear()</code>：切换写模式（pos归零）</li>
<li><code>buff.compact()</code>：切换写模式（未读内容左移到0，pos变成空白buff的起始位置）</li>
<li><code>buff.mark()</code>：标记当前pos的位置</li>
<li><code>buff.reset()</code>：pos回到mark的位置，还是读模式</li>
<li><code>buff.hasRemaining</code>：buff是否读完</li>
</ul>
<h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><ul>
<li><code>ByteBuffer buff = ByteBuffer.allocate(int capacity)</code></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">pos</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th></th>
<th style="text-align:center">capacity + limit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>buff.put(...)</code></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">pos</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">capacity + limit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">c</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>buff.flip()</code></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">pos</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">limit</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">capacity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">c</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>buffer.get() * 2</code>：pos改变</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">pos</th>
<th style="text-align:center">limit</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">capacity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">c</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><p><code>buffer.get(2)</code>：pos不变</p>
</li>
<li><p><code>buffer.compact()</code>：已读部分删除，留下未读</p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">pos</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">capacity+limit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">c</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>buffer.clear()</code>：没读，但也清零</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">pos</th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th></th>
<th style="text-align:center">capacity + limit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
<td></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>buffer.put(new byte[]{&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;})</code></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">pos</th>
<th style="text-align:center"></th>
<th style="text-align:center">capacity + limit</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">c</td>
<td style="text-align:center">d</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>buffer.flip()</code></li>
<li><code>buff.get() * 2</code></li>
<li><code>buff.mark()</code>：记录pos到c的位置</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">pos</th>
<th style="text-align:center"></th>
<th style="text-align:center">limit</th>
<th style="text-align:center"></th>
<th style="text-align:center">capacity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">c</td>
<td style="text-align:center">d</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>buff.get() * 2</code></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">pos+limit</th>
<th style="text-align:center"></th>
<th style="text-align:center">capacity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">c</td>
<td style="text-align:center">d</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>buff.reset()</code>：重置到c，还是读模式</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center"></th>
<th style="text-align:center">pos</th>
<th style="text-align:center"></th>
<th style="text-align:center">limit</th>
<th style="text-align:center"></th>
<th style="text-align:center">capacity</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">a</td>
<td style="text-align:center">b</td>
<td style="text-align:center">c</td>
<td style="text-align:center">d</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
</div>
<h2 id="ByteBuffer和字符串互转"><a href="#ByteBuffer和字符串互转" class="headerlink" title="ByteBuffer和字符串互转"></a>ByteBuffer和字符串互转</h2><h3 id="字符串转ByteBuffer"><a href="#字符串转ByteBuffer" class="headerlink" title="字符串转ByteBuffer"></a>字符串转ByteBuffer</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1. put() ==&gt; 写模式</span></span><br><span class="line">ByteBuffer buff1 = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">buff.put(<span class="string">"hello"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Charset ==&gt; 读模式</span></span><br><span class="line">ByteBuffer buff2 = StandardCharsets.UTF_8.encode(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. warp === Charset方法 ==&gt; 读模式</span></span><br><span class="line">ByteBuffer buff3 = ByteBuffer.warp(<span class="string">"hello"</span>.getBytes());</span><br></pre></td></tr></table></figure>
<h3 id="ByteBuffer转字符串"><a href="#ByteBuffer转字符串" class="headerlink" title="ByteBuffer转字符串"></a>ByteBuffer转字符串</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">buff.flip();</span><br><span class="line">StandardCharsets.UTF_8.decode(buff).toString();</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>Charset转字符串是根据pos位置来转的，因此<strong>必须要在读模式</strong>！</p>
<h2 id="分散读-amp-amp-集中写"><a href="#分散读-amp-amp-集中写" class="headerlink" title="分散读 &amp;&amp; 集中写"></a>分散读 &amp;&amp; 集中写</h2><h3 id="分散读"><a href="#分散读" class="headerlink" title="分散读"></a>分散读</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * data.txt</span></span><br><span class="line"><span class="comment"> * onetwothree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span>(RandAccessFile file = <span class="keyword">new</span> RandAccessFile(path, <span class="string">"rw"</span>)) &#123;</span><br><span class="line">    FileChannel channel = file.getChannel();</span><br><span class="line">    ByteBuffer b1 = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    ByteBuffer b2 = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    ByteBuffer b3 = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    channel.read(<span class="keyword">new</span> ByteBuffer[]&#123;b1, b2, b3&#125;);</span><br><span class="line">    b1.flip(); <span class="comment">// one</span></span><br><span class="line">    b2.flip(); <span class="comment">// two</span></span><br><span class="line">    b3.flip(); <span class="comment">// three</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="集中写"><a href="#集中写" class="headerlink" title="集中写"></a>集中写</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer b1 = StandardCharsets.UTF_8.encode(<span class="string">"hello"</span>);</span><br><span class="line">ByteBuffer b2 = StandardCharsets.UTF_8.encode(<span class="string">"world"</span>);</span><br><span class="line">ByteBuffer b3 = StandardCharsets.UTF_8.encode(<span class="string">"你好！"</span>);</span><br><span class="line"><span class="keyword">try</span>(FileChannel channel = <span class="keyword">new</span> RandAccessFile(path, <span class="string">"rw"</span>).getChannel()) &#123;</span><br><span class="line">    channel.write(<span class="keyword">new</span> ByteBuffer[]&#123;b1, b2, b3&#125;);</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ByteBuffer小练习"><a href="#ByteBuffer小练习" class="headerlink" title="ByteBuffer小练习"></a>ByteBuffer小练习</h2><h3 id="需求描述（粘包半包）"><a href="#需求描述（粘包半包）" class="headerlink" title="需求描述（粘包半包）"></a>需求描述（粘包半包）</h3><p>多条数据，组合成一条消息发送给服务端，通过<strong>字符c</strong>来进行分割每条数据，服务端可能会接收到多个包（ByteBuffer[]），写一段代码，将每条数据进行打印。</p>
<h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseMessage</span><span class="params">(ByteBuffer[] buffers, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ByteBuffer byteBuffer : buffers) capacity += byteBuffer.capacity();</span><br><span class="line">    ByteBuffer source = ByteBuffer.allocate(capacity); <span class="comment">// 用一个source来接受所有的包</span></span><br><span class="line">    <span class="keyword">for</span> (ByteBuffer byteBuffer : buffers) &#123;</span><br><span class="line">        source.put(byteBuffer);</span><br><span class="line">        source.flip();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; source.limit(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">char</span>) source.get(j) == c) &#123;</span><br><span class="line">                <span class="keyword">int</span> length = j - source.position();</span><br><span class="line">                ByteBuffer targetData = ByteBuffer.allocate(length);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; length; k++) &#123;</span><br><span class="line">                    targetData.put(source.get()); <span class="comment">// source读，并pos移动位置</span></span><br><span class="line">                &#125;</span><br><span class="line">                source.get(); <span class="comment">// pos跳过分割字符</span></span><br><span class="line">                targetData.flip(); <span class="comment">// 必须切换成读模式</span></span><br><span class="line">                res.add(StandardCharsets.UTF_8.decode(targetData).toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        source.compact();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="文件编程"><a href="#文件编程" class="headerlink" title="文件编程"></a>文件编程</h1><h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><font color="red">**注意：只能工作在阻塞模式下**</font>

<h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>不能直接打开FileChannel，必须通过<code>FileInputStream, FileOutputStream</code>或者<code>RandomAccessFile</code>来获取，通过<code>getChannel()</code>方法</p>
<blockquote>
<p>FileInputStream获取的Channel只读</p>
<p>FileOutputStream获取的Channel只写</p>
<p>RandomAccessFile，可以控制读写权限</p>
</blockquote>
<h3 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回读到的字节数，如果读到-1，则表示没有内容可读了</span></span><br><span class="line"><span class="keyword">int</span> readBytes = channel.read(byteBuffer);</span><br></pre></td></tr></table></figure>
<h3 id="写入-1"><a href="#写入-1" class="headerlink" title="写入"></a>写入</h3><p>正确姿势如下：（虽然FileChannel不存在这个问题，但是SocketChannel并不能一次性写入所有数据，存在写能力的上限 ===&gt; 必须用while来判断buffer里面是否还有数据）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ByteBuffer buffer = ...;</span><br><span class="line">buffer,put(...); <span class="comment">// 存输入</span></span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>channel必须关闭，不过调用了<code>FileInputStream, FileOutputStream或者RandomAccessFile</code>的close方法，会间接调用channel的close。<strong>推荐使用twr包裹，自动close。</strong></p>
<h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><ul>
<li>获取当前位置：<code>long pos = channel.potision()</code></li>
<li>设置当前位置：<code>channel.position(int newPos)</code><ul>
<li>如果新位置设置在文件末尾，读取会返回-1</li>
<li>写入会进行追加，如果position超过了文件末尾，再写入新的内容和原末尾之间会有空值（00）</li>
</ul>
</li>
</ul>
<h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p>使用<code>size()</code>可以 获得文件的大小</p>
<h3 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h3><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用<code>force(true)</code>方法将文件内容和原数据（文件的权限等）立刻写入磁盘。</p>
<h3 id="两个FileChannel之间传输数据"><a href="#两个FileChannel之间传输数据" class="headerlink" title="两个FileChannel之间传输数据"></a><font color="red">两个FileChannel之间传输数据</font></h3><ul>
<li><code>transferTo</code>:返回实际传输的字节数，一次最多只能传输2GB，但效率非常高</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    FileChannel from = <span class="keyword">new</span> FileInputstream(path).getChannel();</span><br><span class="line">    FileChannel to = <span class="keyword">new</span> FileOutputStream(path).getChannel();</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// 效率高，底层使用了操作系统的零拷贝进行了优化</span></span><br><span class="line">    <span class="keyword">long</span> size = from.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> left = size; left &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">      left -= from.transferTo((size - left), left, to);  </span><br><span class="line">    &#125;</span><br><span class="line">    from.transferTo(<span class="number">0</span>, from.size(), to);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h2><p>JDK7引入的Path和Paths</p>
<ul>
<li>Path表示文件路径</li>
<li>Paths是工具类，用来获取Path实例</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path source = Paths.get(<span class="string">"cxy.txt"</span>);</span><br><span class="line">Path source = Paths.get(<span class="string">"d:\\cxy.txt"</span>);</span><br><span class="line">Path source = Paths.get(<span class="string">"d:/cxy.txt"</span>);</span><br><span class="line">Path source = Paths.get(<span class="string">"d:\\data"</span>, <span class="string">"cxy.txt"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>支持：<code>./</code>和<code>../</code>来表示文件层级</li>
<li><code>path.normaliaze()</code>可以把文件路径格式化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Path source = Paths.get(<span class="string">"d:/data/test/../cxy.txt"</span>);</span><br><span class="line">print(source); <span class="comment">// d:/data/test/../cxy.txt</span></span><br><span class="line">print(source.nomalize()) <span class="comment">// d:/data/cxy.txt</span></span><br></pre></td></tr></table></figure>
<h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p>JDK7引入</p>
<h3 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h3><ul>
<li>检查文件是否存在：<code>Files.exists(Path path)</code></li>
<li>创建一级目录：<code>Files.createDirectory(Path path)</code><ul>
<li>如果目录已经存在，会抛异常</li>
<li>不能创建多级</li>
</ul>
</li>
<li>创建多级目录：<code>Files.createDirectories(Path path)</code></li>
<li><strong>拷贝文件</strong>：<code>Files.copy(Path source, Path target)</code><ul>
<li>如果文件已经存在，会报异常</li>
<li>如果要覆盖原文件: <code>Files.copy(source, target, StrandardCopyoption.REPLACE_EXISITING)</code></li>
<li>和<code>transforTo</code>性能差不多</li>
</ul>
</li>
<li>移动文件：<code>Files.move(Path source, Path target, StandardCopyOption.ATOMIC_MOVE)</code><ul>
<li>保证原子性</li>
</ul>
</li>
<li>删除文件：<code>Files.delete(Path target)</code><ul>
<li>文件不存在，会抛异常</li>
</ul>
</li>
<li>删除目录：<code>Files.delete(Path target)</code><ul>
<li>如果目录内有文件，会抛异常，无法删除</li>
<li>需要先删文件再删目录</li>
</ul>
</li>
</ul>
<h3 id="进阶API"><a href="#进阶API" class="headerlink" title="进阶API"></a>进阶API</h3><p><strong>遍历文件夹：<code>Files.walkFileTree(Path start, FileVisitor&lt;? super Path&gt; visitor)</code></strong></p>
<ul>
<li><code>FileVisitor</code>是一个接口，有4个方法，一般用<code>new SimpleFileVisitor&lt;Path&gt;</code>来写（可以不用全部实现，重写就行）<ul>
<li><code>preVisitDirectory</code>：进入文件夹前触发</li>
<li><code>postVisitDirectory</code>：离开文件夹前触发</li>
<li><code>visitFile</code>：访问文件时触发</li>
<li><code>visitFileFailed</code>：访问文件失败时触发</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 简单用法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger fileCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger directorCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    Files.walkFileTree(Paths.get(<span class="string">"/Users/memoforward/Blog/MemoForward"</span>), <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            directorCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">"files: "</span> + fileCount.get());</span><br><span class="line">    System.out.println(<span class="string">"directors: "</span> + directorCount.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="需求1：如何删除多级目录？"><a href="#需求1：如何删除多级目录？" class="headerlink" title="需求1：如何删除多级目录？"></a>需求1：如何删除多级目录？</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Files.walkFileTree(Paths.get(<span class="string">"~"</span>), <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Files.delete(file);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Files.delete(dir);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Walk"><a href="#Walk" class="headerlink" title="Walk"></a>Walk</h4><p>返回一个stream流。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Files.walk(Paths.get(<span class="string">"~"</span>)).forEach(path -&gt; &#123;</span><br><span class="line">    String targetName = path.toString().replace(source, target);</span><br><span class="line">    <span class="keyword">if</span> (Files.isDirectory()) &#123;</span><br><span class="line">        Files.createDirectories(Paths.get(tartetName));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Files.isRegularFile(path)) &#123;</span><br><span class="line">        Files.copy(path, Paths.get(targetName));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;...&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a><font color="red">网络编程</font></h1><h2 id="阻塞式（NIO实现）"><a href="#阻塞式（NIO实现）" class="headerlink" title="阻塞式（NIO实现）"></a>阻塞式（NIO实现）</h2><p>单线程处理：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//0. ByteBuffer</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 1. 创建了服务器</span></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. accept建立与客户端的连接，SocketChannel用来与客户端之间通信</span></span><br><span class="line">        SocketChannel sc = ssc.accept();</span><br><span class="line">        channels.add(sc);</span><br><span class="line">        <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">            channel.read(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 4. 逻辑处理</span></span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>以上代码，<strong>有两处地方阻塞</strong>：<code>accept()和read()。</code></p>
<ul>
<li><code>accept()</code>：等待客户端连接而导致的阻塞（没有线程连接就阻塞）</li>
<li><code>read()</code>：等待客户端写入数据而导致的阻塞（没有数据写入就阻塞）</li>
</ul>
<p>这就导致了：单线程处理连接，如果同时有两个线程进行连接和写入，不同线程的<code>accpet()</code>和<code>read()</code>会相互阻塞，如果一个客户端连接后，一直不写，这个线程就永远无法与其他客户端连接。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>阻塞式单线程处理，无法进行处理多个连接的情况。</strong></p>
<h2 id="非阻塞式（NIO-Channel实现）"><a href="#非阻塞式（NIO-Channel实现）" class="headerlink" title="非阻塞式（NIO Channel实现）"></a>非阻塞式（NIO Channel实现）</h2><p><strong>单线程处理：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将服务端的channel设置成非阻塞模式</span></span><br><span class="line">ssc.configureBlocking(<span class="keyword">false</span>); </span><br><span class="line"><span class="comment">// 将与客户端通信的SocketChannel也设置成非阻塞</span></span><br><span class="line">ssc.configureBlocking(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>
<p><strong>改进版本：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//0. ByteBuffer</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 1. 创建了服务器</span></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8889</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. accept建立与客户端的连接，SocketChannel用来与客户端之间通信</span></span><br><span class="line">        SocketChannel sc = ssc.accept();</span><br><span class="line">        <span class="keyword">if</span> (sc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            channels.add(sc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">            <span class="keyword">int</span> read = channel.read(buffer); <span class="comment">// 没有读到数据，返回0</span></span><br><span class="line">            <span class="keyword">if</span>(read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="comment">// 4. 逻辑处理</span></span><br><span class="line">                <span class="comment">// ....</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul>
<li>非阻塞模式可以让线程不阻塞，<strong><font color="red">但很消耗资源</font></strong>，相当于线程一直空转</li>
</ul>
<h2 id="非阻塞式改进（Selector）"><a href="#非阻塞式改进（Selector）" class="headerlink" title="非阻塞式改进（Selector）"></a>非阻塞式改进（Selector）</h2><p>由<code>Selector</code>监听事件，没事件就阻塞，有事件就分配线程去运行。提高线程使用效率。</p>
<h4 id="Selector-2"><a href="#Selector-2" class="headerlink" title="Selector"></a>Selector</h4><ul>
<li>创建：<code>Selector sel = Selector.open()</code></li>
<li>channel注册：<code>Selectionkey selectorKey = channel.register(sel, int ops, Object attention)</code><ul>
<li><code>sel</code>：绑定的Selector</li>
<li><code>ops</code>：绑定的事件<code>(SelectionKey.XXXX)</code><ul>
<li>0：不关注任何事件</li>
<li>accept：服务端事件，有连接请求时产生的事件<code>(SelectionKey.OP_ACCEPT)</code></li>
<li>connect：客户端事件，连接建立后产生的事件<code>(SelectionKey.OP_CONNECT)</code></li>
<li>read：服务端事件，读事件<code>(SelectionKey.OP_READ)</code></li>
<li>write：客户端时间，写事件<code>(SelectionKey.OP_WRITE)</code></li>
<li>可以用两个事件的值相加来绑定多个事件<code>(SelectionKey.OP_ACCEPT + SelectionKey.OP_READ)</code></li>
</ul>
</li>
<li><code>SelectorKey</code>：channel和selector绑定的关系具象，可以通过key获得对应的channel和绑定的事件</li>
<li><code>attention</code>：绑定在SelectorKey上的对象，用来做拓展用</li>
</ul>
</li>
<li>也可以手动绑定事件：<code>selectionKey.interestOps(SelectionKey.OP_ACCEPT)</code></li>
<li>开启监听：<code>sel.select()</code> —&gt;没事件是阻塞的</li>
</ul>
<h4 id="SelectedKeys"><a href="#SelectedKeys" class="headerlink" title="SelectedKeys"></a>SelectedKeys</h4><blockquote>
<p>概念：Selector里的keys集合，用来实时处理事件</p>
</blockquote>
<p>如果有事件发生，Selector就会把事件放到SelectedKeys集合里面，我们可以通过key来获取事件，并针对事件做出相应的逻辑处理。</p>
<p>事件处理后，理论上需要把事件移出集合（不移除，每次SelectedKeys都会遍历到这个过期事件），但是Selector仅做了<strong>逻辑删除</strong>，所以我们最好要手动移除，而在遍历集合中要做到移除元素，<strong>需要用迭代器。</strong></p>
<h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a><strong>简单实现</strong></h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Selector，管理多个channel</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将channel注册到selector</span></span><br><span class="line">    <span class="comment">// SelectionKey是事件发生后，可以知道对应channel发生的具体事件</span></span><br><span class="line">    SelectionKey selectionKey = ssc.register(selector, SelectionKey.OP_ACCEPT, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// selectionKey.interestOps(SelectionKey.OP_READ);</span></span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8787</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. select方法，没有事件发生，线程阻塞，有事件，线程才会恢复运行</span></span><br><span class="line">        selector.select();</span><br><span class="line">        <span class="comment">// 4. 处理事件, keys里面包含了所有的事件</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            SelectionKey key = iterator.next();</span><br><span class="line">            ServerSocketChannel channel = (ServerSocketChannel)key.channel();</span><br><span class="line">            SocketChannel sc = channel.accept();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>事件发生，必须要处理，如果不处理，集合内的事件甚至不会被逻辑删除，这就导致select永远不会阻塞，消耗cpu资源。</p>
<ul>
<li>调用<code>key.cancel()</code>方法，会把key<strong>逻辑删除，导致不监听任何方法（除非重新注册，可以理解成物理删除）</strong>，如果不处理，或发生异常来不及处理，就一定要<code>cancel</code>。</li>
</ul>
<p><strong><font color="red">问题:  </font> 好像也只是单线程处理一个事件，如何根据不同的channel执行不同的事件呢？</strong></p>
<ul>
<li>给accept获得的channel也注册到selector中</li>
<li><strong>SelectedKey可以识别自身发生的事件类型</strong><ul>
<li><code>key.isAcceptable()</code></li>
<li><code>key.isReadable()</code></li>
<li>…..</li>
</ul>
</li>
</ul>
<h4 id="改进版本一"><a href="#改进版本一" class="headerlink" title="改进版本一"></a>改进版本一</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Selector，管理多个channel</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将channel注册到selector</span></span><br><span class="line">    <span class="comment">// SelectionKey是事件发生后，可以知道对应channel发生的具体事件</span></span><br><span class="line">    SelectionKey selectionKey = ssc.register(selector, SelectionKey.OP_ACCEPT, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// selectionKey.interestOps(SelectionKey.OP_READ);</span></span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8787</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. select方法，没有事件发生，线程阻塞，有事件，线程才会恢复运行</span></span><br><span class="line">        selector.select();</span><br><span class="line">        <span class="comment">// 4. 处理事件, keys里面包含了所有的事件</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            SelectionKey key = iterator.next();</span><br><span class="line">            <span class="comment">// iterator.remove(); 从集合中移除key</span></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                ServerSocketChannel channel = (ServerSocketChannel)key.channel();</span><br><span class="line">                SocketChannel sc = channel.accept();</span><br><span class="line">                sc.register(selector, SelectionKey.OP_READ, <span class="keyword">null</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                sc.read(buffer);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="comment">// ...业务逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red"><strong>问题：</strong></font><strong>这个代码有一个不明显的问题</strong>，就是上文提到的remove机制。</p>
<ul>
<li>==<strong>前提知识</strong>==：selector中会有两个集合，一个是注册的channel集合（包含了channel和监听的事件类型，这个集合就是用来阻塞监听的），另一个是selectedKeys集合。当有事件发生时，selector会从channel集合中把对应的元素拿出来放到selectedKeys集合中，供用户处理，也就是说，<strong>这两个集合放的元素都是一样，都是key，而且一个key包含了channel + 事件。</strong><ul>
<li><strong>Set\<SelectedKey> publicKeys:  </SelectedKey></strong>注册进来的key</li>
<li><strong>Set\<SelectionKey> publicSelectedKeys: </SelectionKey></strong>事件发生后，加入的key</li>
</ul>
</li>
<li>问题原因：事件处理后，selectedKeys里面仅做了逻辑删除（具体源码未知），这个删除不会让select()监测到。</li>
<li>问题复现：虽然逻辑删除的事件不会取消select()的阻塞，但是会在遍历集合的时候遍历到这个channel，而且<code>isAcceptable()</code>同样也会被触发，因此当其他事件触发时，ssc又会去accept一个channel，但这个channel是null，因此会导致空指针异常。</li>
<li>问题解决：将以上代码的注释放开就行，手动remove。</li>
<li>复盘：这个更像是NIO的一个bug。</li>
</ul>
<h4 id="改进版本二"><a href="#改进版本二" class="headerlink" title="改进版本二"></a>改进版本二</h4><p>上述代码有两个问题：</p>
<ul>
<li>客户端异常关闭，会导致一个read事件。</li>
<li>客户端正常关闭，也会导致一个read事件。</li>
<li>read事件不会得到处理（因为这个channel没法read了），会导致selectedKeys集合每次循环都会增加这个事件，因为<code>publicKeys</code>里面这个事件未被处理，(所以remove了也没用，因为remove是selectedKeys集合里面的内容）。</li>
</ul>
<p>解决：</p>
<ul>
<li>用catch捕获异常，并且在异常中cancel。</li>
<li>如果<code>channel.read() == -1, 则</code>cancel`。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">int</span> read = sc.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (read == -<span class="number">1</span>) key.cancel();</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// ...业务逻辑</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        key.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复盘：这个也像是NIO的一个bug。</p>
<h2 id="消息边界问题"><a href="#消息边界问题" class="headerlink" title="消息边界问题"></a>消息边界问题</h2><p>NIO处理黏包半包问题。</p>
<p><img src="/2022/07/08/NIO%E5%9F%BA%E7%A1%80/NIO消息边界.png" alt></p>
<p><strong>解决思路：</strong></p>
<ol>
<li>约定Buffer容量，缺点是浪费资源</li>
<li>定义包间分割符号，利用符号进行包的提取，缺点是拆包效率低</li>
<li>约定一个报文头，表明后面的消息长度【[4byte][xxxx]】。TLV模式，Type + Length + Value。根据解析的结果分配Buffer，缺点是buffer需要提前分配，如果内容过大，影响server吞吐。<ul>
<li>HTTP1.1是TLV格式</li>
<li>HTTP2.0 是LTV格式 </li>
</ul>
</li>
</ol>
<p>第二种方法的实现就是前面的小练习的增强版。</p>
<ul>
<li>得用channel绑定的自己的ByteBuffer（不能共用ByteBuffer，不然会有线程安全问题）</li>
<li><p>ByteBuffer不够，需要有措施</p>
<ul>
<li>扩容。缺点是扩容时拷贝会浪费性能，优点是消息是连续处理的。</li>
<li>用数组绑定channel，不够就加新建一个ByteBuffer加进数组。缺点是消息存储不连续，解析 复杂。</li>
</ul>
<p>这里引入了channel注册的另一个参数：<code>attachment</code>，表示和channel绑定的一个对象，可以通过key获取。</p>
</li>
</ul>
<p><strong>实现（使用扩容）：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sc.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">4</span>));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer)key.attachment();</span><br><span class="line">        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">int</span> read = sc.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (read == -<span class="number">1</span>) key.cancel();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            split(buffer, <span class="string">'\n'</span>);</span><br><span class="line">            <span class="comment">// buffer满</span></span><br><span class="line">            <span class="keyword">if</span> (buffer.limit() == buffer.position())&#123;</span><br><span class="line">                <span class="comment">// 扩容</span></span><br><span class="line">                ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * <span class="number">2</span>);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                newBuffer.put(buffer); <span class="comment">// 注意此时newBuffer的pos在正确的位置</span></span><br><span class="line">                key.attach(newBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(ByteBuffer source, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; source.limit(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">char</span>) source.get(j) == c) &#123;</span><br><span class="line">            <span class="keyword">int</span> length = j - source.position();</span><br><span class="line">            ByteBuffer targetData = ByteBuffer.allocate(length);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; length; k++) &#123;</span><br><span class="line">                targetData.put(source.get()); <span class="comment">// source读，并pos移动位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            source.get(); <span class="comment">// pos跳过分割字符</span></span><br><span class="line">            targetData.flip(); <span class="comment">// 必须切换成读模式</span></span><br><span class="line">            <span class="comment">// 对target逻辑处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="处理写事件："><a href="#处理写事件：" class="headerlink" title="处理写事件："></a>处理写事件：</h2><p>写事件的监听不太好理解，这里单独用一个样例表示。</p>
<ul>
<li>服务端：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 注意阻塞模式下，write会一次性写完所有数据</span></span><br><span class="line">                    <span class="comment">// 给客户端传递大量数据</span></span><br><span class="line">                    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">3000000</span>; i++) sb.append(<span class="string">"a"</span>);</span><br><span class="line">                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        <span class="keyword">int</span> write = sc.write(buffer); <span class="comment">// 返回每次写多少</span></span><br><span class="line">                        System.out.println(write);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console log:</span><br><span class="line"><span class="number">261676</span></span><br><span class="line"><span class="number">998124</span></span><br><span class="line"><span class="number">1521840</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">73728</span></span><br><span class="line"><span class="number">144632</span></span><br></pre></td></tr></table></figure>
<ul>
<li>客户端</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// 接受数据</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">            count += sc.read(buffer);</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console log:</span><br><span class="line"><span class="number">130656</span></span><br><span class="line"><span class="number">1161444</span></span><br><span class="line"><span class="number">2200476</span></span><br><span class="line"><span class="number">3000000</span></span><br></pre></td></tr></table></figure>
<ul>
<li>问题</li>
</ul>
<p>我们会发现，在非阻塞模式下， 一次写不完的数据会分多次写入，但是，在while循环里，如果buffer里的数据没有被完全传递（buffer满着），就会write一个0，这不合理，我们想把写0的时候，释放线程。</p>
<ul>
<li>改进服务端（触发写事件，buffer空了再去写）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 注意阻塞模式下，write会一次性写完所有数据</span></span><br><span class="line">                    SelectionKey scKey = sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">// 给客户端传递大量数据</span></span><br><span class="line">                    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000000</span>; i++) sb.append(<span class="string">"a"</span>);</span><br><span class="line">                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        scKey.interestOps(scKey.interestOps() | SelectionKey.OP_WRITE); <span class="comment">// 添加事件</span></span><br><span class="line">                        scKey.attach(buffer); <span class="comment">// 将buffer挂上</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                    SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="keyword">int</span> write = sc.write(buffer);</span><br><span class="line">                    System.out.println(write);</span><br><span class="line">                    <span class="keyword">if</span> (!buffer.hasRemaining()) &#123;</span><br><span class="line">                        key.attach(<span class="keyword">null</span>); <span class="comment">// 清理</span></span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE); <span class="comment">// 取消关注</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
  </entry>
  <entry>
    <title>Kafka自整理学习笔记</title>
    <url>/2022/01/01/Kafka%E8%87%AA%E6%95%B4%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<ol>
<li><p>本博客整理了一些Kafka的基本概念和使用</p>
</li>
<li><p>自己用来当笔记的，故不需要图帮助理解</p>
</li>
<li>只有Java端的使用，C++端的以后可能会补上</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="1-事件流"><a href="#1-事件流" class="headerlink" title="1. 事件流"></a>1. 事件流</h1><p>事件流的三个特征：数据格式+持续性的流+分发。</p>
<ul>
<li>实时从事件源读取事件流</li>
<li>数据持久化存储和恢复</li>
<li>实时或者异步处理和响应流数据</li>
<li>将数据流路由到不同的目的地</li>
</ul>
<h1 id="2-Kafka"><a href="#2-Kafka" class="headerlink" title="2. Kafka"></a>2. Kafka</h1><p>Kafka是一个数据流平台，其具有三个能力：</p>
<ol>
<li>发布和订阅事件流，可以持续地从其他系统导入和导出data</li>
<li>持久可靠地存储事件流</li>
<li>可以同步和异步化处理事件流</li>
</ol>
<p>以上的功能Kafka都能以<strong>分布式、高度可拓展、高容错、高安全</strong>的方式提供。</p>
<h1 id="3-Kafka如何工作"><a href="#3-Kafka如何工作" class="headerlink" title="3. Kafka如何工作"></a>3. Kafka如何工作</h1><p>Server和Clients通过高性能的TCP网络来进行通讯。</p>
<h2 id="3-1-Servers"><a href="#3-1-Servers" class="headerlink" title="3.1 Servers"></a>3.1 Servers</h2><p>​    可以通过集群进行部署，一个或者多个server都可以运行，用于存储的服务器称为brokers。kafka集群具有高度的可拓展性和容错能力，如何任何服务器发生故障，其他服务器将接管其工作。</p>
<h2 id="3-2-Clients"><a href="#3-2-Clients" class="headerlink" title="3.2 Clients"></a>3.2 Clients</h2><p>微服务或者分布式客户端并行地读取、写和处理事件流。</p>
<h2 id="3-3-主要概念和术语"><a href="#3-3-主要概念和术语" class="headerlink" title="3.3 主要概念和术语"></a>3.3 主要概念和术语</h2><p>​    事件（event）可以称之为消息。从kafka读取或者写入数据，数据要遵循一定的格式：概念上，一条消息要包含一个key，一个value、一个时间戳以及可选择的元数据信息。</p>
<p>​    在kafka中，生产者和消费者之间是独立的。生产者不必等待消费者消费数据，但Kafka会保证同一个消费者不会重复消费同一条数据。</p>
<p>​    消息会以Topic进行分组和永久存储。简单来说，Topic就像文件系统一个文件夹，消息就像是文件夹中的文件。一个Topic可以有多个生产者和多个消费者，<strong>消息被消费后不会删除</strong>，用户可以通过配置文件来决定就消息可以保存多久，但是磁盘上的消息数量不会影响kafka的性能。</p>
<p>​    一个Topic下有多个Partition（分区）。简单解释就是，一个topic里面的消息被拆分了，而且分布在了不同的broker上。这种分布式的结构在一定程度上实现了生产者和消费者同时进行消息的写入与读取。当一条消息被发布到了Topic中，它实际上是被加到了一个partition中。相同key的消息会被写入到同一个partition中，kafka保证任意消费者会严格按照消息的写入顺序来消费消息。为了保证数据的容错率和高可用性，每个Topic都有存有副本（每个partition分布在不同的broker，每个broker会存有其他partition数据的副本）</p>
<h1 id="4-安装"><a href="#4-安装" class="headerlink" title="4. 安装"></a>4. 安装</h1><p><strong>这里注意一样，kafka3.0号称不依赖zk了，但是我看了一下官网样例，还是写的带zk的部署方式，不依赖zk的只是有范本，还未有稳定版本。</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tar -zxf kafka_2.13-3.0.0.tgz</span><br><span class="line"><span class="built_in">cd</span> kafka_2.13-3.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 至少需要java8</span></span><br><span class="line">bin/zookeeper-server-start.sh config/zookeeper.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在另一台终端开启kafka broker</span></span><br><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure>
<h1 id="5-使用"><a href="#5-使用" class="headerlink" title="5. 使用"></a>5. 使用</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建topic</span></span><br><span class="line"><span class="comment"># 一个partition，一个副本，topic名称test</span></span><br><span class="line">./kafka-topics.sh --create --zookeeper ip:2182 --replication-factor 1 --partition 1 --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前kafka有多少topic</span></span><br><span class="line">./kafka-topics.sh --list --zookeeper ip:2182</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送消息</span></span><br><span class="line"><span class="comment"># kafka自带了一个producer客户端，可与从本地文件或者命令行中传递消息（把内容以消息的形式发送到kafka集群）</span></span><br><span class="line"><span class="comment"># 发送两条消息</span></span><br><span class="line">./kafka-console-producer.sh --broker-list ip:9092 --topic <span class="built_in">test</span></span><br><span class="line">&gt; message1</span><br><span class="line">&gt; message2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费消息</span></span><br><span class="line"><span class="comment"># kafka携带了一个命令行客户端，会将获取到内容在命令行输出，默认消费最新消息</span></span><br><span class="line"><span class="comment"># 方式一：从最后一条消息的偏移量+1开始消费</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server ip:9092 --topic <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 方式二：从头开始消费</span></span><br><span class="line">./kafka-console-consumer.sh --bootstarp-server ip:9092 --from-beginning --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure>
<h2 id="5-1-消费者的几个注意点："><a href="#5-1-消费者的几个注意点：" class="headerlink" title="5.1 消费者的几个注意点："></a>5.1 消费者的几个注意点：</h2><ul>
<li>消息是持久化存储的</li>
<li>消费是顺序存储的，先进先出</li>
<li>消息有偏移量</li>
<li>消息可以指定偏移量进行消费</li>
</ul>
<h1 id="6-顺序消费原理"><a href="#6-顺序消费原理" class="headerlink" title="6. 顺序消费原理"></a>6. 顺序消费原理</h1><p>kafka安装时的配置文件中指定的<code>log.dir</code>是kafka保存消息的路径。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># log.dir 内部</span></span><br><span class="line">默认有一个主题：__consumer_offsets，这个主题有多个分区，里面存放着消费者维护的偏移量。</span><br><span class="line"><span class="comment"># 每个消费者消费到了某个partition的第几条数据(offset)会存储在这个主题里面，以便于恢复</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>主题：</span><br><span class="line">	- 00000.index <span class="comment"># offset position（段的偏移）</span></span><br><span class="line">	- 00000.log <span class="comment"># 消息本体</span></span><br><span class="line">	- 00000.timestamp</span><br><span class="line">	</span><br><span class="line"><span class="comment"># .log文件其实就是分段(segment)，分段文件的大小可以在server.properties里面配置，默认1GB</span></span><br><span class="line"><span class="comment"># 查看分段文件</span></span><br><span class="line">./kafka-run-class.sh kafka.tools.DumpLogSegments --files 00000.log --<span class="built_in">print</span>-data-log </span><br><span class="line"><span class="comment"># segment结构如下：</span></span><br><span class="line">	- offset: 相对于该分区的偏移值，可以理解成第几条消息</span><br><span class="line">	- position: 相对于当前segment的偏移值</span><br><span class="line">	- CreateTime: 记录创建的时间</span><br><span class="line">	- isValid: 表示key的长度</span><br><span class="line">	- valuesize: 表示value的长度</span><br><span class="line">	- magic: 本次发布的kafka服务协议版本号</span><br><span class="line">	- compressscodec: 压缩工具</span><br><span class="line">	- producedId: 生产者ID（用于幂等）</span><br><span class="line">	- sequence: 消息的序列号（用于幂等）</span><br><span class="line">	- payload: 表示具体的消息</span><br></pre></td></tr></table></figure>
<p>原理：</p>
<ul>
<li>生产者将消息发送给broker，broker将消息保存在本地的日志文件中</li>
<li>消息的保存是有时序的，通过offset偏移量来保证消息的有序性</li>
<li>消费者消费消息时也是通过offsets来描述当前要消费的那条消息的位置（offset+1）</li>
</ul>
<h1 id="7-单播消息和多播消息"><a href="#7-单播消息和多播消息" class="headerlink" title="7. 单播消息和多播消息"></a>7. 单播消息和多播消息</h1><p>在一个topic中，启动两个消费者，一个生产者，问：生产者发送消息，这条消息是否会被两个消费者消费？</p>
<h2 id="7-1-单播消息"><a href="#7-1-单播消息" class="headerlink" title="7.1 单播消息"></a>7.1 单播消息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 单播消息</span></span><br><span class="line"><span class="comment"># consumer-1</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server ip:9092 --consumer-property group.id=testGroup --topic <span class="built_in">test</span></span><br><span class="line"><span class="comment"># consumer-2</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server ip:9092 --consumer-property group.id=testGroup --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">&gt; 生产者发送了消息</span><br><span class="line">&gt; message1</span><br><span class="line">&gt; message2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发现消费者group中只有一个消费者会受到订阅的test主题的消息，而且这个消费者还不会变（因为test主题只有一个partition）</span></span><br><span class="line"><span class="comment"># 可以理解成这个消费者订阅了这个partition</span></span><br></pre></td></tr></table></figure>
<h2 id="7-2-多播消息"><a href="#7-2-多播消息" class="headerlink" title="7.2 多播消息"></a>7.2 多播消息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 多播消息</span></span><br><span class="line"><span class="comment"># consumer-1</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server ip:9092 --consumer-property group.id=testGroup1 --topic <span class="built_in">test</span></span><br><span class="line"><span class="comment"># consumer-2</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server ip:9092 --consumer-property group.id=testGroup2 --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">&gt; 生产者发送了消息</span><br><span class="line">&gt; message1</span><br><span class="line">&gt; message2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个消费者都收到了消息</span></span><br></pre></td></tr></table></figure>
<h2 id="7-3-解释"><a href="#7-3-解释" class="headerlink" title="7.3 解释"></a>7.3 解释</h2><p>​    概念就是消费者组，一个消费者组可以看成是一个消费者，一个消费者是不能重复消费消息的，消费者组是为了满足并发消费消息，从而实现高吞吐的设计。一个partition效果不明显，但是当partition多了，一个消费者组中不同的消费者可以通过某个topic的消息效率。</p>
<h2 id="7-4-查看消费组及信息"><a href="#7-4-查看消费组及信息" class="headerlink" title="7.4 查看消费组及信息"></a>7.4 查看消费组及信息</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看当前节点下有多少消费者组</span></span><br><span class="line">./kafka-consumer-groups.sh --bootstrap-server ip:9092 --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看消费者组中的具体信息：当前偏移量、最后一条消息的偏移量</span></span><br><span class="line">./kafka-consumer-groups.sh --bootstrap-server ip:9092 --describe --group testGroup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到以下信息</span></span><br><span class="line">GROUP TOPIC PARTITION CURRENT-OFFSET LOG-END-OFFSET LAG(还有多少未被消费的消息) CONSUMER-ID  HOST CLIENT-ID</span><br><span class="line"><span class="comment"># 如果消费者挂了，以上信息依然会存在，生产者可以继续生产消息，但是CURRENT-OFFSET是不动的，因为消费者没有消费消息</span></span><br></pre></td></tr></table></figure>
<p>重点关注：</p>
<ul>
<li>CURRENT-OFFSET：最后被消费的消息的偏移量</li>
<li>LOG-END-OFFSET：最后一条消息的偏移量</li>
<li>LAG：当前消费组未消费的消息数量</li>
</ul>
<h1 id="8-主题与分区"><a href="#8-主题与分区" class="headerlink" title="8. 主题与分区"></a>8. 主题与分区</h1><h2 id="8-1-Topic"><a href="#8-1-Topic" class="headerlink" title="8.1 Topic"></a>8.1 Topic</h2><p>​    主题就是Kafka消息的<strong>逻辑</strong>划分，一个主题下相当与一个类别。Kafka通过Topic将消息进行分类，不同的Topic会被订阅该Topic的消费者消费。</p>
<p>​    如果一个Topic中的消息巨多无比（可能有几个T），而消息是会被保存到<code>.log</code>文件中的，用一个文件，压力太大。为了解决这个问题，kafka使用了partition来分布式存储这些消息。</p>
<h2 id="8-2-Partition"><a href="#8-2-Partition" class="headerlink" title="8.2 Partition"></a>8.2 Partition</h2><ul>
<li>分区存储，可以解决统一存储文件过大的问题</li>
<li>提高了读写的吞吐量</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 主题多分区</span></span><br><span class="line">./kafka-topics.sh --create --zookeeper ip:2181 --replication-factor 1 --partitions 2 --topic test2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看log文件，可以看见如果有多个partition，一个topic其实就会有两个文件夹存在磁盘上</span></span><br><span class="line">test2-0</span><br><span class="line">	- 0000.index</span><br><span class="line">	- 0000.log</span><br><span class="line">	- 0000.timestamp</span><br><span class="line">	</span><br><span class="line">test2-1</span><br><span class="line">		- 0000.index</span><br><span class="line">	- 0000.log</span><br><span class="line">	- 0000.timestamp</span><br></pre></td></tr></table></figure>
<p><strong>小细节，大改变：</strong></p>
<ul>
<li>kafka内部默认有50个主题__consumer_offsets，这些主题用存储消费者消费消息的偏移量</li>
<li>消费者会定期把自己消费分区的offset提交给kafka内部的主题__consumer_offsets，提交的时候，key是<code>consumerGroupId+topic+分区号</code>，value是当前分区的offset。（消费者）</li>
<li>__conusmer_offsets有多个分区（可以server.properties里面配置，默认50），消费者通过<code>hash(consumerGroupId)%分区数</code>来确定消息被存储到哪个分区</li>
<li>kafka会定期消费已经消费过的数据，默认是7天，旧消息会被删除</li>
<li>__consumer_offsets里面有多个分区是为了提高并发效率，很多消费者可以同时写入自己的offset</li>
</ul>
<h1 id="9-集群与副本"><a href="#9-集群与副本" class="headerlink" title="9. 集群与副本"></a>9. 集群与副本</h1><h2 id="9-1-搭建集群（伪），三个broker"><a href="#9-1-搭建集群（伪），三个broker" class="headerlink" title="9.1 搭建集群（伪），三个broker"></a>9.1 搭建集群（伪），三个broker</h2><p>准备3个server.properties，这里演示建在一台机器上的伪集群</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># server.properties</span></span><br><span class="line">broker.id = 0</span><br><span class="line">listeners=PLAINEXT://ip:9092</span><br><span class="line">log.dir=/usr/<span class="built_in">local</span>/data/kafka-logs-0</span><br><span class="line"></span><br><span class="line"><span class="comment"># server1.properties</span></span><br><span class="line">broker.id = 1</span><br><span class="line">listeners=PLAINEXT://ip:9093</span><br><span class="line">log.dir=/usr/<span class="built_in">local</span>/data/kafka-logs-1</span><br><span class="line"></span><br><span class="line"><span class="comment"># serve2r.properties</span></span><br><span class="line">broker.id = 2</span><br><span class="line">listeners=PLAINEXT://ip:9094</span><br><span class="line">log.dir=/usr/<span class="built_in">local</span>/data/kafka-logs-2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动三个kafka服务器</span></span><br><span class="line">bin/kafka-server-start.sh -deamon config/server.properties</span><br><span class="line">bin/kafka-server-start.sh -deamon config/server1.properties</span><br><span class="line">bin/kafka-server-start.sh -deamon config/server2.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以登录zkClient来看一下节点有没有顺利注册(brokers/ids下有三个znode(0, 1, 2))</span></span><br></pre></td></tr></table></figure>
<h2 id="9-2-副本的概念"><a href="#9-2-副本的概念" class="headerlink" title="9.2 副本的概念"></a>9.2 副本的概念</h2><p>​    副本是为主题中的分区创建多个备份，多个副本在Kafka集群中多个broker中，<strong>会有一个副本是Leader</strong>，其他是Follower，副本数量一般不超过Broker的数量，不然没有意义。</p>
<p>创建1个主题，2个分区，三个副本</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./kafka-topics.sh --create --zookeeper ip:2181 --replication-factor 3 --partitions 2 --topic my-replica-topic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看主题</span></span><br><span class="line">./kafka-topics.sh --describe --zookeeper ip:2181 --topic my-replica-topic</span><br></pre></td></tr></table></figure>
<p>结构：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Topic:my-replica-topic</th>
<th>PartitionCount:2</th>
<th>ReplicationFactor:3</th>
<th>Configs:</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>- Topic：my-replica-topic</td>
<td>- Partition: 0</td>
<td>- Leader:2</td>
<td>Replicas: 2,0,1</td>
<td>lsr:2,0,1</td>
</tr>
<tr>
<td>- Topic：my-replica-topic</td>
<td>- Partition: 2</td>
<td>- Leader:0</td>
<td>Replicas: 0,1,2</td>
<td>lsr:0,1,2</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>Leader负责读写</strong>，Follower中的副本会同步Leader中的数据</li>
<li>不同Partition所在的Broker是不一样的</li>
<li>每个Partition的Leader可能都不一样，说明Leader不是Topic的概念。Leader所在Broker负责该Partition的读写，也负责Follower的数据同步</li>
<li>lsr：可以同步或者已经同步的节点存放在isr中，如果一个节点同步性能很差，该节点会被T掉</li>
<li>Leader挂掉，新Leader会在lsr集合中选举</li>
</ul>
<h1 id="10-Kafka集群的消息发送和消费"><a href="#10-Kafka集群的消息发送和消费" class="headerlink" title="10. Kafka集群的消息发送和消费"></a>10. Kafka集群的消息发送和消费</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 发送</span></span><br><span class="line">./kafka-console-producer.sh --broker-list ip:9092.ip:9093,ip:9094 --topic my-replica-topic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单消费者</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-list ip:9092.ip:9093,ip:9094  --from-beginning --topic my-replica-topic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个组两个消费者</span></span><br><span class="line"><span class="comment"># 消费者1</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-list ip:9092.ip:9093,ip:9094 --consumer-property group.id=testGroup1 --from-beginning --topic my-replica-topic</span><br><span class="line"><span class="comment"># 消费者2</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-list ip:9092.ip:9093,ip:9094 --consumer-property group.id=testGroup1 --from-beginning --topic my-replica-topic</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<ul>
<li>一个Partition最多被一个消费组里的一个消费者消费，因为要保证消息消费的顺序性（想想并发）</li>
<li>一个消费者可以消费多个Partition</li>
<li>Kafka只能保证Partition中局部的消息顺序，不能保证Topic中的消息顺序消费</li>
<li>消费组中的消费者的数量一般不会多于Partition的数量，因为会有消费者消费不到消息</li>
<li>如果某个消费者挂了，就会触发rebalance机制，让其他消费者消费其对应的partition</li>
</ul>
<h1 id="10-Kafka-Java生产者实现"><a href="#10-Kafka-Java生产者实现" class="headerlink" title="10. Kafka Java生产者实现"></a>10. Kafka Java生产者实现</h1><h2 id="10-1-实现"><a href="#10-1-实现" class="headerlink" title="10.1 实现"></a>10.1 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依赖</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">	&lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;</span><br><span class="line">	&lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;</span><br><span class="line">	&lt;version&gt;与kafka版本一致&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySimpleProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TOPIC_NAME = <span class="string">"memo-kafka-test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 设置参数</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"192.168.1.249:9092,192.168.1.249:9093,192.168.1.249:9094"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把key和value从字符串序列转成字节数组</span></span><br><span class="line">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置同步消息的ack</span></span><br><span class="line">        props.put(ProducerConfig.ACKS_CONFIG, <span class="string">"1"</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 发送失败会重试，默认重试间隔100ms，重试能保证消息发送的可靠性，但也会造成消息的重复发送，</span></span><br><span class="line"><span class="comment">         * 如网络抖动，所以需要在接收者那边做好消息接收的幂等性处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        props.put(ProducerConfig.RETRIES_CONFIG, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 发送消息重试间隔时间，设为300</span></span><br><span class="line">        props.put(ProducerConfig.RETRY_BACKOFF_MS_CONFIG, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 设置消息发送的本地缓冲区，如果设置了该缓冲区，消息会先发送到本地缓冲区(默认32M)，</span></span><br><span class="line"><span class="comment">         * kafka生产者客户端会启一条本地线程拉16kb的数据发送给kafka，如果消息没达到16kb，该线程</span></span><br><span class="line"><span class="comment">         * 10毫秒以后也会将数据发送</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class="number">10240</span>);</span><br><span class="line">        props.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="number">16384</span>);</span><br><span class="line">        props.put(ProducerConfig.LINGER_MS_CONFIG, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建生产消息的客户端，传入参数</span></span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建消息</span></span><br><span class="line">        <span class="comment">// key的作用是决定往哪个分区上发，value是具体消息内容</span></span><br><span class="line">        ProducerRecord&lt;String, String&gt; producerRecord = <span class="keyword">new</span> ProducerRecord&lt;&gt;(TOPIC_NAME, <span class="string">"mytestKey"</span>, <span class="string">"hello kafka2"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 发送消息,得到消息发送的元数据并输出</span></span><br><span class="line">        RecordMetadata recordMetadata = producer.send(producerRecord).get();</span><br><span class="line">        System.out.println(<span class="string">"**********************************"</span>);</span><br><span class="line">        System.out.println(<span class="string">"同步方式发送结果："</span> + <span class="string">"topic-"</span> + recordMetadata.topic()</span><br><span class="line">                + <span class="string">"|partition-"</span> + recordMetadata.partition() + <span class="string">"|offset-"</span> + recordMetadata.offset());</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-2-同步发送和异步发送"><a href="#10-2-同步发送和异步发送" class="headerlink" title="10.2 同步发送和异步发送"></a>10.2 同步发送和异步发送</h2><p>同步发送和异步发送都是针对生产者和Kafka服务端的，同步用的比较多，异步的性能提升不明显，反而会出现消息丢失的可能。</p>
<h3 id="10-2-1-同步发送"><a href="#10-2-1-同步发送" class="headerlink" title="10.2.1 同步发送"></a>10.2.1 同步发送</h3><p>如果生产者发送消息，没有收到kafka给服务端的<code>ack</code>，生产者会阻塞，阻塞到3S的时间（可以配置），如果还没有收到消息，则会进行重试，重试的次数默认也为3个，还不行，就会报错了。</p>
<h3 id="10-2-2-异步发送"><a href="#10-2-2-异步发送" class="headerlink" title="10.2.2 异步发送"></a>10.2.2 异步发送</h3><p>不会确认收到kafka的<code>ack</code>，会触发一个回调函数（不会阻塞）。生产者发送完消息可以做别的事情，broker收到消息后就会触发回调（callback）。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">producer.send(producerRecord, (recordMetadata, e) -&gt; &#123;</span><br><span class="line">               <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   System.err.println(<span class="string">"发送消息失败:"</span> + Arrays.toString(e.getStackTrace()));</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (recordMetadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   System.out.println(<span class="string">"异步方式发送结果："</span> + <span class="string">"topic-"</span> + recordMetadata.topic()</span><br><span class="line">                           + <span class="string">"|partition-"</span> + recordMetadata.partition() + <span class="string">"|offset-"</span> + recordMetadata.offset());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h2 id="10-3-关于生产者ack配置"><a href="#10-3-关于生产者ack配置" class="headerlink" title="10.3 关于生产者ack配置"></a>10.3 关于生产者ack配置</h2><p><code>ack</code>就是在<strong>同步发送</strong>中，生产者给kafka发送消息后的，kafka给的一个确认信号。</p>
<p><code>ack</code>会有三个参数配置：</p>
<ul>
<li>ack=0：kafka不需要任何broker收到消息，会立即返回ack给生产者（最容易丢消息，但是效率最高）。</li>
<li>ack=1：leader已经收到消息，并把消息写入到本地的log中，才会返回ack生产者。性能和安全性是最均衡的。</li>
<li>ack=-1/all：里面有默认配置<code>min.insync.replicas=2(默认为1，推荐配置大于等于2)</code>，leader同步2个副本之后（此时集群中有2个broker已完成数据的接收），才会返回ack给生产者。最安全但性能最差。默认是1，那么和ack=1是一样的，因为leader本身就是1个副本。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 配置同步消息的ack</span></span><br><span class="line">     props.put(ProducerConfig.ACKS_CONFIG, <span class="string">"1"</span>);</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 发送失败会重试，默认重试间隔100ms，重试能保证消息发送的可靠性，但也会造成消息的重复发送，</span></span><br><span class="line"><span class="comment">      * 如网络抖动，所以需要在接收者那边做好消息接收的幂等性处理</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     props.put(ProducerConfig.RETRIES_CONFIG, <span class="number">3</span>);</span><br><span class="line">     <span class="comment">// 发送消息重试间隔时间，设为300</span></span><br><span class="line">     props.put(ProducerConfig.RETRY_BACKOFF_MS_CONFIG, <span class="number">300</span>);</span><br></pre></td></tr></table></figure>
<h2 id="10-4-关于消息发送的缓冲区"><a href="#10-4-关于消息发送的缓冲区" class="headerlink" title="10.4 关于消息发送的缓冲区"></a>10.4 关于消息发送的缓冲区</h2><ul>
<li>kafka默认会创建一个消息缓冲区，默认为32MB（可配置）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置消息发送的本地缓冲区，如果设置了该缓冲区，消息会先发送到本地缓冲区(默认32M)，</span></span><br><span class="line"><span class="comment"> * kafka生产者客户端会启一条本地线程拉16kb的数据发送给kafka，如果消息没达到16kb，该线程</span></span><br><span class="line"><span class="comment"> * 10毫秒以后也会将数据发送</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class="number">33554432</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>kafka客户端本地线程会去缓冲区一次拉16kb的数据，发送给broker</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">props.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="number">16384</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果线程拉不到16kb的数据，间隔10ms也会发送给broker</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">props.put(ProducerConfig.LINGER_MS_CONFIG, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<h1 id="11-Java客户端消费者的实现"><a href="#11-Java客户端消费者的实现" class="headerlink" title="11. Java客户端消费者的实现"></a>11. Java客户端消费者的实现</h1><h2 id="11-1-实现"><a href="#11-1-实现" class="headerlink" title="11.1 实现"></a>11.1 实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 依赖也是kafka-clients</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySimpleConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TOPIC_NAME = <span class="string">"memo-kafka-test"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String CONSUMER_GROUP_NAME = <span class="string">"memoGroup"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 设置参数</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"192.168.1.249:9092,192.168.1.249:9093,192.168.1.249:9094"</span>);</span><br><span class="line">        <span class="comment">// 消费者组</span></span><br><span class="line">        props.put(ConsumerConfig.GROUP_ID_CONFIG, CONSUMER_GROUP_NAME);</span><br><span class="line">        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        <span class="comment">// 开启offset自动提交，默认是true</span></span><br><span class="line">        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="string">"true"</span>);</span><br><span class="line">        <span class="comment">// 设置自动提交的时间间隔，默认1000ms</span></span><br><span class="line">        props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次poll最大拉取消息的条数，可以根据消费的速度来设置，默认500</span></span><br><span class="line">        props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, <span class="number">500</span>);</span><br><span class="line">        <span class="comment">// 如果两次poll的时间如果超过了30s的时间间隔，kafka会人认为其消费能力过弱，会把其T出消费者组，并把分区分给其他消费者（rebalance）。</span></span><br><span class="line">        props.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, <span class="number">30</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// consumer给broker发送心跳的间隔时间</span></span><br><span class="line">        props.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// kafka如果10秒没有收到消费者的心跳，则会把消费者踢出消费组，进行rebalance</span></span><br><span class="line">        props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, <span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 订阅主题列表</span></span><br><span class="line">        <span class="comment">// consumer.subscribe(Collections.singletonList(TOPIC_NAME));</span></span><br><span class="line">        <span class="comment">// 指定分区消费</span></span><br><span class="line">        consumer.assign(Collections.singleton(<span class="keyword">new</span> TopicPartition(TOPIC_NAME, <span class="number">1</span>)));</span><br><span class="line">        <span class="comment">// 消息回溯消费</span></span><br><span class="line">        consumer.seekToBeginning(Collections.singleton(<span class="keyword">new</span> TopicPartition(TOPIC_NAME, <span class="number">1</span>)));</span><br><span class="line">        <span class="comment">// 从partition1的offset=5开始消费</span></span><br><span class="line">        <span class="comment">//consumer.seek(new TopicPartition(TOPIC_NAME, 1), 5);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从指定时间点开始消费</span></span><br><span class="line">        List&lt;PartitionInfo&gt; topicPartitions = consumer.partitionsFor(TOPIC_NAME);</span><br><span class="line">        <span class="keyword">long</span> fetchDateTime = <span class="keyword">new</span> Date().getTime() - <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line">        Map&lt;TopicPartition, Long&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (PartitionInfo partition : topicPartitions) &#123;</span><br><span class="line">            map.put(<span class="keyword">new</span> TopicPartition(TOPIC_NAME, partition.partition()), fetchDateTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 根据时间找偏移量</span></span><br><span class="line"><span class="comment">        Map&lt;TopicPartition, OffsetAndTimestamp&gt; parMap = consumer.offsetsForTimes(map);</span></span><br><span class="line"><span class="comment">        for (Map.Entry&lt;TopicPartition, OffsetAndTimestamp&gt; entry : parMap.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">            TopicPartition topicPartition = entry.getKey();</span></span><br><span class="line"><span class="comment">            OffsetAndTimestamp offsetAndTimestamp = entry.getValue();</span></span><br><span class="line"><span class="comment">            if (topicPartition == null || offsetAndTimestamp == null) continue;</span></span><br><span class="line"><span class="comment">            long offset = offsetAndTimestamp.offset();</span></span><br><span class="line"><span class="comment">            System.out.println("partition-" + topicPartition.partition() + "|offset-" + offset);</span></span><br><span class="line"><span class="comment">            // 指定offset开始消息</span></span><br><span class="line"><span class="comment">            consumer.assign(Collections.singletonList(topicPartition));</span></span><br><span class="line"><span class="comment">            consumer.seek(topicPartition, offset);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 3. poll() API是拉取消息的长轮询,如果poll在1000ms内没有拉满，就会在1000ms之内一直等待</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                <span class="comment">// 消费</span></span><br><span class="line">                System.out.printf(<span class="string">"收到消息: partition=%d, offset=%d, key=%s, value=%s%n"</span>,</span><br><span class="line">                        record.partition(), record.offset(), record.key(), record.value());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            // 消费结束后</span></span><br><span class="line"><span class="comment">            if (!records.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">                // 同步提交，当前线程会阻塞到offset提交成功</span></span><br><span class="line"><span class="comment">                // consumer.commitAsync();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                // 异步提交</span></span><br><span class="line"><span class="comment">                consumer.commitAsync((map, e) -&gt; &#123;</span></span><br><span class="line"><span class="comment">                    if (e != null) &#123;</span></span><br><span class="line"><span class="comment">                        e.printStackTrace();</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-2-消费者的自动提交和手动提交"><a href="#11-2-消费者的自动提交和手动提交" class="headerlink" title="11.2 消费者的自动提交和手动提交"></a>11.2 消费者的自动提交和手动提交</h2><p>消费者无论是自动提交还是手动提交，都需要把所属的<strong>消费组+消费的某个主题+消费的某个分区及消费的偏移量</strong>，这样的信息提交到集群的__consuemr_offset主题里面。</p>
<p>详细点来：消费者会把offset提交到borker-0上的__consumer_offset主题上，这个broker-0是一个controller。消费者要根据offset进行消费，消费者是先把消息给poll下来，然后不管有没有消费，就会定时把当前偏移量给提交给offset主题（自动提交）；手动提交就是把消息消费时或者消费完再手动提交offset。</p>
<h3 id="11-2-1-自动提交"><a href="#11-2-1-自动提交" class="headerlink" title="11.2.1 自动提交"></a>11.2.1 自动提交</h3><p>消费者poll到消息后默认情况下，会自动向broker的__consumer_offset主题提交当前主题-分区消费的偏移量。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启offset自动提交，默认是true</span></span><br><span class="line">props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="string">"true"</span>);</span><br><span class="line"><span class="comment">// 设置自动提交的时间间隔，默认1000ms</span></span><br><span class="line">props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class="string">"1000"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong>自动提交可能会丢消息，当消费者刚提交offset之后，没来得及消费就挂了，下一个消费者会从已经提交的offset的下一个位置开始消费消息。未被消费的消息就丢失掉了。</p>
<h3 id="11-2-2-手动提交"><a href="#11-2-2-手动提交" class="headerlink" title="11.2.2 手动提交"></a>11.2.2 手动提交</h3><ul>
<li>设置手动提交参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 开启offset手动提交</span></span><br><span class="line">props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="string">"false"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>手动同步提交</li>
</ul>
<p>会等待broker-0返回ack</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消费结束后</span></span><br><span class="line"><span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">	<span class="comment">// 同步提交，当前线程会阻塞到offset提交成功</span></span><br><span class="line">	consumer.commitAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>手动异步提交</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 消费结束后</span></span><br><span class="line"><span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line">	<span class="comment">// 异步提交</span></span><br><span class="line">	consumer.commitAsync((map, e) -&gt; &#123;</span><br><span class="line">		<span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 异步提交失败处理逻辑</span></span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="11-3-长轮询消息"><a href="#11-3-长轮询消息" class="headerlink" title="11.3 长轮询消息"></a>11.3 长轮询消息</h2><ul>
<li>默认情况下，消费者一次会poll500条消息</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一次poll最大拉取消息的条数，可以根据消费的速度来设置，默认500</span></span><br><span class="line">props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, <span class="number">500</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>代码中设置了长轮询的时间是1000ms</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3. poll() API是拉取消息的长轮询,如果poll在1000ms内没有拉到数据，则返回空</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br></pre></td></tr></table></figure>
<p>意味着：</p>
<ul>
<li><ul>
<li>如果一次poll到了数据，最大为500条，就会直接执行for循环</li>
<li>如果1000ms内没poll到数据，则返回空</li>
</ul>
</li>
<li><p>如果两次poll的时间间隔太长（默认30s），消费者会被kafkaT出消费者组</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果两次poll的时间如果超过了30s的时间间隔，kafka会人认为其消费能力过弱，会把其T出消费者组，并把分区分给其他消费者（rebalance）。</span></span><br><span class="line">props.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, <span class="number">30</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h1 id="12-消费者的其他配置"><a href="#12-消费者的其他配置" class="headerlink" title="12. 消费者的其他配置"></a>12. 消费者的其他配置</h1><h2 id="12-1-健康状态检查"><a href="#12-1-健康状态检查" class="headerlink" title="12.1 健康状态检查"></a>12.1 健康状态检查</h2><p>消费者每隔1s像kafka集群发送心跳，集群发现如果有10s没有续约的消费者，将被T出消费组，触发该消费组的rebalance。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// consumer给broker发送心跳的间隔时间</span></span><br><span class="line">props.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// kafka如果10秒没有收到消费者的心跳，则会把消费者踢出消费组，进行rebalance</span></span><br><span class="line">props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, <span class="number">10</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h2 id="12-2-指定分区消费"><a href="#12-2-指定分区消费" class="headerlink" title="12.2 指定分区消费"></a>12.2 指定分区消费</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定分区消费</span></span><br><span class="line">consumer.assign(Collections.singleton(<span class="keyword">new</span> TopicPartition(TOPIC_NAME, <span class="number">0</span>)));</span><br></pre></td></tr></table></figure>
<h2 id="12-3-消息回溯消费"><a href="#12-3-消息回溯消费" class="headerlink" title="12.3 消息回溯消费"></a>12.3 消息回溯消费</h2><p>每次消费都从offset=0开始消费，需要先指定分区，再seek</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定分区消费</span></span><br><span class="line">consumer.assign(Collections.singleton(<span class="keyword">new</span> TopicPartition(TOPIC_NAME, <span class="number">1</span>)));</span><br><span class="line"><span class="comment">// 消息回溯消费</span></span><br><span class="line">onsumer.seekToBeginning(Collections.singleton(<span class="keyword">new</span> TopicPartition(TOPIC_NAME, <span class="number">1</span>)));</span><br></pre></td></tr></table></figure>
<h2 id="12-4-指定offset消费"><a href="#12-4-指定offset消费" class="headerlink" title="12.4 指定offset消费"></a>12.4 指定offset消费</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 指定分区消费</span></span><br><span class="line">consumer.assign(Collections.singleton(<span class="keyword">new</span> TopicPartition(TOPIC_NAME, <span class="number">1</span>)));</span><br><span class="line"><span class="comment">// 消息回溯消费</span></span><br><span class="line"><span class="comment">// consumer.seekToBeginning(Collections.singleton(new TopicPartition(TOPIC_NAME, 1)));</span></span><br><span class="line"><span class="comment">// 从partition1的offset=5开始消费</span></span><br><span class="line">consumer.seek(<span class="keyword">new</span> TopicPartition(TOPIC_NAME, <span class="number">1</span>), <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h2 id="12-5-从指定时间点开始消费"><a href="#12-5-从指定时间点开始消费" class="headerlink" title="12.5 从指定时间点开始消费"></a>12.5 从指定时间点开始消费</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 根据时间找偏移量</span></span><br><span class="line">Map&lt;TopicPartition, OffsetAndTimestamp&gt; parMap = consumer.offsetsForTimes(map);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;TopicPartition, OffsetAndTimestamp&gt; entry : parMap.entrySet()) &#123;</span><br><span class="line">	TopicPartition topicPartition = entry.getKey();</span><br><span class="line">	OffsetAndTimestamp offsetAndTimestamp = entry.getValue();</span><br><span class="line">	<span class="keyword">if</span> (topicPartition == <span class="keyword">null</span> || offsetAndTimestamp == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line">	<span class="keyword">long</span> offset = offsetAndTimestamp.offset();</span><br><span class="line">	System.out.println(<span class="string">"partition-"</span> + topicPartition.partition() + <span class="string">"|offset-"</span> + offset);</span><br><span class="line">	<span class="comment">// 指定offset开始消息</span></span><br><span class="line">	consumer.assign(Collections.singletonList(topicPartition));</span><br><span class="line">	consumer.seek(topicPartition, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="12-6-新消费者组的offset"><a href="#12-6-新消费者组的offset" class="headerlink" title="12.6 新消费者组的offset"></a>12.6 新消费者组的offset</h2><p>之前命令行的时候搞过的就是这个<code>--from-beginning</code>还记得吗。</p>
<p>默认的消费是最后的<code>offset+1</code>。知道这个就可以理解这个配置了。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* latest(默认)：新消费者组从最后offset+1开始消费</span></span><br><span class="line"><span class="comment">* earliest：第一次从头，然后跟着offset，注意和seekBeginning区分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">"earliest"</span>);</span><br></pre></td></tr></table></figure>
<h1 id="13-SpringBoot集成Kafka"><a href="#13-SpringBoot集成Kafka" class="headerlink" title="13. SpringBoot集成Kafka"></a>13. SpringBoot集成Kafka</h1><h2 id="13-1-基本配置"><a href="#13-1-基本配置" class="headerlink" title="13.1 基本配置"></a>13.1 基本配置</h2><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">依赖</span></span><br><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line">	<span class="string">&lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;</span></span><br><span class="line">	<span class="string">&lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br><span class="line">      </span><br><span class="line"><span class="string">//</span> <span class="string">配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.249</span><span class="string">:9092,192.168.1.249:9093,192.168.1.249:9094</span></span><br><span class="line">    <span class="attr">producer:</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">batch-size:</span> <span class="number">16384</span> <span class="comment"># 16k</span></span><br><span class="line">      <span class="attr">buffer-memory:</span> <span class="number">33554432</span> <span class="comment"># 32M</span></span><br><span class="line">      <span class="attr">acks:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">key-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">      <span class="attr">value-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="attr">group-id:</span> <span class="string">default-group</span></span><br><span class="line">      <span class="attr">enable-auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">auto-offset-reset:</span> <span class="string">earliest</span></span><br><span class="line">      <span class="attr">key-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">      <span class="attr">value-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">      <span class="attr">max-poll-records:</span> <span class="number">500</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="comment"># TIME: 当一批poll()的数据被消费者Listener处理后，距离上次提交时间大于TIME时提交offset</span></span><br><span class="line">      <span class="comment"># COUNT: 当一批poll()的数据被消费者Listener处理后，处理record数量大于等于COUNT时提交offset</span></span><br><span class="line">      <span class="comment"># COUNT_TIME: 满足TIME或者COUNT</span></span><br><span class="line">      <span class="comment"># MANUAL: 当一批poll()的数据被消费者Listener处理后，手动调用acknowledge()提交offset</span></span><br><span class="line">      <span class="comment"># BATCH：当一批poll()数据被消费者Listener处理后，自动提交offset</span></span><br><span class="line">      <span class="comment"># record：当每一条记录被处理后，自动提交offset</span></span><br><span class="line">      <span class="attr">ack-mode:</span> <span class="string">MANUAL_IMMEDIATE</span> <span class="comment"># 手动调用acknowledge()后（处理一条消息后），提交offset</span></span><br></pre></td></tr></table></figure>
<h2 id="13-2-生产者"><a href="#13-2-生产者" class="headerlink" title="13.2 生产者"></a>13.2 生产者</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/msg"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyKafkaController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TOPIC_NAME = <span class="string">"memo-kafka-test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/send"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        kafkaTemplate.send(TOPIC_NAME, <span class="string">"KEY"</span>, <span class="string">"this kafka sb test msg!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="13-3-消费者"><a href="#13-3-消费者" class="headerlink" title="13.3 消费者"></a>13.3 消费者</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里是一条条处理的，一次poll的消息有很多，这里一条条消费啦，thanks for springboot</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record：收到的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack: 针对手动提交很作用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@KafkaListener</span>(topics = <span class="string">"memo-kafka-test"</span>, groupId = <span class="string">"memoGroup1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenGroup</span><span class="params">(ConsumerRecord&lt;String, String&gt; record, Acknowledgment ack)</span> </span>&#123;</span><br><span class="line">        String value = record.value();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        System.out.println(record);</span><br><span class="line">        <span class="comment">// 手动提交offset</span></span><br><span class="line">        ack.acknowledge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="13-4-消费者的详细配置"><a href="#13-4-消费者的详细配置" class="headerlink" title="13.4 消费者的详细配置"></a>13.4 消费者的详细配置</h1><h3 id="13-4-1-设置多主题，指定分区，指定offset，同组下的消费者个数（并发消费数）"><a href="#13-4-1-设置多主题，指定分区，指定offset，同组下的消费者个数（并发消费数）" class="headerlink" title="13.4.1 设置多主题，指定分区，指定offset，同组下的消费者个数（并发消费数）"></a>13.4.1 设置多主题，指定分区，指定offset，同组下的消费者个数（并发消费数）</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="comment">// 1个消费者，消费"memo-kafka-test"两个分区，"test"一个分区（并从offset=1开始消费） </span></span><br><span class="line"><span class="meta">@KafkaListener</span>(groupId = <span class="string">"memoGroup2"</span>, topicPartitions = &#123;</span><br><span class="line">           <span class="meta">@TopicPartition</span>(topic = <span class="string">"memo-kafka-test"</span>, partitions = &#123;<span class="string">"0"</span>, <span class="string">"1"</span>&#125;),</span><br><span class="line">           <span class="meta">@TopicPartition</span>(topic = <span class="string">"test"</span>, partitionOffsets = <span class="meta">@PartitionOffset</span>(partition = <span class="string">"0"</span>,initialOffset = <span class="string">"1"</span>))</span><br><span class="line">   &#125;, concurrency = <span class="string">"1"</span>)<span class="comment">// concurrency 就是同组下的消费者个数，就是并发消费数，建议小于等于分区总数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenGroupPro</span><span class="params">(ConsumerRecord&lt;String, String&gt; record, Acknowledgment ack)</span> </span>&#123;</span><br><span class="line">       String value = record.value();</span><br><span class="line">       System.out.println(value);</span><br><span class="line">       System.out.println(record);</span><br><span class="line">       <span class="comment">// 手动提交offset</span></span><br><span class="line">       ack.acknowledge();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="13-4-2-一些有关Listener的配置"><a href="#13-4-2-一些有关Listener的配置" class="headerlink" title="13.4.2 一些有关Listener的配置"></a>13.4.2 一些有关Listener的配置</h3><figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">listener:</span></span><br><span class="line">  <span class="comment"># TIME: 当一批poll()的数据被消费者Listener处理后，距离上次提交时间大于TIME时提交offset</span></span><br><span class="line">  <span class="comment"># COUNT: 当一批poll()的数据被消费者Listener处理后，处理record数量大于等于COUNT时提交offset</span></span><br><span class="line">  <span class="comment"># COUNT_TIME: 满足TIME或者COUNT</span></span><br><span class="line">  <span class="comment"># MANUAL: 当一批poll()的数据被消费者Listener处理后，手动调用acknowledge()提交offset</span></span><br><span class="line">  <span class="comment"># BATCH：当一批poll()数据被消费者Listener处理后，自动提交offset</span></span><br><span class="line">  <span class="comment"># record：当每一条记录被处理后，自动提交offset</span></span><br><span class="line">  <span class="attr">ack-mode:</span> <span class="string">MANUAL_IMMEDIATE</span> <span class="comment"># 手动调用acknowledge()后（处理一条消息后），提交offset</span></span><br></pre></td></tr></table></figure>
<h1 id="14-Kafka集群Controller、Rebalance、HW和LEO"><a href="#14-Kafka集群Controller、Rebalance、HW和LEO" class="headerlink" title="14. Kafka集群Controller、Rebalance、HW和LEO"></a>14. Kafka集群Controller、Rebalance、HW和LEO</h1><h2 id="14-1-Controller"><a href="#14-1-Controller" class="headerlink" title="14.1 Controller"></a>14.1 Controller</h2><p>​    <strong>kafka启动的时候会先向zookeeper创建一个临时序号节点，获得的序号最小的那个broker作为集群的controller，</strong>负责管理整个集群中的所有分区和副本的状态：</p>
<ul>
<li>当某个分区的leader出现故障时，由controller负责为该分区选举新的leader副本</li>
<li>当检测到某个分区的ISR集合发生变化时（broker新增或减少），由controller负责通知所有broker更新其元数据信息</li>
<li>当使用kafka-topics.sh脚本为某个topic增加分区数量时，同样还是由controller通知其他broker</li>
</ul>
<h2 id="14-2-Rebalance"><a href="#14-2-Rebalance" class="headerlink" title="14.2 Rebalance"></a>14.2 Rebalance</h2><p>前提时：消费者没有指明分区消费。当消费组里的消费者和分区关系发生变化，那么就会触发rebalance机制。</p>
<p>这个机制会重新调整消费者消费哪个分区。</p>
<p>在触发rebalance机制之前，消费者消费哪个分区有三种策略：</p>
<ul>
<li>range：通过公式来计算某个消费者消费哪个分区</li>
<li>轮询：大家轮着消费</li>
<li>sticky：在触发了rebalance之后，在消费者消费的原分区不变的基础上进行调整</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Kafka</tag>
        <tag>中间件</tag>
      </tags>
  </entry>
  <entry>
    <title>git用法浅析</title>
    <url>/2021/09/01/git%E7%94%A8%E6%B3%95%E6%B5%85%E6%9E%90/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要记录git常见的基础用法以及如何离线在linux上安装git。</p>
<p>本文旨在让人成为git使用者而不是git使用专家，所有命令基本都是充分且必要的。</p>
<blockquote>
<ol>
<li>git是什么</li>
<li>linux离线安装git</li>
<li>git基本用法</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="git是什么"><a href="#git是什么" class="headerlink" title="git是什么"></a>git是什么</h1><p>　　Git是目前世界上最先进的分布式<strong>版本控制</strong>系统。所谓版本控制，打个简单的比方：修改一份文件，我们往往会另存为很多个备份，每个备份可能代表一个版本，如图所示:</p>
<p><img src="/2021/09/01/git%E7%94%A8%E6%B3%95%E6%B5%85%E6%9E%90/multiDoc.png" alt></p>
<p>　这导致了两个严重的问题：第一，你不知道这些文件的每个版本都有谁改动过；第二，过了一段时间，你自己都不知道这些文件代表啥， <strong>但是你还不敢删。</strong>我们希望文件的管理是这样的：<strong>每次文件的改动都有相应的记录，不仅记录了是谁改了文件，还要有改动文件的说明</strong>，看起来就像这样。</p>
<p><img src="/2021/09/01/git%E7%94%A8%E6%B3%95%E6%B5%85%E6%9E%90/multiPerson.png" alt></p>
<p>　　简而言之，git就是干这活的，把每个文件都想这样管理起来，这样我们只需要保存两样东西：</p>
<ul>
<li>一份最新的文件</li>
<li>这份文件所有的历史改动信息</li>
</ul>
<p>　　<font color="red"><strong>这里说一下</strong></font>，git比svn好在哪里。</p>
<p>　　SVN是典型的集中式的版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p>
<p>　　那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，<strong>每个人的电脑上都是一个完整的版本库</strong>，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p>
<p>　　和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p>
<p>　　在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，<strong>分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已</strong>。</p>
<p>　　而且git最有用的是其强大的分支管理，而SVN全在同一条分支上进行开发，非常混乱。</p>
<h1 id="linux离线安装git"><a href="#linux离线安装git" class="headerlink" title="linux离线安装git"></a>linux离线安装git</h1><p>　　啥都不说了，工作需要，一般情况用不到这种安装方式，这里记录一下，防止忘记。步骤如下：</p>
<ol>
<li><a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a>下载linux下git安装包(.tar.gz)，不要下载.rpm，因为公司电脑没有rpm。</li>
<li>安装步骤</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压: xxx自己换成下载的版本</span></span><br><span class="line">tar -zxvf git.xxx.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装路径: 自己选安装在哪，我给装的都是在/home/git</span></span><br><span class="line">cd git-xxx</span><br><span class="line">./configure --prefix=/home/git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 这里java自己配</span></span></span><br><span class="line">export GIT_HOME=/usr/local/git</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH:$GIT_HOME/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 激活环境变量</span></span></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查有没有装好</span></span><br><span class="line">git --version</span><br></pre></td></tr></table></figure>
<h1 id="git基本用法"><a href="#git基本用法" class="headerlink" title="git基本用法"></a>git基本用法</h1><h2 id="配置用户并生成公钥私钥"><a href="#配置用户并生成公钥私钥" class="headerlink" title="配置用户并生成公钥私钥"></a>配置用户并生成公钥私钥</h2><p>　　安装好git后第一件事就是把全局的<code>user</code>配置了，不然无法上传代码。</p>
<p>　　git基于ssh连接，配置公钥到远程仓库中可以省去认证。这里不讲怎么放，只讲怎么生成。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置用户</span></span><br><span class="line">git config --global user.name "xxx"</span><br><span class="line">git config --global user.email "xxx@yyy.com"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入命令后一路回车，公钥在 ~/.ssh 文件夹下</span></span><br><span class="line">ssh-keygen -t rsa -C "xxx@yyy.com"</span><br></pre></td></tr></table></figure>
<h2 id="git版本库"><a href="#git版本库" class="headerlink" title="git版本库"></a>git版本库</h2><p>　　每个人使用git的时候，会在项目中创建一个git版本库，这个库是实际可以理解为一个<code>.git</code>文件夹，git的所有操作，都是对这个<code>.git</code>文件夹进行修改。当我们用git来进行项目管理时，版本库会把这个项目分成三个区域，如图所示: </p>
<p><img src="/2021/09/01/git%E7%94%A8%E6%B3%95%E6%B5%85%E6%9E%90/gitRepo.png" alt></p>
<p>　　<strong>工作区就是我们的文件夹，暂存区(stage)和最终的提交区域就是我们的git版本库</strong>，这里的控制都是在<code>.git</code>中进行的，请注意区分工作区和版本库，这两个概念是不同的。图中<code>add、commit、HEAD</code>等下文再讲。看到这里我们应该清楚了一个git仓库的基本结构。</p>
<h3 id="创建git版本库"><a href="#创建git版本库" class="headerlink" title="创建git版本库"></a>创建git版本库</h3><p>　　命令：<code>git init</code>。这个命令可以创建一个纯净的git版本库，运行这个命令后，会在这个文件夹下生成一个<code>.git文件夹</code>，这说明你的这个文件夹可以开始被git管理了。<strong>这里值得注意的是</strong>，运行这个命令后，不管你的文件夹下有没有内容，<code>.git</code>初始化后始终是一个纯净的空仓库。    </p>
<p>我们可以通过<code>git status</code>命令来查看git版本库的情况。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line">已初始化空的 Git 仓库于 /Users/memoforward/Project/<span class="built_in">test</span>/testgit/temp/.git/</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line">位于分支 master</span><br><span class="line">尚无提交</span><br><span class="line">无文件要提交（创建/拷贝文件并使用 <span class="string">"git add"</span> 建立跟踪）</span><br></pre></td></tr></table></figure>
<h3 id="把文件添加到版本库并提交"><a href="#把文件添加到版本库并提交" class="headerlink" title="把文件添加到版本库并提交"></a>把文件添加到版本库并提交</h3><p>先在工作区创建一个新文件.gitignore</p>
<p>通过<code>git add</code>将修改的内容从<code>工作区</code>添加到git版本库的<code>暂存区</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add 文件名+后缀</span><br><span class="line"></span><br><span class="line">*********实例**********</span><br><span class="line">git add .gitignore</span><br><span class="line">git status</span><br><span class="line">位于分支 master</span><br><span class="line">尚无提交</span><br><span class="line">要提交的变更：</span><br><span class="line">  （使用 <span class="string">"git rm --cached &lt;文件&gt;..."</span> 以取消暂存）</span><br><span class="line">	新文件：   .gitignore</span><br></pre></td></tr></table></figure>
<p>通过<code>git commit</code>将<code>暂存区</code>的内容提交到最终的区域，并添加提交说明</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit -m <span class="string">"提交说明"</span></span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">"添加gitignore"</span></span><br><span class="line">[master（根提交） c92669e] 添加.gitignore</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 .gitignore</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br></pre></td></tr></table></figure>
<p>此时我们的git项目就通过本地git仓库进行了管理</p>
<h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><p>　　我们可能不小心提交了一个错误的版本（即最新的版本存在问题），为了保证git仓库中最新的版本是稳定的，我们在短期内搞不定的情况，就要对版本进行回滚。</p>
<p>　　<strong>PS：</strong>其实在自己本地的库上影响不严重，但是在远程的库上若有这种问题，则情况就非常严重，因为一般情况下，远程库中的git就是线上的版本，线上出问题，一般很难定位。此时，回滚是一个兜底策略，非常重要。</p>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>　　一个项目可能有很多人在进行开发，会进行成百上千次提交，每次提交就是一个版本，我们不可能记得住每个版本都修改了哪些内容，但是git能帮我们记住，只需要输入<code>git log</code> 就行。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 将日志一行显示，更加简洁，我喜欢加上这样的命令, 但是看不到作者信息了</span></span><br><span class="line">git <span class="built_in">log</span> --oneline </span><br><span class="line"></span><br><span class="line">3fc2d100b (HEAD -&gt; master, origin/master, origin/HEAD) <span class="built_in">enable</span> Github Action <span class="keyword">for</span> Unit <span class="built_in">test</span> (<span class="comment">#6726)</span></span><br><span class="line">a2a14dcb4 add short/byte data <span class="built_in">type</span> support <span class="keyword">for</span> PojoUtils<span class="comment">#getDefaultValue (#6551)</span></span><br><span class="line">b14e53443 fix boolean data <span class="built_in">type</span> issue <span class="keyword">for</span> Pojoutils.java<span class="comment">#getDefaultValue</span></span><br><span class="line">4a265a52b update dubbo-provider.xml <span class="keyword">for</span> demo (<span class="comment">#6857)</span></span><br><span class="line">1a3949ebb remove impossible reach branch and the useless variable <span class="keyword">for</span> RedisRegistry.java (<span class="comment">#6862)</span></span><br></pre></td></tr></table></figure>
<p>　　这个命令能让你看到所有的提交，<code>commit</code>后面可以理解为版本号，以下包括<strong>作者</strong>，<strong>提交时间</strong>以及<strong>提交说明</strong>。这就体现了每次提交都写提交说明的重要性，为了方便我们对每次版本进行查看。</p>
<p>　　当我们获取到了该一个git项目所有历史版本号之后，我们就可以把git提交区域的版本回退到特定历史。下面介绍回退版本的命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD^ <span class="comment"># 回退到上个版本</span></span><br><span class="line">git reset --hard HEAD^^ <span class="comment"># 回退到上上个版本</span></span><br><span class="line">git reset --hard HEAD~10 <span class="comment"># 回退到10个版本以前</span></span><br><span class="line">git reset  --hard commit_id <span class="comment"># 可以调到任意一个版本，可以回退可以前进</span></span><br></pre></td></tr></table></figure>
<p>　　git版本回退的原理是维护一个指向版本的指针，这个指针名叫HEAD，git保存的不是每次版本的文件，而是保存每次版本的修改，因此十分高效，如下图所示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">graph BT</span><br><span class="line">	subgraph table</span><br><span class="line">		commit_id2 ---&gt; commit_id1</span><br><span class="line">		commit_id3 ---&gt; commit_id2</span><br><span class="line">	end</span><br><span class="line">		HEAD((HEAD)) ---&gt; commit_id2</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式笔记</title>
    <url>/2021/07/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要对正则表达式的一些语法进行了一些记录，有机会长期补充一下：</p>
<blockquote>
<p>正则表达式基础语法</p>
</blockquote>
<a id="more"></a>
<h1 id="正则基础语法"><a href="#正则基础语法" class="headerlink" title="正则基础语法"></a>正则基础语法</h1><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>　　元字符用来对字符串进行简单的匹配。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">元字符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>.</code></td>
<td style="text-align:center">匹配除换行符以外的任意字符</td>
</tr>
<tr>
<td style="text-align:center"><code>\w</code></td>
<td style="text-align:center">匹配 字母、数字、下划线或汉汉字</td>
</tr>
<tr>
<td style="text-align:center"><code>\s</code></td>
<td style="text-align:center">匹配任意空白符</td>
</tr>
<tr>
<td style="text-align:center"><code>\d</code></td>
<td style="text-align:center">匹配数字</td>
</tr>
<tr>
<td style="text-align:center"><code>\b</code></td>
<td style="text-align:center">匹配单词的开始或结束</td>
</tr>
<tr>
<td style="text-align:center"><code>^</code></td>
<td style="text-align:center">匹配字符串的开始</td>
</tr>
<tr>
<td style="text-align:center"><code>$</code></td>
<td style="text-align:center">匹配字符串的结束</td>
</tr>
</tbody>
</table>
</div>
<p>　　例子：</p>
<ol>
<li>匹配有abc开头的字符串</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">\babc或^abc</span><br></pre></td></tr></table></figure>
<ol>
<li>匹配3位数字</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">^\d\d\d$</span><br></pre></td></tr></table></figure>
<ol>
<li>配7开头的3位数字</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">^<span class="number">7</span>\d\d$</span><br></pre></td></tr></table></figure>
<h2 id="重复限定符"><a href="#重复限定符" class="headerlink" title="重复限定符"></a>重复限定符</h2><p>　　元字符规则匹配的一般是单个或固定多个字符的情况，这很笨重，有时候多个字符匹配的规则是一样的，这时候就需要用重重复限定符去进行一个匹配。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">重复限定符</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>*</code></td>
<td style="text-align:center">重复任意次数，包括0次</td>
</tr>
<tr>
<td style="text-align:center"><code>+</code></td>
<td style="text-align:center">重复1次以上</td>
</tr>
<tr>
<td style="text-align:center"><code>?</code></td>
<td style="text-align:center">重复0次或1次</td>
</tr>
<tr>
<td style="text-align:center"><code>{n}</code></td>
<td style="text-align:center">重复n次</td>
</tr>
<tr>
<td style="text-align:center"><code>{n,}</code></td>
<td style="text-align:center">重复n次即以上</td>
</tr>
<tr>
<td style="text-align:center"><code>{n, m}</code></td>
<td style="text-align:center">重复n到m次之间都匹配</td>
</tr>
</tbody>
</table>
</div>
<p>　　用了重复限定符之后会优雅很多。</p>
<ol>
<li>匹配11位手机号，必须以1开头</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">^<span class="number">1</span>\d&#123;<span class="number">10</span>&#125;$</span><br></pre></td></tr></table></figure>
<ol>
<li>匹配a开头，x结尾，中间是12-18位数字的字符串</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">^a\d&#123;<span class="number">12</span>-<span class="number">18</span>&#125;x$</span><br></pre></td></tr></table></figure>
<ol>
<li>匹配a开头，0个或多个b结尾的字符串</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">^ab*$</span><br></pre></td></tr></table></figure>
<h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>　　使用括号来对一组字符进行匹配。</p>
<ol>
<li>匹配xy开头的任意数量的字符</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">^(xy)*$</span><br></pre></td></tr></table></figure>
<h1 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h1><p>　　防止正则符号和字符符号冲突。</p>
<ol>
<li>匹配任意数量(ab)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">(\(ab\)*</span><br></pre></td></tr></table></figure>
<h1 id="条件或和区间"><a href="#条件或和区间" class="headerlink" title="条件或和区间"></a>条件或和区间</h1><p>　　用<code>|</code>表示或，[]表示区间（[0-9][a-z][A-Z][156]等，<strong>[]只能匹配一个字符</strong>）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">^((<span class="number">13</span>[<span class="number">0</span>-<span class="number">2</span>])|(<span class="number">15</span>[<span class="number">56</span>])|(<span class="number">18</span>[<span class="number">5</span>-<span class="number">6</span>])|<span class="number">145</span>|<span class="number">176</span>)\d&#123;<span class="number">8</span>&#125;$</span><br><span class="line">^(<span class="number">130</span>|<span class="number">131</span>|<span class="number">132</span>|<span class="number">155</span>|<span class="number">156</span>|<span class="number">185</span>|<span class="number">186</span>|<span class="number">145</span>|<span class="number">176</span>)\d&#123;<span class="number">8</span>&#125;$ <span class="comment">// 等价</span></span><br></pre></td></tr></table></figure>
<h1 id="前断言和后断言"><a href="#前断言和后断言" class="headerlink" title="前断言和后断言"></a>前断言和后断言</h1><p>　　先不写了，有点事，以后再说。</p>
]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>工具</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的继承</title>
    <url>/2021/07/19/Java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文主要针对一些比较模糊的问题进行总结：</p>
<ol>
<li>引用是父类，实例是子类</li>
<li>super和this</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="父类和子类的引用情况"><a href="#父类和子类的引用情况" class="headerlink" title="父类和子类的引用情况"></a>父类和子类的引用情况</h1><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>　　父类的引用可以指向子类的对象（向上转型），子类引用不能指向父类对象。这个很好理解，子类实例化会执行父类的构造器，此时父类的属性已经在内存中了，使用父类的引用可以访问到父类的属性信息；但是父类实例化不会执行子类的构造器，因此内存中不会有子类的属性信息，使用子类的引用无法访问到子类的成员信息。这里有个口诀对于对象的类型：<strong>编译看左边，运行看右边，静态全看左</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Father f = <span class="keyword">new</span> Son(); <span class="comment">// ok</span></span><br><span class="line">Son s = <span class="keyword">new</span> Father(); <span class="comment">// 编译不通过</span></span><br><span class="line">Son ss = (Son)<span class="keyword">new</span> Father(); <span class="comment">// 编译通过，运行时抛出ClassCastException（类型转换异常）</span></span><br></pre></td></tr></table></figure>
<p>　　这里比较特殊的是，父类引用指向子类的对象，该引用<strong>只能</strong>调用父类定义的成员变量和成员方法（因为编译看左边），<font color="red"><strong>而在运行中，调用同名的成员变量会调用父类的成员变量，如果调用同名的成员方法（即重写的方法），则会调用子类的方法</strong></font>。这里很奇怪，既然运行看右边，为什么我访问的不是子类对象中同名的成员变量呢？</p>
<p>　　这和Java的运行机制有关，<font color="brown">Java中的<strong>成员变量、静态成员方法、private以及final方法都是静态绑定的</strong>，所谓静态绑定是指在编译期绑定，这时候引用<code>f</code>已经和父类的成员变量绑定了；而<strong>普通的成员方法是动态绑定的</strong>，也就是运行时绑定，此时引用<code>f</code>在调用方法的时候是访问的是子类方法表的地址</font>。也就是说，Java的多态是指在运行时多态，只是指普通成员方法的多态。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">"父亲"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">"儿子"</span>;</span><br><span class="line">    <span class="keyword">public</span> String name2 = <span class="string">"儿子小名"</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Father f = <span class="keyword">new</span> Son();</span><br><span class="line">    System.out.println(f.name); <span class="comment">// 父亲</span></span><br><span class="line">    System.out.println(f.getName()); <span class="comment">//儿子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>　　这里补充一下：虽然引用<code>f</code>无法直接调用子类的成员变量和父类没有的成员方法，但是在运行时，这些属性仍然是开辟了空间的，但是无法访问（主要是因为编译不过）。这里给出一个验证，我们知道反射是典型的在运行时可以操作对象的方式，这里通过反射在运行时强行去找<code>f</code>的成员变量，可以看到实际上<code>f</code>在运行时是一个子类的实例对象，通过反射可以访问到父类没有的变量或者方法（代码只写了变量），但是因为静态绑定了，所以直接通过<code>f.name</code>显示的是父亲的<code>name</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Father f = <span class="keyword">new</span> Son();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field field = f.getClass().getField(<span class="string">"name"</span>);</span><br><span class="line">        Field field2 = f.getClass().getField(<span class="string">"name2"</span>);</span><br><span class="line">        System.out.println(f.name); <span class="comment">// 父亲</span></span><br><span class="line">        System.out.println(f.getName()); <span class="comment">// 儿子</span></span><br><span class="line">        String name = (String)field.get(f); <span class="comment">// 儿子</span></span><br><span class="line">        String name2 = (String)field2.get(f); <span class="comment">// 儿子小名</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Super和This"><a href="#Super和This" class="headerlink" title="Super和This"></a>Super和This</h1><p>　　大家都知道两点：</p>
<ol>
<li>子类初始化会调用父类的构造器</li>
<li>子类中使用super可以调用父类的变量和方法（除了<code>private</code>修饰的）</li>
</ol>
<p>　　但是这里要强调一下，<font color="red"><strong>子类实例化不会创建父类的实例</strong></font>，调用父类的构造器只是在内存中开辟了父类属性的空间，也就是说和<code>this</code>不同，<code>super</code>并不指代一个对象。如果调用<code>super.hashcode()</code>就会发现结果和<code>this.hashcode()</code>的值一样，因为根本就没有父类对象，调用父类的<code>hashcode</code>和子类的<code>hashcode</code>得到的都是子类的<code>hashcode</code>，从这可以推导得出，就算是在父类的构造器中调用<code>this.hashcode()</code>得到的也是子类的<code>hashcode</code>。</p>
<p>　　<strong>总结一下</strong>就是：<code>super</code>只是一个标志，不指向任何对象，它能调用父类的构造器和方法，并不是说指向了父类对象，因为根本没有父类对象被创建。</p>
<p>　　另外，<code>hashcode</code>方法是运行时调用的，因此上述的结论和引用是不是子类类型并无关系。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 重写Son和Father</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类this.hashcode(): "</span> + <span class="keyword">this</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类this.hashcode(): "</span> + <span class="keyword">this</span>.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"子类super.hashcode(): "</span> + <span class="keyword">super</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Son s = <span class="keyword">new</span> Son();</span><br><span class="line">    System.out.println(<span class="string">"==========="</span>);</span><br><span class="line">    Father f = <span class="keyword">new</span> Son();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">父类<span class="keyword">this</span>.hashcode(): <span class="number">1554874502</span></span><br><span class="line">子类<span class="keyword">this</span>.hashcode(): <span class="number">1554874502</span></span><br><span class="line">子类<span class="keyword">super</span>.hashcode(): <span class="number">1554874502</span></span><br><span class="line">===========</span><br><span class="line">父类<span class="keyword">this</span>.hashcode(): <span class="number">1846274136</span></span><br><span class="line">子类<span class="keyword">this</span>.hashcode(): <span class="number">1846274136</span></span><br><span class="line">子类<span class="keyword">super</span>.hashcode(): <span class="number">1846274136</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　　Java继承主要就是要处理两个问题：一、什么东西是静态绑定的；二、子类实例化，会不会实例化一个父类对象？懂了这两个问题，所有问题都能推导出来。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java8特性lambda表达式笔记</title>
    <url>/2021/07/19/Java8%E7%89%B9%E6%80%A7lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文涉及以下知识：</p>
<ol>
<li>Lambda表达式基本概念</li>
<li>Lambda表达式语法</li>
<li>Lambda表达式实战：java.util.function</li>
<li>Stream 流的概念</li>
<li>Stream实战</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="Lambda基本概念"><a href="#Lambda基本概念" class="headerlink" title="Lambda基本概念"></a>Lambda基本概念</h1><p>　　Java8的一个新特性就是引入了函数式接口。通常我们的方法的入参都是基本数据类型，或者是实例对象的引用，这在一定程度上限制了方法的多样性，因此Java引入了函数式编程，即<font color="red"><strong>在声明（构造器或者方法）时把一个函数接口当成入参</strong></font>。一般这样的入参在实际使用时，会用一个实现了该接口的类对象来传入，这种对象我们一般会写成匿名的，如下所示（声明一个线程）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 接口Runnable作为声明时的入参，在使用时使用一个匿名类来传入</span></span><br><span class="line">Thread td = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>　　这种匿名函数写起来很笨重，<strong>因此引入了Lambda表达式来简化匿名函数的定义</strong>，如果用Lambda表达式来声明上述<code>td</code>对象，则可以写成如下形式（两种写法的作用是完全一致的）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Thread td = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"run"</span>));</span><br></pre></td></tr></table></figure>
<p>　　可以说，labmda表达式就是一种简洁的匿名类书写方式，用来增强代码的简洁性和可读性。</p>
<h1 id="Lambda表达式语法"><a href="#Lambda表达式语法" class="headerlink" title="Lambda表达式语法"></a>Lambda表达式语法</h1><h2 id="Lambda使用的条件"><a href="#Lambda使用的条件" class="headerlink" title="Lambda使用的条件"></a>Lambda使用的条件</h2><p>　　使用Lambda表达式来实现某个接口时，<strong>必须保证该接口只有一个抽象方法</strong>。如果该接口有两个或者两个以上的抽象方法，则无法使用Lambda。这里需要注意一点：因为Java8为接口加入了<code>default</code>和<code>static</code>方法，这两种方法不是抽象方法，是可以使用lambda的，如下例所示：</p>
<ul>
<li>可以使用Lambda的情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只有一个抽象方法，可以用使用lambda</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">canUseLambda</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"log..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"perf..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">InterA interA = () -&gt; System.out.println(<span class="string">"canUseLambda"</span>); <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure>
<ul>
<li>不可以使用Lambda的情况</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canUseLambda</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cantUseLambda</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会报如下的错误：</p>
<p><img src="/2021/07/19/Java8%E7%89%B9%E6%80%A7lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/mutiAbstarct.png" alt></p>
<h2 id="Lambda-语法"><a href="#Lambda-语法" class="headerlink" title="Lambda 语法"></a>Lambda 语法</h2><p>　　Lambda语法很简单，完整写法就是<code>(参数列表) -&gt; {具体实现代码(有返回类型可以写return)}</code>。举个例子，假设有一个<code>Rectangle</code>接口，里面有一个抽象方法，接收两个参数，返回一个<code>double</code>;同时也有一个<code>Circle</code>接口，里面有一个方法，接收一个参数，返回一个<code>double</code>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>完整</strong>定义的方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Rectangle rect1 = (x, y) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Circle circle1 = (x) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>简化写法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 当具体实现代码只有一行的时候，不需要写大括号，如果有return，则省去return</span></span><br><span class="line">Rectangle rect2 = (x, y) -&gt; x * y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果入参只有一个，则入参的()也可以省略</span></span><br><span class="line">Circle circle2 = x -&gt; Math.sqrt(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果参数只有一个，而且调用的方法也只需要传入这个参数</span></span><br><span class="line"> Circle circle3 = Math::sqrt;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">rect1.cal(<span class="number">4.0</span>,<span class="number">5.0</span>); <span class="comment">// 20.0</span></span><br><span class="line">rect2.cal(<span class="number">4.0</span>, <span class="number">5.0</span>); <span class="comment">// 20.0</span></span><br><span class="line">circle1.cal(<span class="number">81.0</span>); <span class="comment">// 9.0</span></span><br><span class="line">circle2.cal(<span class="number">81.0</span>); <span class="comment">// 9.0</span></span><br><span class="line">circle3.cal(<span class="number">81.0</span>); <span class="comment">// 9.0</span></span><br></pre></td></tr></table></figure>
<h1 id="Lambda实战-java-util-function"><a href="#Lambda实战-java-util-function" class="headerlink" title="Lambda实战: java.util.function"></a>Lambda实战: java.util.function</h1><p>　　Lambda主要用在函数式编程里面，而Java8引入了一个新的包用来支持函数式编程，那就是<code>java.util.fuction</code>。</p>
<h2 id="java-util-function常用接口"><a href="#java-util-function常用接口" class="headerlink" title="java.util.function常用接口"></a>java.util.function常用接口</h2><p>接口文档可查看：<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="noopener">java.util.function接口文档</a></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">接口</th>
<th style="text-align:center">方法</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>Consumer&lt;T&gt;</code></td>
<td style="text-align:center"><code>void accept(T t)</code></td>
<td style="text-align:center">表示”消费者”，接收一个参数（一般用消费<code>t</code>来实现某个功能）</td>
</tr>
<tr>
<td style="text-align:center"><code>Supplier&lt;T&gt;</code></td>
<td style="text-align:center"><code>T get()</code></td>
<td style="text-align:center">表示”生产者”，不接收参数，返回一个值</td>
</tr>
<tr>
<td style="text-align:center"><code>Predicate&lt;T&gt;</code></td>
<td style="text-align:center"><code>bool test(T t)</code></td>
<td style="text-align:center">预测接口，提供一个参数，返回一个<code>bool</code>值</td>
</tr>
<tr>
<td style="text-align:center"><code>Function&lt;T, R&gt;</code></td>
<td style="text-align:center"><code>R apply(T t)</code></td>
<td style="text-align:center">接收一个参数<code>t</code>，返回一个值</td>
</tr>
</tbody>
</table>
</div>
<p>　　这里写个简单的例子，这些接口一般会经常用在<code>Stream</code>里，下一章会介绍这些方法的具体应用，这里写个简单的，方便理解。<font color="red"><strong>下列方法一个重要的理解方式就是：入参函数使用了另一个入参作为了参数，类方法又调用了入参函数。</strong></font></p>
<ul>
<li>定义一个类，使用上述接口作为参数</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoLambda</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">doSupply</span><span class="params">(Supplier&lt;T&gt; supplier)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doConsumer</span><span class="params">(T t, Consumer&lt;T&gt; consumer)</span> </span>&#123;</span><br><span class="line">        consumer.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">doPredicate</span><span class="params">(T t, Predicate&lt;T&gt; predicate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> predicate.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T, R&gt; <span class="function">R <span class="title">doFunction</span><span class="params">(T t, Function&lt;T, R&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function.apply(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用这些方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DoLambda d = <span class="keyword">new</span> DoLambda();</span><br><span class="line">    System.out.println(d.doSupply(() -&gt; <span class="string">"生产者提供的一个字符串"</span>));</span><br><span class="line">    d.doConsumer(<span class="string">"消费者要消费这个字符串"</span>, System.out::println);</span><br><span class="line">    d.doPredicate(<span class="string">"判断这个字符串的长度是否为10"</span>, x -&gt; x.length() == <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">boolean</span> flag = d.doPredicate(<span class="string">"判断这个字符串的长度是否为10"</span>, x -&gt; x.length() == <span class="number">10</span>);</span><br><span class="line">    System.out.println(flag);</span><br><span class="line">    Double a = d.doFunction(<span class="number">53.4</span>, x -&gt; &#123;</span><br><span class="line">        System.out.print(<span class="string">"计算53.4的平方: "</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.pow(x, <span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******输出如下*******/</span></span><br><span class="line">生产者提供的一个字符串</span><br><span class="line">消费者要消费这个字符串</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">计算<span class="number">53.4</span>的平方: <span class="number">2851.56</span></span><br></pre></td></tr></table></figure>
<h1 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h1><p>　　StreamAPI也是Java8引入的新特性，可以实现<font color="red">集合</font>的<strong>串行或者并行的流操作</strong>。这是Java8最实用的功能。<strong>这里说一个重要的，流只是操作，不改变原集合。</strong></p>
<ul>
<li><div id="person">创建流</div>

</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Stream&lt;T&gt; stream1 = 集合&lt;T&gt;对象.stream() <span class="comment">// 串行流</span></span><br><span class="line">Stream&lt;T&gt; stream2 = 集合&lt;T&gt;对象.parallelStream() <span class="comment">// 并行流</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"yi"</span>, <span class="number">45</span>)); <span class="comment">// name, age</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"two"</span>, <span class="number">11</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"three"</span>, <span class="number">56</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"four"</span>, <span class="number">27</span>));</span><br><span class="line">        Stream&lt;Person&gt; stream = list.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>部分流操作</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">流操作</th>
<th style="text-align:center">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><code>void forEach(Consumer&lt;? super T&gt; action)</code></td>
<td style="text-align:center">迭代这个集合中的每一个数据</td>
</tr>
<tr>
<td style="text-align:center"><code>Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code></td>
<td style="text-align:center">把集合中的每一个T类型数据映射成R类型数据，<strong>返回一个R类型的流</strong></td>
</tr>
<tr>
<td style="text-align:center"><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></td>
<td style="text-align:center">对集合中每一个数据进行筛选，筛出符合条件的数据(true)，并返回一个流</td>
</tr>
<tr>
<td style="text-align:center"><code>Stream&lt;T&gt; limit(long maxSize)</code></td>
<td style="text-align:center">获取指定数量的流，数量为maxSize（串行有序，并行无序）</td>
</tr>
<tr>
<td style="text-align:center"><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code></td>
<td style="text-align:center">累加器，两两相加，最后返回一个Optional容器（Optional是为了防止空指针，用<code>容器对象.get()</code>得到T，关于BinaryOperator去看<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="noopener">文档</a>）</td>
</tr>
<tr>
<td style="text-align:center"><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></td>
<td style="text-align:center">有初始值的累加，因为有初始值，所以不会出现空指针，直接返回T</td>
</tr>
<tr>
<td style="text-align:center"><code>Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)</code></td>
<td style="text-align:center">对集合类进行排序，传入一个比较器，返回一个流对象</td>
</tr>
<tr>
<td style="text-align:center"><code>Object[] toArray() 和 collect(Collectors.toList())</code></td>
<td style="text-align:center">对流进行数组或集合类型的转化</td>
</tr>
</tbody>
</table>
</div>
<h1 id="Stream实战"><a href="#Stream实战" class="headerlink" title="Stream实战"></a>Stream实战</h1><p><a href="#person">以上</a>写了一个<code>Person</code>的列表，要求用流分别实现如下功能：</p>
<ol>
<li><p>将人的按照年龄大小排序并打印</p>
</li>
<li><p>筛选出年龄小于50的并打印</p>
</li>
<li><p>打印出总年龄</p>
</li>
<li><p>打印前3个人</p>
</li>
<li><p>把每个人的年龄加100，并打印</p>
</li>
<li><p>将所有的人映射到一个Map集合里面，key是名字，value是年龄</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">System.out.println(<span class="string">"====问题1===="</span>);</span><br><span class="line">list.stream().sorted((o1, o2) -&gt; o1.getAge() - o2.getAge()).forEach(Person::print);</span><br><span class="line">System.out.println(<span class="string">"====问题2===="</span>);</span><br><span class="line">list.stream().filter(p -&gt; p.getAge() &lt; <span class="number">50</span>).forEach(Person::print);</span><br><span class="line">System.out.println(<span class="string">"====问题3===="</span>);</span><br><span class="line">System.out.println(list.stream().mapToInt(Person::getAge).reduce(Integer::sum).orElse(-<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">"====问题4===="</span>);</span><br><span class="line">list.stream().limit(<span class="number">3</span>).forEach(Person::print);</span><br><span class="line">System.out.println(<span class="string">"====问题5===="</span>);</span><br><span class="line">list.forEach(p -&gt; p.setAge(p.getAge() + <span class="number">100</span>));</span><br><span class="line">list.forEach(Person::print);</span><br><span class="line">System.out.println(<span class="string">"====问题6===="</span>);</span><br><span class="line">Map&lt;String, Integer&gt; map = list.stream().collect(Collectors.toMap(Person::getName, Person::getAge));</span><br><span class="line"><span class="keyword">for</span>(String key: map.keySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"姓名："</span> + key + <span class="string">"  年龄："</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">====问题<span class="number">1</span>====</span><br><span class="line">姓名：two  年龄：<span class="number">11</span></span><br><span class="line">姓名：four  年龄：<span class="number">27</span></span><br><span class="line">姓名：yi  年龄：<span class="number">45</span></span><br><span class="line">姓名：three  年龄：<span class="number">56</span></span><br><span class="line">====问题<span class="number">2</span>====</span><br><span class="line">姓名：yi  年龄：<span class="number">45</span></span><br><span class="line">姓名：two  年龄：<span class="number">11</span></span><br><span class="line">姓名：four  年龄：<span class="number">27</span></span><br><span class="line">====问题<span class="number">3</span>====</span><br><span class="line"><span class="number">139</span></span><br><span class="line">====问题<span class="number">4</span>====</span><br><span class="line">姓名：yi  年龄：<span class="number">45</span></span><br><span class="line">姓名：two  年龄：<span class="number">11</span></span><br><span class="line">姓名：three  年龄：<span class="number">56</span></span><br><span class="line">====问题<span class="number">5</span>====</span><br><span class="line">姓名：yi  年龄：<span class="number">145</span></span><br><span class="line">姓名：two  年龄：<span class="number">111</span></span><br><span class="line">姓名：three  年龄：<span class="number">156</span></span><br><span class="line">姓名：four  年龄：<span class="number">127</span></span><br><span class="line">====问题<span class="number">6</span>====（顺序是随机的）</span><br><span class="line">姓名：yi  年龄：<span class="number">145</span></span><br><span class="line">姓名：four  年龄：<span class="number">127</span></span><br><span class="line">姓名：three  年龄：<span class="number">156</span></span><br><span class="line">姓名：two  年龄：<span class="number">111</span></span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　　本章内容主要介绍了一下Lambda表达式，同时稍微介绍了一点StreamAPI的知识，这部分知识不难，主要难在架构设计，希望以后我忘记这部分内容的时候能够通过这篇文章回想起来。</p>
]]></content>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>限流工具RateLimiter和Semaphore解析</title>
    <url>/2020/10/30/%E9%99%90%E6%B5%81%E5%B7%A5%E5%85%B7RateLimiter%E5%92%8CSemaphore/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文主要介绍限流工具RateLimiter和Semaphore</p>
<ol>
<li>RateLimiter介绍</li>
<li>Semaphore</li>
<li>使用场景分析</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="RateLimiter"><a href="#RateLimiter" class="headerlink" title="RateLimiter"></a>RateLimiter</h1><h2 id="RateLimiter原理简介"><a href="#RateLimiter原理简介" class="headerlink" title="RateLimiter原理简介"></a>RateLimiter原理简介</h2><p>　　RateLimiter是谷歌出品的一个限流工具，使用令牌桶策略进行限流。所谓令牌桶策略，直观上来看就是：规定桶里最多能放N个令牌，如果桶没满，则按照一定的速率（可以是匀速，也可以是变速）往桶里追加令牌，如果有线程打到了这个实例上，则会拿走一个或多个令牌，如果没有令牌可以拿，就会阻塞几秒，直到可以拿到令牌为止。</p>
<p>　　这种原理很好理解，有点类似小时候”浴缸一边加水一边放水“的感觉，但同时这个如果按照这个理解去实现这个RateLimiter的话，会出现很多的问题，比如”我们如何实现每秒钟往桶里放令牌呢？“，上面的思路实现就会是：这个类会始终启动一个线程无时无刻去放令牌。这种做法显然会造成极大的资源浪费。在下一小节，我将针对RateLimiter的部分源码来解释一下谷歌对于限流的实现。</p>
<h2 id="RateLimiter源码解析"><a href="#RateLimiter源码解析" class="headerlink" title="RateLimiter源码解析"></a>RateLimiter源码解析</h2><p>　　 先说结论：RateLimiter本身不会自启一个线程去往桶里放令牌，<strong>放令牌的数量是基于时间的</strong>，RateLimiter中会<font color="brown"><strong>记录下一个请求从何时（记为x）开始才能获取到令牌</strong></font>，根据当前请求的时间（y）和x作比较，如果x &lt; y，则一定可以获得令牌（可预支），然后根据其申请的令牌数计算下次可以获取到令牌的具体时间；如果x &gt; y，则说明目前是桶中是没有令牌的，则会计算出线程获得令牌需要等待的时间（t），同时也会进一步更新，线程将沉睡t时间后再去执行方法。</p>
<p><strong>这里有两点需要注意：</strong></p>
<ol>
<li><strong>线程获取令牌这个操作是串行的，不会出现两个线程同时争夺同一块令牌的情况;</strong></li>
<li><strong>同时，如果桶中只有10个令牌，我的请求需要20个令牌，我是可以立刻获取到这些令牌并执行方法的，但是下一个请求将会等待这多出来的生产10个令牌的时间。</strong>这里给出谷歌官方文档的原文: It is important to note that the number of permits requested <em>never</em> affects the throttling of the request itself (an invocation to <code>acquire(1)</code> and an invocation to <code>acquire(1000)</code> will result in exactly the same throttling, if any), but it affects the throttling of the <em>next</em> request. I.e., if an expensive task arrives at an idle RateLimiter, it will be granted immediately, but it is the <em>next</em> request that will experience extra throttling, thus paying for the cost of the expensive task.</li>
</ol>
<p>　　下面我先介绍一下<code>RateLimiter</code>类的一些基本概念。<code>RateLimiter</code>是一个抽象的基类，自身是不含有成员变量的，仅包含了一些通用的方法，具体参数的定义都放在了它的子类<code>SmoothRateLimiter</code>中，这个类又派生出了两个”限流桶“的实现内部类，分别是：<code>SmoothBursty</code>类和<code>SmoothWarmingUp</code>类。前者是恒定速率生产令牌的”限流桶“，后者是变速生产令牌的桶（类似于TCP的慢开始策略）。本文因为篇幅限制，仅介绍实现稍微简单一些的<code>SmoothBursty</code>类。</p>
<ul>
<li>上面讲到，”限流桶“其中一个实现类是SmoothBursty，下表列出了这个类的<strong>核心参数</strong>和含义。</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">参数含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><font color="orange">double </font><font color="purple">storedPermits</font></td>
<td style="text-align:center">当前存储的令牌数量</td>
</tr>
<tr>
<td style="text-align:center"><font color="orange">double </font> <font color="purple">maxPermits</font></td>
<td style="text-align:center">允许存储的最大令牌数量 =<font color="purple"> maxBurstSeconds * permitsPerSecond</font></td>
</tr>
<tr>
<td style="text-align:center"><font color="orange">double </font> <font color="purple">stableIntervalMicros</font></td>
<td style="text-align:center">稳定生产一个令牌所用的时间（微秒）</td>
</tr>
<tr>
<td style="text-align:center"><font color="orange">private long </font> <font color="purple">nextFreeTicketMicros</font></td>
<td style="text-align:center">下次可以获取到令牌的具体时间，如果当前时间小于这个时间，则不能获取</td>
</tr>
<tr>
<td style="text-align:center"><font color="orange">final double </font> <font color="purple">maxBurstSeconds</font></td>
<td style="text-align:center">桶中可以放几秒的限值（默认是一秒，可以用来应对突发的大流量）</td>
</tr>
</tbody>
</table>
</div>
<p>　　接下来，我将介绍一下RateLimiter类的几个核心方法：</p>
<ul>
<li><font color="green">RateLimiter.create(double permitsPerSecond)</font>这个方法会生成一个匀速产生令牌的”限流桶”：<font color="blue">SmoothBursty</font>。这个函数没什么好讲的，主要就是将以上的参数都给赋值，尤其是把 <font color="purple">storedPermits</font>给填满。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// created方法是RateLimiter类的方法，核心是setRate，限流器核心参数的赋值都是基于我们设置的permitsPerSecond</span></span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, SleepingStopwatch stopwatch)</span> </span>&#123;</span><br><span class="line">    RateLimiter rateLimiter = <span class="keyword">new</span> SmoothBursty(stopwatch, <span class="number">1.0</span> <span class="comment">/* maxBurstSeconds */</span>);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// setRate方法在下层有两个操作，其中一个是用来给stableIntervalMicros赋值，另一个用来调整maxPermits和stroedPermits</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 核心方法，根据时间来更新令牌数</span></span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="comment">// 这个很好理解</span></span><br><span class="line">    <span class="keyword">double</span> stableIntervalMicros = SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;</span><br><span class="line">    <span class="keyword">this</span>.stableIntervalMicros = stableIntervalMicros;</span><br><span class="line">    doSetRate(permitsPerSecond, stableIntervalMicros);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> stableIntervalMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> oldMaxPermits = <span class="keyword">this</span>.maxPermits;</span><br><span class="line">    maxPermits = maxBurstSeconds * permitsPerSecond;</span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">      <span class="comment">// if we don't special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">      storedPermits = maxPermits;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 防止更新了桶的大小后，令牌数超标的情况</span></span><br><span class="line">      storedPermits =</span><br><span class="line">          (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">              ? <span class="number">0.0</span> <span class="comment">// initial state</span></span><br><span class="line">              : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>以上代码中有一个核心的方法：<font color="red">resync(nowMicros)</font>。这个方法将根据目前线程的请求时间和上一次请求所间隔的时间，来计算出这段时间中桶中生产了多少个令牌，并更新这个桶中的令牌数量，这个方法是RateLimiter实现添加加令牌操作的基础方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// if nextFreeTicket is in the past, resync to now</span></span><br><span class="line">  <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">    <span class="comment">// 计算出这段时间内，一共可以生产多少令牌</span></span><br><span class="line">    <span class="comment">// coolDownIntervalMicros()对于SmoothBurst而言一直是stableIntervalMicros</span></span><br><span class="line">    <span class="keyword">double</span> newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class="line">    <span class="comment">// 添加令牌, 如果桶空闲了，令牌数是可以填满的</span></span><br><span class="line">    storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">    <span class="comment">// 目前下一次获取令牌的时间是当前请求的时间，因为进到这个方法里表示请求一定可以拿到令牌（下面的方法会讲，RateLimiter可以预约令牌）</span></span><br><span class="line">    nextFreeTicketMicros = nowMicros;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="green">RateLimiter.acquire(int permits)</font>：这个方法是从桶中拿走permits个令牌，入参可不写，默认拿走一个令牌，返回可以获得令牌等待了多长时间。如果不能够取得足够数量的令牌，则线程会阻塞一段时间，然后再尝试获取。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 核心方法，意思为”预定“，每个线程都会去申请这个令牌的获取，返回需要等待的时间</span></span><br><span class="line">  <span class="keyword">long</span> microsToWait = reserve(permits);</span><br><span class="line">  <span class="comment">// 线程根据等待的时间进行阻塞</span></span><br><span class="line">  stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// reserve操作加了锁，保证线程不会争夺同一块令牌</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">  checkPermits(permits);</span><br><span class="line">  <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">    <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没什么好讲的，这个就是在计算需要等的时间</span></span><br><span class="line"><span class="comment">// reserveEarliestAvailable计算了当前请求能够拿到令牌的系统时间，如果是future就会阻塞，不是future就是0，表示立刻就能拿到</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveAndGetWaitLength</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> momentAvailable = reserveEarliestAvailable(permits, nowMicros);</span><br><span class="line">  <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体限流桶的方法，两种限流桶不太一样（主要是因为生成的速率不一样，思路是一样的）</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveEarliestAvailable</span><span class="params">(<span class="keyword">int</span> requiredPermits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据时间间隔计算桶中当前应该有多少令牌，更新一下stroedPermits，并把nextFreeTicketMicros和当前时间同步</span></span><br><span class="line">  resync(nowMicros);</span><br><span class="line">  <span class="comment">// 进到这个方法，不管桶中令牌够不够都不会阻塞，如果不够，多余的开销由下一次请求承担，所以直接直接返回当前的时间，表示线程不会阻塞</span></span><br><span class="line">  <span class="keyword">long</span> returnValue = nextFreeTicketMicros;</span><br><span class="line">  <span class="comment">// 计算需要至多能从桶中拿多少的令牌</span></span><br><span class="line">  <span class="keyword">double</span> storedPermitsToSpend = min(requiredPermits, <span class="keyword">this</span>.storedPermits);</span><br><span class="line">  <span class="comment">// 计算预支的令牌数</span></span><br><span class="line">  <span class="keyword">double</span> freshPermits = requiredPermits - storedPermitsToSpend;</span><br><span class="line">  <span class="comment">// 计算额外的开销</span></span><br><span class="line">  <span class="keyword">long</span> waitMicros =</span><br><span class="line">      storedPermitsToWaitTime(<span class="keyword">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">          + (<span class="keyword">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line">  <span class="comment">// 额外的开销将会更新到”下次可以获取到令牌的具体时间“，如果额外开销很大</span></span><br><span class="line">  <span class="comment">// 这个时间就会是很遥远的future，下次请求阻塞的时间就越长</span></span><br><span class="line">  <span class="keyword">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);</span><br><span class="line">      <span class="comment">// 如果”预支“了，storedPermits就会清零</span></span><br><span class="line">  <span class="keyword">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class="line">  <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="RateLimiter总结"><a href="#RateLimiter总结" class="headerlink" title="RateLimiter总结"></a>RateLimiter总结</h2><p>　　RateLimiter是用来进行QPS限流的，请求获取令牌但不释放令牌，同时线程在获取令牌时是串行的，保证了限流数量的一致性。当有操作量大的线程一下子获取了多余的令牌后，RateLimter会使用预支的方式保证这个请求能够顺利响应，同时也不会影响到限流的可靠性，因为多余的开销会由下一次请求承担。同时RateLimiter桶在空闲时会将令牌先塞满桶，这样当在QPS突然非常高的时候（从空闲状态突然变高），RateLimiter可以短时间处理高于限值的请求数，等桶中令牌消耗完了，QPS就会趋于限值并稳定下来。但是RateLimiter获取令牌的操作是用sychronize实现的，因此其无法保证公平性。</p>
<h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><h2 id="Semaphore简介"><a href="#Semaphore简介" class="headerlink" title="Semaphore简介"></a>Semaphore简介</h2><p>　　Semaphore是J.U.C提供的共享锁，名为”信号量”。这个策略比较直观，控制最大并发数，维护一个”信号量“记录当前可用并发量（同样用令牌数来表示信号量的数值），请求要执行操作需要获取<strong>一个</strong>令牌，方法执行结束后需要释放这个令牌。但信号量为0时（令牌数为0），则线程会进一个等待链表（<strong>head是个虚拟头结点，以下说的链表头都指head.next</strong>），进链表后这个线程机会阻塞，直到某个线程释放了令牌，这个释放了令牌的线程会唤醒处在链表头的线程，然后这个线程再去尝试获取令牌。　</p>
<h2 id="Semaphore源码解析"><a href="#Semaphore源码解析" class="headerlink" title="Semaphore源码解析"></a>Semaphore源码解析</h2><p>　　Semaphore主要是通过一个抽象的内部类Sync的两个子类：NonfairSync和FairSync（公平锁和非公平锁）来实现相关功能。这两个类的实现功能是一样的，就是线程获取令牌的公平性问题：进入等待的线程会形成一个链表，每个线程在忙循环中都会尝试去获取令牌，FairSync保证了只有链表头的线程才能够获取到最新的空闲令牌。</p>
<ul>
<li>Sync类继承了AbstractQueuedSynchronizer（AQS）类，这个类中有实现功能的核心参数</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">参数</th>
<th style="text-align:center">参数含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><font color="orange">private volatile int</font> <font color="purple">state</font></td>
<td style="text-align:center">可用的令牌数量（设置的最大并发数），所有的操作都会基于这个值</td>
</tr>
<tr>
<td style="text-align:center"><font color="orange">static final</font> <font color="brown">class Node</font></td>
<td style="text-align:center">等待线程的链表</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Node类核心参数</th>
<th style="text-align:center">参数含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"><font color="orange">volatile</font> <font color="brown">Thread thread</font></td>
<td style="text-align:center">每一个node与当前线程绑定</td>
</tr>
<tr>
<td style="text-align:center"><font color="orange">volatile int</font> <font color="purple">waitStatus</font></td>
<td style="text-align:center">记录这个Node的状态，比如cancelled</td>
</tr>
</tbody>
</table>
</div>
<p> Semaphore最核心的两个操作是acquire()和release()，下面将针对NonFairSync和FairSync详细介绍一下这两个方法。</p>
<ul>
<li>acquire()：这个方法会尝试获取一个令牌，对中断敏感，如果线程中断了，则会抛出异常（还有一个acquireUninterruptibly方法，对中断不敏感，这里不介绍了）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// 去获取一个令牌</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取令牌的具体实现</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// tryAcquireShared 尝试获取令牌，返回获取后剩余的令牌数量，&lt;0则表示无法获取令牌</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// NonfairSync版本tryAcquireShared</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这个循环是为了配合CAS</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 可用的令牌数</span></span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="comment">// 剩余令牌数</span></span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="comment">// 根据java特性，如果剩余令牌数 &lt; 0，就不会执行后面的CAS操作</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// FaieSync版本tryAcquireShared</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 主要就是加了个这个判断，如果等待链表为空，或者当前线程在等待链表的开头（head.next），则可以获取</span></span><br><span class="line">            <span class="comment">// 这避免了新来的线程”插队“</span></span><br><span class="line">            <span class="comment">// 因为在多线程的情况下，即使有了等待队列，available也可能会大于0</span></span><br><span class="line">            <span class="comment">// 此时新来的线程在非公平的情况下，可能会绕过链表直接获取到令牌</span></span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">               <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果tryAcquire的值小于0了，则会执行doAcquireSharedInterruptibly方法来将执行忙循环</span></span><br><span class="line"><span class="comment">// 不停地去请求获取令牌,这个方法对于公不公平没有区分</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 当前请求第一次进来会在等待链表后面添加一个node</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="comment">// 默认这个请求最终能获取令牌</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 线程被唤醒后再次去尝试获取令牌，获取不到就继续被阻塞</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 查询这个node的prev</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 如果这个prev是head再去尝试获取令牌（</span></span><br><span class="line">                <span class="comment">// 等待列表是有序的，只有链表的头（head.next）才有资格去尝试获取令牌，也只有链表头会被唤醒）</span></span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// 公平锁可以保证这个线程一定可以获取到令牌，非公平锁不能保证</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 重新设置链表头</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">// shouldParkAfterFailedAcquire: 重组链表，清除无效节点</span></span><br><span class="line">                <span class="comment">// parkAndCheckInterrupt: 将当前线程挂起，同时检测中断</span></span><br><span class="line">                <span class="comment">// 如果中断则捕获异常（这里多嘴一句，内部用了LockSupport.park()来阻塞线程</span></span><br><span class="line">                <span class="comment">// 这个方法自己不能捕获中断，所以我们不能try..catch）</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                <span class="comment">// 放弃获取令牌，将node的状态置为cancelled</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// setHeadAndPropagate比想象中复杂</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        <span class="comment">// 重新设置链表头</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="comment">// 如果下一个节点为空，或者节点是共享模式（只有虚拟head是独占的，其他node都是共享模式），则尝试唤醒线程</span></span><br><span class="line">            <span class="comment">// s == null 的时候一定不会唤醒后继节点，感觉有点多余</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                <span class="comment">// 尝试唤醒线程，在release方法里详细写</span></span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>这里注意一下，tryAcquireShared在AQS也有带有超时阻塞的重载方法tryAcquireSharedNanos(int arg, long nanosTimeout)，当线程请求超时，直接退出自旋，但是其在Semaphore中没有使用。</strong></p>
<ul>
<li>release()：释放令牌，这个操作没有特别大的学问。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 去释放一个令牌</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放的具体实现</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试去释放令牌，tryReleaseShared已经增加了令牌数</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 释放成功，唤醒链表头的线程</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这个函数比较难懂，最主要的原因就是在共享模式下</span></span><br><span class="line"><span class="comment">// 线程获取令牌和释放令牌都会尝试去唤醒下一个线程，所以这个函数加了一些if判断防止线程被重复唤醒，却没有唤醒应该唤醒的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// SIGNAL表示下一个线程需要被唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 这个函数在唤醒线程</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; <span class="comment">// 0表示dump状态，链表刚刚初始化</span></span><br><span class="line">                     <span class="comment">// PROPAGATE表示线程已经被唤醒，如果交换成功，则跳出if</span></span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) </span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果同时有线程获取和释放了锁，这里的head可能改变，需要重新唤醒后继线程</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Semaphore总结"><a href="#Semaphore总结" class="headerlink" title="Semaphore总结"></a>Semaphore总结</h2><p>　　Semaphore本质上一个基于AQS的共享锁，说到底还是一个锁的模式，如果锁没有释放，其他线程就得一直阻塞或者超时返回。一个非常直观的应用场景可以是数据库的连接，可以控制最大的并发数在1000，只要连接不断开，其他线程就无法访问数据库。</p>
<h1 id="Semaphore和RateLimiter的区别"><a href="#Semaphore和RateLimiter的区别" class="headerlink" title="Semaphore和RateLimiter的区别"></a>Semaphore和RateLimiter的区别</h1><h2 id="原理上的区别"><a href="#原理上的区别" class="headerlink" title="原理上的区别"></a>原理上的区别</h2><p>　　Semaphore限制了服务的最大并发量，并提供了等待队列来阻塞线程，当有令牌可用时会唤醒队列中的线程，队列中线程通过自旋的策略来保证自动获取令牌；而RateLimiter则是限制了QPS，本质上是对速率的一种控制。RateLimiter可能对服务器的CPU造成更大的压力，但也保证了很高的处理效率，因为其只控制在1秒内最多能有多少请求访问资源，但是不会管这个请求会占用资源多久：如果某个请求会占用这个服务2秒，我们限制了QPS为100，则这个服务最大并发量可能会有200。</p>
<h2 id="使用场景上的区别"><a href="#使用场景上的区别" class="headerlink" title="使用场景上的区别"></a>使用场景上的区别</h2><p>大多数场景下，限制QPS和限制并发量的场景都是互通的，限制的并发量。</p>
<ul>
<li>如果请求的平均响应时间是不确定的，那么建议控制并发量来保证服务器不会受到太大的压力；</li>
<li>其他情况建议使用限制QPS的限流器：<ul>
<li>从两种种工具的实现上来看，Semaphore通过阻塞唤醒机制来控制线程，默认情况下线程被唤醒后不一定能够获取到令牌，从而又会重新进入阻塞状态，同时每次自旋都会重新处理等待链表也比较消耗资源，而RateLimiter会计算线程阻塞的时间，到时间自动唤醒，没有自旋，也没有额外开销，比Semaphore开销小。</li>
<li>从应对突发请求来看，Semaphore没有机制来应对，突发的大流量可能直接使等待链表变得超级大，<strong>而RateLimiter可以通过”令牌空闲累积“以及“预支”的策略来保证1秒的内的实际请求量可能临时大于限值，等桶中令牌消耗完了就会趋于稳定，稳定在我们限制的QPS中</strong>，这样在一定程度上保证了服务的可用性<strong>。</strong></li>
</ul>
</li>
</ul>
<h1 id="关于并发数和QPS的思考"><a href="#关于并发数和QPS的思考" class="headerlink" title="关于并发数和QPS的思考"></a>关于并发数和QPS的思考</h1><p>　　  这里先明确一个概念，在实际的业务场景中，QPS是稳定的，影响服务器性能的主要是并发数，试想一下如果我们服务的响应时间特别短，在某一个时刻我们预期的并发数会很低，不会对服务器造成很大的压力，符合逻辑；如果时延很高，这就表示我们的服务链出了问题，这样系统在某个时刻的并发数就会很高，因为时延高会导致某些线程迟迟不释放系统资源。这也是符合逻辑的。</p>
<p> 　　根据以上逻辑，这套QPS和并发量的转换公式就是：$QPS = 1000 / t <em> C$。$t$表示服务的平均响应时延，$C$表示该服务在这个QPS下的最大并发量。在使用Semaphore中，我们将会进行单机的并发数限流，通过上面的公式，我们可以对并发数的控制有一个相应的预期，<em>*在控制并发数的前提下，服务的稳定性会影响QPS（默认在限流生效的情况下），</em></em>如果服务时延降低，QPS预期会提高，如果服务时延提高，对应的QPS就会下降；我建议对被限流的请求进行打点统计，因为在限制并发数的前提下，QPS的降低不一定是用户侧的问题，也可能是服务稳定性的问题，比如网络的波动也会导致QPS降低。</p>
<p>　　举个简单的例子：某个服务的QPS有15W，平均请求时延为40ms，部署了600个实例。</p>
<p>　　这就是说，我们平时对这个服务的QPS期望不超过15W，单机平均QPS为：$Q = 150000 / 600 = 250$; 此时如果用Semaphore限流，设置的最大并发数为: $C = 250 * 40 / 1000 = 10$。也就是说，如果服务的时延稳定在40ms，理论上最大设置10个并发就能满足15WQPS的需要。</p>
<p>　　日常使用的时候，用RateLimiter可能更加直观，但是RateLimiter有一个问题：在满额QPS在跑的时候，如果服务可用性下降，请求时延陡增，系统的并发数也会陡增，导致严重的后果。因此，如果使用RateLimiter，建议对服务的请求时延做一个监控，当时延超过一定的阈值的时候，对服务降级处理，防止对服务器产生过大的压力。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://guava.dev/releases/snapshot-jre/api/docs/" target="_blank" rel="noopener">Google Guava API DOCS</a></li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">Java8 API DOCS</a></li>
<li><a href="https://www.django-rest-framework.org/api-guide/throttling/" target="_blank" rel="noopener">DRF框架 Throttling API DOCS</a></li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>限流</tag>
      </tags>
  </entry>
  <entry>
    <title>HTTP详解</title>
    <url>/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文主要梳理HTTP协议的知识体系</p>
<ol>
<li>HTTP基础</li>
<li>DNS</li>
<li>HTTP缓存策略</li>
<li>HTTPS</li>
<li>常见问题</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="HTTP各版本之间的差异"><a href="#HTTP各版本之间的差异" class="headerlink" title="HTTP各版本之间的差异"></a>HTTP各版本之间的差异</h1><p>超文本传输协议。<strong>「HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范」</strong>。</p>
<h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h2><ul>
<li>只有一个GET请求，只支持纯文本，早已过时</li>
</ul>
<h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h2><ul>
<li>可以传送任何格式的文件，如图像、视频、文本等。</li>
<li>除了GET命令，还有POST和HEAD等。</li>
<li>HTTP的请求和回应的格式改变，除了数据部分，每次通信还必须包含头信息（HTTP header），用来描述一些元数据。</li>
<li>只使用header中<code>If-Modified-Since</code> 和<code>Expires</code>作为缓存失效的标准。</li>
<li>不支持断点续传，每次都会传送全部的页面和数据。</li>
<li>通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）</li>
<li><code>keep-alive</code>（默认关闭）</li>
</ul>
<h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h2><p>HTTP是当前最主流的http协议版本。</p>
<ul>
<li>支持持久连接（presistent connection），即TCP连接默认不关闭，可以被多个请求复用。长连接的连接时长由请求头中的<code>keep-alive</code>（默认开启）来设置。</li>
<li>引入了管道机制（pipeline），即在同一个TCP连接里，客户端可以同时发送多条请求，提高了HTTP协议的效率。</li>
<li>HTTP 1.1 中新增加了 <code>E-tag，If-Unmodified-Since, If-Match, If-None-Match</code>等缓存控制标头来控制缓存失效。</li>
<li>支持断点续传，通过使用请求头中的<code>Range</code>来实现。</li>
<li>使用了虚拟网络，在一台物理服务器上可以存在多个物理主机（Multi-homed Web Servers），并且它们共享一个ip地址。</li>
<li>新增方法：PUT、 PATCH、 OPTIONS、 DELETE。</li>
</ul>
<h2 id="HTTP-1-x-的版本问题"><a href="#HTTP-1-x-的版本问题" class="headerlink" title="HTTP 1.x 的版本问题"></a>HTTP 1.x 的版本问题</h2><ul>
<li>传输的数据都是明文，没有加密，客户端和服务端都无法验证对方的身份，很不安全。</li>
<li>HTTP/1.1默认允许复用TCP连接，但是在同一个TCP连接里，所有的数据都是有序传输的，服务器只有处理完一个回应后才会去处理下一个，因此如果前面有数据阻塞，后面的都无法传输，这就是<strong>队头阻塞</strong>。</li>
<li>HTTP/1.x 支持长连接，为了避免创建多次连接产生的延迟，但是这同样会给服务器带来压力。对于单文件的请求，在请求结束后还会保持不必要的连接。</li>
</ul>
<h3 id="聊一聊队头阻塞"><a href="#聊一聊队头阻塞" class="headerlink" title="聊一聊队头阻塞"></a>聊一聊队头阻塞</h3><p>　　对于每一个HTTP/1.x请求而言，这些任务是会被放入一个任务队列中串行执行的，一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是<code>HTTP队头阻塞</code>问题。可以通过如下方式解决：</p>
<ul>
<li>并发连接：增加多个TCP连接。</li>
<li>域名分片：把一个域名分成很多二级域名，相当于也是增加了多个连接</li>
</ul>
<h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><ul>
<li><strong>二进制分帧：</strong>将数据全部转为二进制，头信息和数据体都是二进制，统称为<strong>“帧”</strong>：头信息帧和数据帧。</li>
<li><strong>头部压缩：</strong>HTTP/1.x版本中可能会出现的<code>User-Agent、Cookie、Accept、Server、Range</code>等字段可能会占用几百甚至几千字节，而body部分可能才几十字节，导致头部偏重。HTTP 2.0 使用 <code>HPACK</code> 算法进行压缩。</li>
<li><strong>多路复用：</strong>复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求和回应，且不用按照顺序一一对应，这样就解决了队头阻塞的问题。</li>
<li><strong>服务器推送：</strong> 允许服务器未经请求，主动向客户端发送资源，即服务器推送。</li>
<li><strong>请求优先级：</strong> 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</li>
</ul>
<h1 id="HTTP-2-0介绍"><a href="#HTTP-2-0介绍" class="headerlink" title="HTTP 2.0介绍"></a>HTTP 2.0介绍</h1><p>更加详细且权威的内容请参考：<a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-CN" target="_blank" rel="noopener">谷歌开发手册HTTP2.0</a>。</p>
<h2 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h2><p>　　上一节讲到HTTP/1.x的头部包含了太多的内容，导致头部偏重的问题。HTTP/2.0采用了HPACK算法进行了头部压缩。这一节主要介绍一下HPACK算法。官方文档：<a href="https://www.rfc-editor.org/rfc/rfc7541.txt" target="_blank" rel="noopener">RFC7541</a>。</p>
<h3 id="HPACK"><a href="#HPACK" class="headerlink" title="HPACK"></a>HPACK</h3><ul>
<li><p><strong>基本原理：</strong>HPACK 使用2个索引表(静态索引表和动态索引表)来把头部映射到索引值，并对不存在的头部使用哈夫曼编码，并动态缓存到索引，从而达到压缩头部的效果。</p>
<p>  <img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/hpack.png" alt></p>
<blockquote>
<p>从上面看，我们可以看到类似于索引表，每个索引表对应一个值，比如索引为2对应头部中的method头部信息，这样子的话，在传输的时候，不在是传输对应的头部信息了，而是传递索引，对于之前出现过的头部信息，只需要把<strong>「索引」</strong>(比如1，2，…)传给对方即可，对方拿到索引查表就行了。</p>
</blockquote>
</li>
<li><p>静态索引表：定义在RFC中的固定头部，当发送的值符合索引表时，只需要发送索引值就行。比如<code>2 :method GET</code>和<code>3 :method POST</code>是静态表中的两个字段，这样请求的方式如果是<code>GET</code>就可以只发送索引2。</p>
</li>
<li><p>动态索引表：动态表是一个由先进先出的队列维护的有空间限制的表，里面同样维护的是头部与对应的索引。<strong>每个动态表只针对一个TCP连接，也就是说每个TCP连接压缩解压缩的上下文中有且只有一个动态表。</strong>当一个头部没有出现过的时候，会把他插入动态表中，下次同名的值就可能会在表中查到到索引并替换掉头部。动态表初始为空。</p>
</li>
</ul>
<h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>HTTP/1.x中，如果想并发多个请求需要建立多个TCP连接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP连接请求限制。</p>
<p>HTTP/2.0：</p>
<ul>
<li><p>同域名的所有通信在单个连接上完成</p>
</li>
<li><p>单个通信可以承载任意数量的双向数据流</p>
</li>
<li><p>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，根据帧首部的流标识重新组装，也就是<code>Stream ID</code>，这个标识符标志了这个帧是属于哪一条消息的，通过这个标识符，接收方就可以从乱序的二进制帧中选择ID相同的帧，按照顺序进行组装成一个报文。</p>
</li>
<li><p>这里要注意一下，TCP是字节有序的协议，所有报文之间必须顺序传送，<strong>同一个报文的帧也是顺序传送的</strong>，但是不同报文的帧可以交错，如下图：</p>
<p>  <img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/多路复用.png" alt></p>
</li>
</ul>
<h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><p>浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源（发送多个响应），这样浏览器就不用发起后续请求。</p>
<p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/服务器推送.png" alt></p>
<blockquote>
<p>HTTP/2 打破了严格的请求-响应语义，支持一对多和服务器发起的推送工作流，在浏览器内外开启了全新的互动可能性。 这是一项使能功能，对我们思考协议、协议用途和使用方式具有重要的长期影响。</p>
</blockquote>
<p>​        为什么在浏览器中需要一种此类机制呢？一个典型的网络应用包含多种资源，客户端需要检查服务器提供的文档才能逐个找到它们。 那为什么不让服务器提前推送这些资源，从而减少额外的延迟时间呢？ 服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场。</p>
<p><strong>优势：</strong></p>
<ul>
<li>推送资源可以由不同页面共享</li>
<li>服务器可以按照优先级推送资源</li>
<li>客户端可以缓存推送的资源</li>
<li>客户端可以拒收推送过来的资源</li>
</ul>
<h2 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h2><p>以前的版本都是明文传输，不利于计算机解析。HTTP/2.0采用二进制格式，全部传输01串，便于计算机解码。</p>
<p>这样子，一个报文就被拆分成一个个二进制帧，用<strong>Headers帧</strong>存放头部字段，<strong>Data帧</strong>存放请求体数据。</p>
<h3 id="数据流-消息-帧"><a href="#数据流-消息-帧" class="headerlink" title="数据流 消息 帧"></a>数据流 消息 帧</h3><p>这里简单解释一下数据流，消息和帧的概念：</p>
<ul>
<li>数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。</li>
<li>消息：与逻辑请求或响应消息对应的完整的一系列帧。</li>
<li>帧：HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。</li>
</ul>
<p>这些概念的总结如下：</p>
<ul>
<li>所有通信都在一个TCP连接上完成，此连接可以承载任意数量的双向字节流。</li>
<li>每个数据流都有唯一的标识符和可选的优先级信息，用于承载双向消息。</li>
<li>每条消息都是一条逻辑HTTP消息（请求或者响应），包含一个或多个帧</li>
<li>帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装（所谓乱序）。</li>
</ul>
<h3 id="乱序帧的组装"><a href="#乱序帧的组装" class="headerlink" title="乱序帧的组装"></a>乱序帧的组装</h3><ul>
<li><strong>所谓的乱序，指的是不同ID的Stream是乱序的，对于同一个<code>Stream ID</code>的帧是按顺序传输的。</strong>（不厌其烦地再解释一遍）</li>
<li>接受方收到二进制帧之后，把相同<code>Stream ID</code>的帧组装成完整的请求报文或响应报文。</li>
<li>二进制帧中有一些字段，控制着<code>优先级</code>和<code>流量控制</code>等功能，这样子的话，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验。</li>
</ul>
<h1 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h1><p>RFC定义了HTTP的状态码为三位数，第一个数字为响应的类别，一共分为五类。</p>
<ul>
<li><strong>1XX：</strong>代表请求已接受，需要后续处理</li>
<li><strong>2XX：</strong>表示成功</li>
<li><strong>3XX：</strong>重定向状态</li>
<li><strong>4XX：</strong>客户端错误</li>
<li><strong>5XX：</strong>服务端错误</li>
</ul>
<h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><ul>
<li><strong>200 OK</strong>：表示客户端的请求在服务端被正确请求。</li>
<li>204 No Content：表示请求成功，但是没有资源返回。</li>
<li>206 Paritial Content：表示客户端进行了范围请求，服务端成功执行了这部分的请求。响应报文中包含由<code>Content Range</code>指定范围的实体内容。</li>
</ul>
<h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><ul>
<li><strong>301 moved permanently：</strong>永久重定向，表示资源已被分配了新的URL，这时应该按 Location 首部字段提示的 URL 重新访问。</li>
<li><strong>302 found：</strong>临时重定向，表示资源被临时分配了新的URL。</li>
<li>303 see other：表示资源存在着另一个URL，应使用GET方法获取资源。</li>
<li>304 not modified，当协商缓存命中时会返回这个状态码。</li>
<li>307 temporary redirect，临时重定向，和302含义相同,不会改变method</li>
</ul>
<blockquote>
<ol>
<li><p>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送</p>
</li>
<li><p>301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做</p>
</li>
</ol>
</blockquote>
<h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><ul>
<li><p>400 bad request：请求报文存在语法错误。</p>
</li>
<li><p>401 unauthorized：表示发送的请求需要有通过HTTP认证的认证信息。</p>
</li>
<li><p>403 forbidden：表示请求资源的请求被服务器拒绝。</p>
</li>
<li><p>404 not fond：表示在服务器上没有找到相应的资源。</p>
</li>
<li><p>405 Method Not Allowed：服务器禁止使用该方法，客户端可以通过options方法来查看服务器允许的访问方法，如下 ：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Access-Control-Allow-Methods →GET,HEAD,PUT,PATCH,POST,DELETE</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><ul>
<li>500 internal sever error：表示服务端在执行请求时出现了错误。</li>
<li>502 Bad Gateway：服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道。</li>
<li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求。</li>
</ul>
<h1 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul>
<li>缓解服务器的压力</li>
<li>降低客户端获取资源的速度：缓存一般存在在内存中，而且缓存服务器可能比源服务器更近一点（浏览器缓存）。</li>
</ul>
<h2 id="储存位置"><a href="#储存位置" class="headerlink" title="储存位置"></a>储存位置</h2><ul>
<li>代理服务器进行缓存</li>
<li>客户端浏览器进行缓存</li>
</ul>
<h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>浏览器在请求资源时会先判断有没有命中强缓存。HTTP/1.0 版本用<code>Expires</code>字段来控制强缓存，HTTP/1.1 版本使用<code>Cache-Control</code>来控制。</p>
<h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>　　设置缓存的过期时间，这个时间是针对服务器时间而言的，存在于服务器返回的响应头中，在这个过期时间内可以使用缓存，不需要再次请求。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Expires:Mon, 29 Jun 2029 11:10:23 GMT <span class="comment"># 过期时间为2029年06月29日</span></span><br></pre></td></tr></table></figure>
<p>　　可以注意到，浏览器的时间和服务器的时间可能不一致，因此在HTTP/1.1中用新的字段<code>Cache-Control</code></p>
<h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>　　<code>Cache-Control</code>通过设置<code>Max-Age</code>来设置缓存的过期时间。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Cache-Control:max-age=6000 <span class="comment"># 6000秒后过期</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li><p>当<code>Expires</code>和<code>Cache-Control</code>同时存在时，优先考虑Cache-Control。</p>
</li>
<li><p>当然了，当缓存资源失效了，也就是没有命中强缓存，接下来就进入协商缓存</p>
</li>
</ul>
<h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p> 　　强缓存失效后，浏览器在请求头中携带响应的<code>缓存Tag</code>来向服务器发送请求，服务器根据对应的tag，<strong>来决定是否使用缓存</strong>。Tag分为两种，<code>Last Modified</code>和<code>ETag</code>。如果两种方式都支持的话，服务器会优先考虑<code>ETag</code>。</p>
<h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last Modified"></a>Last Modified</h3><p>　　这个字段表示最后修改时间，当浏览器给服务器第一次发请求后，服务器会在响应头中加上这个字段。浏览器接收到这个请求后，如果<strong>再次发起请求</strong>，会在请求头中携带<code>IF-Modified-Since</code>字段，这个字段值就是服务器传来的最后修改时间。服务器拿到<code>IF-Modified-Since</code>字段后，<strong>会与服务器资源目前最新修改的时间最对比</strong>：</p>
<ul>
<li>如果<code>IF-Modified-Since</code>比最新修改的时间要小，也就是说服务器资源更新了，那么就会返回新的资源。</li>
<li>如果相等，则说明资源没有修改，那么返回304，告诉浏览器直接用缓存。</li>
</ul>
<h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>　　ETag是服务器根据当前文件的内容，对文件生成唯一的标识，比如MD5算法，只要里面的内容有改动，这个值就会修改，<strong>服务器通过把响应头把该字段给浏览器</strong>。浏览器接收到Tag值，会在下次请求中把这个值放到<code>IF-None-Match</code>字段里发个服务器。服务器拿到这个值后，和最新资源的ETag做对比：</p>
<ul>
<li>相等，返回304</li>
<li>否则，返回新的资源</li>
</ul>
<h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul>
<li><p>性能上，<code>Last-Modified</code>优于<code>ETag</code>，<code>Last-Modified</code>记录的是时间点，而<code>Etag</code>需要根据文件的MD5算法生成对应的hash值。</p>
</li>
<li><p>精度上，<code>ETag</code>优于<code>Last-Modified</code>。<code>ETag</code>按照内容给资源带上标识，能准确感知资源变化，<code>Last-Modified</code>在某些场景并不能准确感知变化，比如：</p>
<ul>
<li>编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。</li>
<li>Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。</li>
</ul>
</li>
</ul>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li><p>首先检查<code>Cache-Control</code>， 看强缓存是否可用</p>
</li>
<li><p>如果可用的话，直接使用</p>
</li>
<li><p>否则进入协商缓存，发送HTTP请求，服务器通过请求头中的<code>If-Modified-Since</code>或者<code>If-None-Match</code>字段检查资源是否更新</p>
</li>
<li><p>资源更新，返回资源和200状态码。</p>
</li>
<li><p>否则，返回304，直接告诉浏览器直接从缓存中去资源。</p>
</li>
</ol>
<h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="和HTTP的区别"><a href="#和HTTP的区别" class="headerlink" title="和HTTP的区别"></a>和HTTP的区别</h2><p>　　HTTPS相比HTTP就是多了一个安全性的概念，实际上，HTTPS并不是一个全新的应用层协议，它就是<code>HTTP + TLS/SSL</code>，而安全性就是<code>TLS/SSL</code>做的工作。</p>
<ul>
<li>SSL（Secure Sockets Layer）：安全套接层</li>
<li>TLS（Transport Layer Security）：传输层安全，目前使用的版本是1.2</li>
</ul>
<p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/HTTPS.png" alt></p>
<p>主要有如下区别：</p>
<ul>
<li>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li>
<li>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页。</li>
<li>HTTPS标准端口443，HTTP标准端口80。</li>
<li>HTTPS需要用到SSL证书，而HTTP不用。</li>
</ul>
<p><strong>HTTPS有两点关键的作用：</strong></p>
<ul>
<li>建立信息安全的通道，保证数据传输的安全。</li>
<li>对网站服务其进行真实身份验证。</li>
</ul>
<h2 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h2><p>工作原理就是过了一层<code>SSL/TCL</code>连接。</p>
<blockquote>
<p>TLS/SSL 的功能实现主要依赖于三类基本算法：<code>散列函数</code> 、<code>对称加密</code>和<code>非对称加密</code>。</p>
<ul>
<li>非对称加密实现身份认证和密钥协商</li>
<li>对称加密算法采用协商的密钥对数据加密</li>
<li>散列函数验证信息的完整性。</li>
</ul>
</blockquote>
<h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>　　对称加密就是指客户端和服务端使用同一个密钥来加密明文。</p>
<p>　　但是不同的客户端密钥肯定不同，服务器要和客户端拥有相同的密钥就需要把密钥从客户端通过HTTP传输过来，这样密钥就会被拦截，很不安全。但是如果这个密钥别人获取不到，那么就是安全的。</p>
<h3 id="非对称加密TLS-1-2"><a href="#非对称加密TLS-1-2" class="headerlink" title="非对称加密TLS 1.2"></a>非对称加密TLS 1.2</h3><p>　　采用的算法是RSA，所以在一些文章中也会看见<strong>传统RSA握手</strong>，基于现在TLS主流版本是1.2，所以接下来梳理的是<strong>TLS/1.2握手过程</strong>。非对称加密需要知道以下要点：</p>
<ul>
<li>有一堆密钥，公钥和私钥。</li>
<li>公钥加密的内容，只有私钥也可以解开，私钥加密的内容，只有公钥可以解开。</li>
<li>公钥发送给所有客户端，私钥只保存在服务端。</li>
</ul>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/TLS1.2.PNG" alt></p>
<p><strong>步骤解释：</strong></p>
<ol>
<li><p>Client发送一个HTTPS请求，连接443端口。这个请求可以理解成是<strong>请求公钥</strong>。</p>
</li>
<li><p>Server端收到请求后通过第三方机构私钥加密，会把数字证书（公钥证书）发给Client。</p>
</li>
<li><p>浏览器验证公钥证书</p>
<ul>
<li><p>浏览器安装后会自动带一些权威第三方机构公钥，使用匹配的公钥对数字签名进行解密。</p>
</li>
<li><p>根据签名生成的规则对网站信息进行本地签名生成，然后两者比对。</p>
</li>
<li><p>通过比对两者签名，匹配则说明认证通过，不匹配则获取证书失败。</p>
</li>
</ul>
</li>
<li><p>在安全拿到<strong>服务器公钥</strong>后，客户端Client随机生成一个<strong>会话密钥</strong>（SessionID），使用<strong>服务器公钥</strong>（证书的公钥）加密这个<strong>对称密钥</strong>，发送给Server(服务器)。</p>
</li>
<li><p>Server端用私钥解密得到会话密钥，至此两端都有了一个相同的密钥作为<strong>对称密钥</strong>。</p>
</li>
<li><p>两端使用对称密钥对请求的数据进行加密和解密</p>
</li>
</ol>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>　　在第二步的时候，我发给Client的公钥证书被劫持且篡改了怎么办？因为证书中有公钥，这个公钥是公开的，如果有中间人替换了这个公钥，Client是感知不到的。</p>
<p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/公钥劫持.png" alt></p>
<h2 id="第三方认证"><a href="#第三方认证" class="headerlink" title="第三方认证"></a>第三方认证</h2><p>如果只用非对称加密，一旦证书被劫持，Client感知不到。如果让Cilent可以感知呢？</p>
<h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>在HTTPS中，通过”<strong>证书 + 数字签名</strong>”来解决这个问题。</p>
<p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/数字签名.png" alt></p>
<p>　　可以看到，数字签名是单独加密的：<strong>使用第三方认证机构的私钥。</strong></p>
<p>　　如果证书再被劫持，把服务器的公钥替换成假的公钥，因为有数字签名的存在，客户端会发现数字签名不匹配。因为数字签名有第三方的私钥加密，这个私钥中间人是不知道的。<font color="red">数字签名用<strong>散列函数</strong>计算了<strong>公钥证书</strong>中部分信息</font>，如果中间人修改了公钥证书，客户端解开数字签名后，内容就会不匹配，这就保证了可靠性。</p>
<h3 id="客户端如果对比数字签名？"><a href="#客户端如果对比数字签名？" class="headerlink" title="客户端如果对比数字签名？"></a>客户端如果对比数字签名？</h3><ol>
<li>浏览器会去安装一些比较权威的第三方认证机构的公钥，比如VeriSign、Symantec以及GlobalSign等等。</li>
<li>验证数字签名的时候，会直接从本地拿到相应的第三方的公钥，对私钥加密后的数字签名进行解密得到真正的签名。</li>
<li>然后客户端利用签名生成规则（这里具体的规则就不讲了，散列函数只是一种）进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。</li>
</ol>
<h2 id="SSL断开后如何恢复？"><a href="#SSL断开后如何恢复？" class="headerlink" title="SSL断开后如何恢复？"></a>SSL断开后如何恢复？</h2><p>　　可以看到，HTTPS建立连接十分麻烦，且十分耗时。有两种方式可以快速的恢复SSL连接，一种是使用SessionID，另一种是Session Ticket。</p>
<h3 id="SessionID"><a href="#SessionID" class="headerlink" title="SessionID"></a>SessionID</h3><p>　　使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，<strong>如果我们的请求通过负载平衡被转移到了其他的服务器上</strong>，那么就无法恢复对话。</p>
<h3 id="Session-Ticket"><a href="#Session-Ticket" class="headerlink" title="Session Ticket"></a>Session Ticket</h3><p>　　另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。</p>
<h1 id="短轮询、长轮询和-WebSocket"><a href="#短轮询、长轮询和-WebSocket" class="headerlink" title="短轮询、长轮询和 WebSocket"></a>短轮询、长轮询和 WebSocket</h1><h2 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h2><p><strong>短轮询的基本思路:</strong></p>
<ul>
<li>浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行 响应。</li>
<li>这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。</li>
</ul>
<p><strong>优缺点：</strong></p>
<ul>
<li>优点是便于理解</li>
<li>缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</li>
</ul>
<h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p><strong>长轮询的基本思路:</strong></p>
<ul>
<li>首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。</li>
<li>如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。</li>
</ul>
<p><strong>优缺点：</strong></p>
<ul>
<li>长轮询和短轮询比起来，它的优点是<strong>「明显减少了很多不必要的 http 请求次数」</strong>，相比之下节约了资源。</li>
<li>长轮询的缺点在于，连接挂起也会导致资源的浪费。</li>
</ul>
<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><ul>
<li><p>WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。</p>
</li>
<li><p>使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息。</p>
</li>
</ul>
<h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>DNS协议提供了一种主机名到IP地址的转换服务，就是我们常说的域名系统。这是应用层的协议，通常该协议建立在UDP之上，这就要求域名解析器和域名服务器都必须自己处理超时和重传来确保可靠性，使用53端口号。有两种情况会建立TCP连接：</p>
<ul>
<li>返回的响应超过了512个字节（UDP最多传递512字节）</li>
<li>区域传送（主域名向辅助域名传送数据）</li>
</ul>
<h2 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h2><ol>
<li>客户端不会直接去请求本地DNS服务器，而是通过下图流程一步步查询：</li>
</ol>
<p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/客户端请求域名.png" alt></p>
<ol>
<li>本地DNS服务器查询IP的过程一般是<strong>递归查询</strong></li>
</ol>
<p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/本地DNS迭代查询.png" alt></p>
<ol>
<li><strong>迭代查询：</strong>用户请求DNS服务器后，DNS服务器直接返回结果，如果没有找到域名，则由用户自己发送下一级请求。</li>
</ol>
<p>　　可以这么理解：本地服务器看起来自己的请求时递归的，因为我只需要发一次请求，但是本地DNS服务器的请求是迭代的，需要服务器一次次去查询。</p>
<h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><p>　　在一个请求中，当某个DNS服务器收到一个DNS回答后，他能够将回答中的信息存储到本地储存器中。返回资源中的TTL代表该记录的缓存时间。</p>
<h2 id="DNS为什么要使用UDP？"><a href="#DNS为什么要使用UDP？" class="headerlink" title="DNS为什么要使用UDP？"></a>DNS为什么要使用UDP？</h2><p><strong>「DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。」</strong></p>
<ul>
<li>为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢。</li>
<li>大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。</li>
</ul>
<h2 id="DNS实现负载均衡"><a href="#DNS实现负载均衡" class="headerlink" title="DNS实现负载均衡"></a>DNS实现负载均衡</h2><p>想不到吧，DNS还能做负载均衡，因为一个域名可能对应不同的ip。</p>
<ul>
<li>当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合</li>
<li>在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。</li>
<li>以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。</li>
</ul>
<h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul>
<li>DNS域名系统是应层的协议，运行在UDP之上，使用端口53</li>
<li>查询过程，本地查询是递归查询，依次通过 <strong>浏览器缓存—-本地hosts文件—-本地DNS解析器—-本地DNS服务器—-其他域名服务器请求</strong>。 接下来的过程就是迭代过程。</li>
<li>递归查询一般而言，发送一次请求就够，迭代过程需要用户发送多次请求。</li>
</ul>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://www.jianshu.com/p/f44b930cfcac" target="_blank" rel="noopener">HPACK完全解析</a></li>
<li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-CN" target="_blank" rel="noopener">HTTP/2简介 Google</a></li>
<li><a href="https://juejin.im/post/6857287743966281736#heading-59" target="_blank" rel="noopener">「查缺补漏」巩固你的HTTP知识体系</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#%E5%85%ADhttps" target="_blank" rel="noopener">CS-NOTE</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
        <tag>面试题</tag>
      </tags>
  </entry>
  <entry>
    <title>计网相关基础知识</title>
    <url>/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文旨在介绍计网的相关基础知识，只介绍到网络层之上</p>
<ol>
<li>计算机网络概述</li>
<li>应用层</li>
<li>Socket</li>
<li>传输层</li>
<li>网络层</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><p>​    计算机网络就是为了解决<strong>计算机之间的通信问题</strong>。通讯就是指数据的交换，即信息的交换。计算机的世界里，一切信息都是数据。</p>
<p>​    与计算机网络有关的东西有很多：网线，网卡，路由器，IP地址，TCP，HTTP，FTP等等。这些东西分别对应着计算机网络中的不同层次。层次有不同的分法：</p>
<ul>
<li>OSI模型将计算机网络分成了7层，由上至下分别是：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。因为分的太细，与实际操作时不相匹配的，因此市场上很少使用这种模型。</li>
<li>市场上成功的模型一般是四层或者五层，分成五层比较好理解：应用层、传输层、网络层、数据链路层、物理层。网线属于物理层，网卡属于数据链路层，路由器属于网络层，对应的协议有IP和ICMP协议，TCP属于传输层，HTTP属于应用层等等。</li>
</ul>
<p>​    计算机网络分层的原因在于其体系结构太复杂了，按照不同设备的功能划分成不同的层次更易于规范的标准化，而且每一层相对其它层独立且透明，这一层变化了也不影响其他层的工作，更易于维护。透明的含义可以解释如下：计算机网络的每一层之间不需要理解对方是则怎么工作的，我只需要接收下层给我的数据，这个数据符合我定义的数据规范，我解读并处理了该数据后，按照上一层定义的数据格式封装我的数据，并提交给上一层，上一层就能正确接收到我的数据。分层之后，某层的修改不会影响到其他层，<strong>举个通俗的例子：</strong>IPV4和IPV6是网络层不同版本的协议，但是这两种版本的切换对应用层HTTP是没有区别的，因为不管用IPV4或者IPV6，传给HTTP的数据格式都是一样的。</p>
<h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>​    应用层协议比较多，每个协议有不同的功能和用法，比如HTTP用于网页内容的传输，FTP用于文件的传输，SMTP用于邮件的传输等。HTTP是做web服务必须了解的知识点，但是内容很多，我单独写了一片博客：<a href>HTTP详解</a></p>
<h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>​    在应用层和传输层之间有一个接口叫做Socket。Socket不属于某一个层，它可以理解应用层和传输层之间的一个管道，用来连接操作系统和应用层中的具体应用进程，应用可以操作Socket来使用操作系统的网络功能。</p>
<p>​    因为传输层之下基本都是由操作系统控制，而应用层协议是由应用进程控制，所以要定义一个接口来建立起应用进程和底层协议的桥梁，这个接口的实现就是Socket。大部分操作系统都实现了Socket。</p>
<h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>​    传输层最经典的两个协议是TCP和UDP，其他的比如DCCP，SCTP本文就不讲了。传输层提供的是应用进程之间的逻辑通信机制。传输层通过Socket提供的端口号，把一个进程的数据传送到另一个进程。</p>
<p>​    传输层有多路复用的概念，这和物理层中的多路复用不一样，物理层的多路复用是指物理线路上的复用，如：频分复用、码分复用等；而传输层中多路复用是指：多个数据报被同时接收，计算机如何处理这些数据包是如何分发，按照什么原则分发。在传输层之下，所有的数据包都经过了相同的处理，但到了传输层，不同的数据包传输就有了区别。所有其他主机给我发送的所有UDP数据包都会被提交到同一个端口，而TCP数据包会根据其连接的不同分发给不同的端口。因为TCP连接是一对一的，每个端口只对应一个连接，也同时对应发送数据的主机上某个唯一端口，因此如果发送数据的主机想要和我创建多条TCP连接，需要创建不同的进程或者线程，还需要相应的端口号。</p>
<h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>​    UDP只对IP协议做简单的拓展，仅仅只把网络层传输过来的数据区分一下端口号，就递给进程了，有可能也会做一点简单的错误检测。UDP有以下的好处（主要和TCP对比）：</p>
<ol>
<li>不需要建立连接，因此数据请求的延迟小；</li>
<li>实现简单，不需要负责实现过程，比如维护连接等；</li>
<li>头部开销很小，在数据内容之上，只包装了一些区别端口号和差错检验的账号；</li>
<li>应用层可以很好地对其进行拓展。</li>
</ol>
<p>​    UDP数据报的结构如下：<img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/UDP数据包.png" alt></p>
<p>​    可以看到，一个UDP数据报，除了具体的传输数据，还在首部增加了8个字节的数据用来区分端口，限制长度和差错校验。其中这个数据长度是包含了8个字节的头部数据的，可以看出一个UDP的数据包的长度是有限制的，不能太大。UDP的源端口号可以省略，如果省略则代表了我的数据一旦发出去，就不需要回复了；校验和字段也可以省略，不过一般都会做一些简单的校验，防止数据在传输过程中出错，导致数据乱序，残缺。这种数据应用层接受到是无法使用的。校验后这种错误的数据会在传输层废弃，然后给发送源一个ICMP数据包，告知数据错误，然后这个数据传输就结束了，因为UDP不提供重传机制。</p>
<p>​    UDP进行差错检验的方法和IP中的方法一致，这里先不提。UDP的差错检验保证了端口与端口之间正确传输的检测，也能核实出数据部分是否产生了错误。在进行差错检测时，会添加一些额外的数据参与计算，这些数据计算完之后就丢弃了，真正用来传输的数据格式还是上面那个。伪首部结构如下图红色的部分：</p>
<p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/UDP数据包-伪首.png" alt></p>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP是一个点到点（端口到端口）的协议，是一个可靠的，按序字节流的协议。是一个面向连接的协议。</p>
<p>接收方和发送方都会有一定的存储空间用来缓存数据，一般用于重传，分组重组等功能。</p>
<p>面向连接的含义：通信前必须建立连接，两端维护连接，中间节点不连接。</p>
<p>TCP提供了可靠的数据传输，流量控制和拥塞控制。</p>
<h3 id="可靠的数据传输"><a href="#可靠的数据传输" class="headerlink" title="可靠的数据传输"></a>可靠的数据传输</h3><p>​    TCP实现可靠的数据传输主要是基于一种确认（acknowledge，ACK）机制。简单说来就是，我发你一个数据包，你得告诉我你收到了，不然我默认你没收到，等一段时间后就会重新发这个数据包给你，直到你告诉我你收到了。这是保证可靠传输的逻辑。</p>
<p>​    在可靠传输的具体实现中，TCP采用的是累加确认，确认的是数据中的自己号，而不是确认收到了第几个数据包。正因如此，TCP才被叫做按序字节流的协议。</p>
<p>​    在TCP发出报文后，如果没有收到确认，要过多久才会重新发送数据呢？计算超时时间有一个算法，里面最主要的参数是RTT（Round Trip delay time），RTT指我发出一个报文开始，到我接受到ACK报文所经过的时间。根据历史值的平均数，和上一个数据包的 RTT 值，经过加权计算之后的值设置为当前数据报的超时时间。这样结合了当前网络和历史网络的状况后得到的结果最合理。如果我发过了一个报文，过了超时时间，就会重新发。因为等待ACK报文需要时间，一个个发报文严重影响传输效率，因此TCP一般都一段段发：<font color="red"><strong>TCP有一个滑动窗口机制</strong></font>，一段一段的发送数据，确认时只按收到了第几个字节数（可以理解成下一个报文的头位置）来确认。这一过程中会遇到这样的问题：第五段报文丢失了，第六段、第七段和第八段报文被接收了，接收方因为没有收到第五段报文，因此在收到第六段报文时，接收方会发一个第五段报文的ACK报文，然后又收到了第七段报文，没办法，只好再发一次第五段的ACK，然后又收到了第八段报文，只好再发一次第五段报文ACK，至此，接收方连续发送了<strong>三次</strong>第五段报文的ACK，发送方立刻重发第五段报文，这就是<font color="red"><strong>快重传机制</strong></font>，可见快重传不需要等待计时器超时。一般设置了3次重复ACK报文就会启动重传，因为如果丢包，必然会有两次以上的ACK，但是如果只收到了两次ACK，则很有可能是乱序造成的，这时候重传解决不了问题，详见<a href="https://www.zhihu.com/question/21789252/answer/110640581" target="_blank" rel="noopener">TCP 快速重传为什么是三次冗余 ACK，这个三次是怎么定下来的？</a></p>
<h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>上面讲到TCP的有一个滑动窗口机制。接收方也有一个缓存窗口。如果数据的读取很慢，但是网速却很快，数据大量集中，超过了接收方缓存的大小，这时候即使再来数据，也无法接收，于是接收方就不停地发送缓存窗口最后一个位置的ACK，然后发送方就会不停地进行重传，这大大浪费了网络资源。因此，<strong>接收方每次返回ACK报文时，会在报文中加入缓存空间的剩余量是多少</strong>，发送方根据剩余量的多少发送数据。<strong>这里有一个边界问题：如果接受方的ACK报文中剩余量为0时怎么办？</strong>肯定不可能停止发送数据，因为停止发送就再也不知道剩余缓存量的变化了。因此，如果接收方缓存剩余量为0，发送方会间歇性、尝试性地发送一组探测报文（ZWP），探测一下对方还有多少余量，如果余量变多了就恢复数据的传输，这就实现了TCP的流量控制。</p>
<h3 id="拥塞机制"><a href="#拥塞机制" class="headerlink" title="拥塞机制"></a>拥塞机制</h3><p>TCP采用的是端到端的控制方法，由两端的计算机控制，中间的路由不提供明显的控制。TCP的拥塞控制中有多种算法。目前TCP的拥塞控制流程一般是这样的：</p>
<ul>
<li>最一开始，采用<strong>慢开始</strong>算法，发送窗口的大小成指数上升到某一阈值。举个例子，窗口大小依次为：1，2，4，8，16，32，64（阈值ssthresh，假设这个值是64）</li>
<li>到达阈值后，采用线性增算法（<strong>拥塞避免</strong>），发送窗口的大小每个时间点增加一：64，65，66，67….。</li>
<li>这时候会出现两种情况<ul>
<li>当增加到80时，发送方连续收到三个相同的ACK：立刻将发送窗口大小设为40（减一半），并将阈值也设置成40，随后线性增加发送窗口大小的算法。<font color="red"><strong>这就是快恢复</strong></font>。</li>
<li>当增加到80时，发送方发现一个数据包超时了（也就是没有收到接收方的ACK报文），立刻把发送窗口的大小设置成1。</li>
<li>解释<ul>
<li>第一种情况要么是乱序，要么是丢包，不管是那种，数据包都是能够传输进来的，网络很通畅，因此可以指定快恢复。</li>
<li>第二种情况直接超时了，说明网络质量很差，这时候需要降低发送速率，防止阻塞。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>为什么TCP有拥塞控制？因为其有重传机制，网络环境差就会不停地重传，造成阻塞，而UDP不依赖于网络环境，丢了就丢了。</p>
<h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP报文.png" alt></p>
<p>由上至下依次解释如下：</p>
<ul>
<li>1、源端口号：数据发起者的端口号，16bit</li>
<li>2、目的端口号：数据接收者的端口号，16bit</li>
<li>3、<font color="red"><strong>序列号</strong></font>：32bit的序列号，<strong>真正发送数据时使用，告知当前发送的一段数据的<font color="red">首字节的序列号</font></strong>，如果发的报文不含数据（如确认报文），此字段是没有变化的。若 SYN=1 或 FIN =1 的数据报当作含有一字节数据。</li>
<li>4、<font color="red"><strong>确认序列号</strong></font>：32bit的确认号，是接收数据方<strong>期望收到发送方的下一个报文段</strong>的序号，<strong>因此确认序号应当是对方刚刚发给你的 TCP 报文中的序号字段加数据长度的值再<font color="red">加1</font>，是你的确认序号</strong>，你要回复他说，我收到你的数据了，所以要确认的是对方的序号。  </li>
<li>5、首部长度：4位，最大可表示的数为 15 。而光首部就有 20 字节，所以在这里规定，每个 1 代表 4 字节，就是上图中的一行，这个字段值为几，就是几行。最大可表示 15*4 = 60 字节。</li>
<li>6、保留：6bit，均为0</li>
<li>7、紧急URG：当URG=1时，表示报文段中有紧急数据，应尽快传送，紧急指针字段有效。</li>
<li>8、确认比特ACK：ACK = 1时代表这是一个确认报文，取值 0 则不是确认报文；</li>
<li>9、<strong>推送比特PSH</strong>：当发送端PSH=1时，接收端尽快的交付给应用进程；</li>
<li>10、复位比特（RST）：当RST=1时，表明TCP连接中出现严重差错，必须释放连接，再重新建立连接；</li>
<li>11、<strong>同步比特SYN：在建立连接是用来同步序号</strong>。<strong>一个报文中 SYN=1,ACK=0时，是表示这一个连接请求报文段。SYN=1，ACK=1时表示的是接收方同意建立连接。</strong></li>
<li>12、<strong>终止比特FIN</strong>：FIN=1时，表明此报文段的发送端的数据已经发送完毕，并要求释放传输连接。</li>
<li>13、<strong>窗口</strong>：就是提供流量控制的功能，表示可缓存字节数的多少。</li>
<li>14、校验和：该字段检验的范围包括首部和数据这两部分。由发端计算和存储，并由收端进行验证。</li>
<li>15、紧急指针：紧急指针在URG=1时才有效，它指出本报文段中的紧急数据的字节数。</li>
<li>16、选项：长度可变，最长可达40字节。绝大多数不适用此字段，也就是说 TCP 绝大部分是 20 字节。</li>
</ul>
<h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TCP是面向连接的，双方进行数据交换前必须建立连接。TCP的连接机制就是注明的三次握手，四次挥手。</p>
<h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>讲握手机制之前必须明确一个概念。序列号，用来标志我发送数据的第一个字节的序号。在建立连接前，会根据计算机的时钟信号初始化一个序列号，这个序列号是操作系统计算出来的（防止有人伪造连接）。目前我还没有发送数据，所以TCP头部信息中的序号的值就是初始值。</p>
<ul>
<li>发送端发起连接请求：向接收端发起一个请求连接的TCP报文，初始化一个序号x，SYN = 1, ACK = 0。</li>
<li>接收端收到连接请求，发起一个同意连接的TCP报文：接收端也会初始化一个序号y，SYN = 1, ACK = 1（同时确认序列号为：x + 1，可以简写成 ACK = x + 1)</li>
<li>发送端也发送了一次ACK，告知接收端我收到了你的同意：ACK = 1（确认序号为：y + 1，简写成 ACK = y + 1）</li>
</ul>
<p>​    两台主机都有自己的序号，建立连接的过程就是相互确认对方的序列号，从而在交换数据的时候保证有效。确认序号要确认的是期望得到的下一段报文的序号。</p>
<p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/三次握手.png" alt></p>
<p>​    为什么需要三次握手呢？发送方如果发送了一条请求连接的报文A，但是因为网络问题超时了，此时发送端会重新再发一条请求B，这两条请求的序号是不一样的，此时如果接收方返回了一个同意连接的请求C，这个C的确认序号是基于A报文的序号的，如果此时接收方建立了连接，那就是B和C建立了连接，此时序号对不上，那么数据传输就会失败。此时引入了三次握手，如果接受方收不到C报文的ACK，就不会建立连接。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ul>
<li>我准备断开连接了，此时发送一条请求断开连接的TCP报文：FIN = 1, seq = x + 2，ACK = 1（ACK = y + 1）。<ul>
<li>官方文档规定，除了建立连接，任何时候ACK都要是1</li>
<li>我一旦发出了FIN报文，我就不会再发送有数据的报文了</li>
<li>这里seq是x+2主要是为了与图片一致</li>
</ul>
</li>
<li>你收到了我的FIN报文，回复一个ACK，同意断开：ACK = x + 3<ul>
<li>此时，你虽然应答了我的断开连接报文，但是你仍可以继续传输数据。比如你的数据还没有穿完我就发给你一个断开连接的报文，如果你没有传完数据，是可以继续一直传的。</li>
</ul>
</li>
<li>你传完了数据，发我一个FIN：seq = y + 1</li>
<li>我收到了你的FIN，发送一个ACK：ACK = y + 2<ul>
<li>此时你如果收到了我的ACK，就可以立刻释放连接了</li>
<li>我不能释放连接，因为我不确定你有没有收到我的ACK，因此我需要等一段时间再释放（数据包最大存活时间的两倍：2MSL）</li>
</ul>
</li>
</ul>
<p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/四次挥手.png" alt></p>
<p>注意：</p>
<ol>
<li><p>收到我的FIN之后，如果你没有要传给我的数据，那么你就直接返回个FIN给我，这样就简化成了三次挥手。</p>
</li>
<li><p>为什么要四次挥手？要么保证发送方能够正确释放连接，要么保证接受方能够正确释放连接，少一个都不行。</p>
</li>
<li>为什么要等待2MSL，超过2MSL后，连接中的所有报文会自动丢弃，这样我释放连接再建立了新连接后，可以保证没有旧的报文。</li>
</ol>
<h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>​    网络层的核心功能是<strong>转发</strong>和<strong>路由</strong>。因为要实现路由和转发功能，所以这一层实现了很多路由协议，要实现转发，就需要知道转发地址，这用到了IP协议。IP协议中规定一些寻址规则，以及数据报过大时如何切成一小片一小片的问题等。此外，网络层还包括重要的 ICMP 协议，依托于这种协议的数据都像是网络中的指令，计算机或者中间路由设备就成为了官兵的角色，根据指令内容做出相应的动作反应。</p>
<h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><h3 id="基础知识科普"><a href="#基础知识科普" class="headerlink" title="基础知识科普"></a>基础知识科普</h3><p>​    IP地址是有限的，只有32bit，所以要对其进行划分，比如中国一部分，美国一部分。划分大块后还要继续划分，划给省、市、学校等等。这个划分过程，称为划分子网。于是就规定了，IP地址是有两个部分组成的<strong><font color="red">网络号和主机号</font></strong>。网络号的位置是不确定的，如果一个子网很大，网络号就小，主机号就可以很多。</p>
<p>​    以前会把IP地址划分成A,B,C类，还有划分子网的概念，将主机号中的一部分拿出来作为子网号：IP = 网络号 + 子网号 + 主机号。要使用子网必须使用子网掩码，一个B类地址默认的子网号是<code>255.255.0.0</code>，如果他的子网占两个比特，那么他的子网掩码就是<code>11111111.11111111.11000000.00000000 = 255.255.192.0</code>。外部网络是看不见子网的。</p>
<p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/IP地址分类.png" alt></p>
<p>​    现在划分子网的方式是CIDR（无类域间路由），形式是 <code>x.x.x.x/n</code>，例如：<code>202.113.132.45/24</code>，这表示前24位是网络号，后8位是主机号。</p>
<p>​    这里列举一些特殊的网络地址：</p>
<p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/特殊的网络地址.png" alt></p>
<p>​    以上特殊的网络地址有可能会碰到，放在这里记录一下。</p>
<p>​    还有一些是私有的网络地址，一般是自己的内部局域网访问，比如校园网什么的。如下图所示：</p>
<p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/私有网络地址.png" alt></p>
<h3 id="IP数据格式"><a href="#IP数据格式" class="headerlink" title="IP数据格式"></a>IP数据格式</h3><p>​    从传输层传来的TCP或UDP的段需要在网络层增加一个首部，然后在提交给数据链路层。网络层对数据作了些什么呢？首先网络层具有转发的功能，因此必须要知道数据的目的地，于是网络层对数据增加了目的地址，这个目的地址就IP地址，唯一地标识一台主机。网络层还会对超过MTU（Max Transfer Unit最大传输单元）的数据包进行分片。以太网的MTU是1500字节，这是经验的规定，因为如果MTU设置的太小，数据包被切成很多快，传输的错误率就会上升，不利于数据的传输；切的太大，又会增加传输的延迟。</p>
<p>​    IP数据报的结构如下：</p>
<p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/IP数据报.png" alt></p>
<ol>
<li><p><strong>版本 4bit</strong> 指 IP 协议的版本。目前广泛使用的 IP 协议版本号为 4 ，IPv6，版本号为 6 。</p>
</li>
<li><p><strong>首部长度</strong> <strong>4bit</strong> 单位是 4 个字节( 32bit 也就是上面的一行。因为 4bit 最大描述的数值是15，首部长度最短也需要20字节，不够描述的，所以单位改成 4 字节)，那这里的值一般为 5 。首部长度也就是 20 字节。首部长度大小取值范围 20 字节到 60 （4*15）字节，首部长度一般都是 20 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在4字节的整数倍开始。</p>
</li>
<li><p><strong>区分服务</strong> <strong>8bit</strong> 目前几乎不使用，若要支持区分服务，需要中间所有的路由器都支持区分服务，但是目前的绝大多数路由器都不支持，所以区分服务几乎不使用了。</p>
</li>
<li><p><strong>总长度 16bit</strong> 首部长度 + 数据长度，单位是字节。数据报的最大长度为 2^16-1 = 65535 字节。但由于数据链路层的最大传送单元 MTU &lt; 65535，所与当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的MTU值，若超过则需要分片(因此有上图的第二行，用于切片)。</p>
</li>
<li><p><strong>标识 16bit</strong> 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为 IP 是无连接服务，数据报不存在按序接收的问题。<strong>当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。<font color="red">相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报</font></strong>。</p>
</li>
<li><p><strong>标志 3bit</strong> 目前只有2位有意义。标志字段中间的一位记为 DF (Don’t Fragment)，意思是“不能分片”。只有当DF=0时才允许分片，若为 1 则不分片。标志字段中的最低位记为 MF (More Fragment)。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。 </p>
</li>
<li><p><strong>片偏移 13bit</strong> 当一个较长的 IP 数据报在分片后，分片后的某一片的第一个 bit 在原分组中的相对位置。也就是说，相对传输层数据报的数据部分的起点，该片从何处截断的。片偏移以 8 个字节为偏移单位。这就表明，每个分片的长度也一定是 8 字节（ 64位 ）的整数倍。那为什么 ipv4 片偏移量以 8 字节位单位呢？如果直接用字节为单位，总长度是 16bit 而片偏移量只有 13 bit，就会出现不够描述的。 所以偏移量就按 8 字节为单位的来规定了。</p>
</li>
<li><p><strong>生存时间 8bit</strong> TTL( Time To Live ) 就是说 IP 数据报最大能经过多少个路由器跳转(每经过一个路由器，TTL减1)。<strong>防止数据报在网络中因为某些错误导致无限循环，浪费网络资源</strong>。那么可以知道，路由器在转发时会将这个字段的值减 1，并重新计算首部校验和。</p>
</li>
<li><p><strong>协议 8bit</strong> 标志此数据报携带的数据是使用协议类型( 例如TCP、UDP等 )，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。</p>
</li>
<li><p><strong>首部检验和</strong> <strong>16bit</strong> 注意这个字段只检验数据报的首部，不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（因为生存时间、标志、片偏移都可能发生变化，就是说在中间路由被重新分片时会出现变化。），不检验数据部分可减少计算量。</p>
</li>
<li><p><strong>源IP地址</strong>　占32位。</p>
</li>
<li><p><strong>目的IP地址</strong>　占32位。</p>
</li>
</ol>
<h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>​    我们自己电脑的IP地址有两种方式，第一种是直接设置一个固定的IP地址，需要配置一系列信息，比如子网掩码和DNS服务器地址等等；第二种是自动获取IP地址，这就是DHCP（动态主机配置协议）。通过本网络中的DHCP服务器发出请求，DHCP看看自己还有哪些IP地址没有分发出去，随机挑选一个给你用，返回给你的数据包中不仅包含了IP地址，还有子网掩码，默认网关地址以及DNS服务器地址。</p>
<p>​    DHCP的好处就是方便，以及节省资源，插上网线就能用，不用了之后，这个IP就给别人用。</p>
<h3 id="DHCP索要IP地址的流程"><a href="#DHCP索要IP地址的流程" class="headerlink" title="DHCP索要IP地址的流程"></a>DHCP索要IP地址的流程</h3><ol>
<li>想上网的设备要先在本网络中广播一个DHCP的报文，看谁回应，谁就就是DHCP服务器。这个过程称之为发现报文。</li>
<li>DHCP服务器在自己身体里找一个合适的IP地址，向全体广播提供一个<strong>提供报文</strong>。</li>
<li>上网的设备收到IP地址后会发一个请求报文，告诉DHCP服务器收到了IP地址。</li>
<li>随后DHCP服务器发送一个确认报文，并更新自己的数据库。</li>
</ol>
<p>​    这样做的原因是因为网络中可能有很多的DHCP服务器，这些服务器接收到了设备的DHCP报文，都会提供一个包含IP地址的报文，但是设备自己只能接收一个IP地址，所以要设备要发送一个请求报文来与告知其中某一个DHCP服务器“我用了你的IP”，这样这台DHCP服务器才会更新其数据库，其他的DHCP服务则会收回其分发的IP地址。</p>
<p>​    具体通信过程如下：</p>
<ol>
<li>DHCP服务其的默认端口是67</li>
<li>联网设备发送 DHCP 报文的默认端口是 68</li>
<li>发现报文：源 IP 0.0.0.0：68 目的 IP 255.255.255.255：67 双方都不知道彼此的 IP 地址 所以都是广播通信</li>
<li>提供报文：源 IP x.x.x.x：67 目的IP 255.255.255.255：67</li>
<li>下面就是再发一个请求报文和确认报文了</li>
</ol>
<h3 id="DHCP特点"><a href="#DHCP特点" class="headerlink" title="DHCP特点"></a>DHCP特点</h3><ol>
<li>在应用层实现，通过应用进程实现</li>
<li>使用 UDP</li>
<li>使用了 IP 广播</li>
</ol>
<h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>与 IP 息息相关。它的主要功能有差错报告和网络探测俩种。差错报告就是数据在网络中进行转发时，可能会出现一些错误，比如，数据报经过路由器时发现 TTL=0，那么路由器就会丢弃该报文，然后向发送端发送一个 ICMP 报文。而网络探测的功能，最常用的就是 ping 工具呢，这个 ping 工具基于的就是 ICMP 的回声请求应答报文，属于 ICMP 中的一种报文格式。具体的就不细说了。</p>
<h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol>
<li><a href="https://juejin.im/post/6844903518365564936#heading-11" target="_blank" rel="noopener">计算机网络知识解析</a></li>
<li><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">CS-NOTE</a></li>
</ol>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>计算机网络基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Reids和Memcached对比</title>
    <url>/2020/09/15/Reids%E5%92%8CMemcached/</url>
    <content><![CDATA[<h1 id="Reids和Memcached对比"><a href="#Reids和Memcached对比" class="headerlink" title="Reids和Memcached对比"></a>Reids和Memcached对比</h1><blockquote>
<p>本文简单介绍了Redis和Memcached的区别</p>
</blockquote>
<a id="more"></a>
<h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ol>
<li>数据类型<ul>
<li>Redis支持String、hash等5种类型</li>
<li>Memcached只支持hash</li>
</ul>
</li>
<li>单线程和多线程<ul>
<li>Redis是单线程请求，所有命令串行执行，并发情况下数据是一致的；但是性能受限于CPU，单实例的QPS在4-6w</li>
<li>Memcached是多线程，在单实例的情况下，可以达到写入60-80w qps，读80-100w</li>
</ul>
</li>
<li>持久化<ul>
<li>Redis支持持久化，使用AOF或者RDB</li>
<li>Memcached不支持持久化</li>
</ul>
</li>
<li>对热点、bigkey的支持<ul>
<li>QPS较高的情况下容易造成redis阻塞：单线程CPU饱和</li>
<li>memcached多线程，支持较好</li>
</ul>
</li>
<li>高可用/HA<ul>
<li>Redis哨兵模式master-slave，支持多级复制和增量复制</li>
<li>Memcached无法高可用</li>
</ul>
</li>
<li><b>发布订阅</b><ul>
<li>Redis支持pub/sub，可以用来订阅和通知</li>
<li>Memcached没有订阅</li>
</ul>
</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol>
<li>Memcached可以提供更高的QPS，在请求量巨大的时候可以使用Memcached</li>
<li>Memcached无法持久化且可用性不高，在承载巨大的并发请求时，应采用多活结构来提高可用性</li>
<li>可以一台服务器部署多个Memcached实例，减少单实例的压力</li>
<li>大部分情况应使用Redis，毕竟Redis可用性高，支持持久化</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Redis</tag>
        <tag>Memcached</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解:39,41,42</title>
    <url>/2020/06/27/LeetCode%E9%A2%98%E8%A7%A3-39-41-42/</url>
    <content><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><blockquote>
<p>第39题：<a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">组合总和(中等)</a></p>
<p>第41题：<a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">缺失的第一个正数(困难)</a></p>
<p>第42题：<a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水(困难)</a></p>
<p>补充：个人项的题解，没有图解，没有视频。</p>
</blockquote>
<a id="more"></a>
<hr>
<h1 id="第39题：组合总和"><a href="#第39题：组合总和" class="headerlink" title=" 第39题：组合总和 "></a><font color="red"> 第39题：组合总和 </font></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个无重复元素的数组<code>candidates</code> 和一个目标数<code>target</code> ，找出<code>candidates</code> 中所有可以使数字和为<code>target</code>的组合。<code>candidates</code> 中的数字可以无限制重复被选取。数组中所有元素都是正数，解集不能重复。</p>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这种题型，只有回溯这一种解法，涉及到回溯，所谓回溯，就是稍微有一点技巧的穷举法，穷举法一般意味着高空间利用率和时间利用率，因此只要涉及到回溯，就要考虑剪枝。其次，遇到无序数组，如果题目没有要求时间复杂度必须在O(n)，一般情况下都可以去排序，而本题在排序后可以达到剪枝的效果。</p>
<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(candidates, target, ans, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, </span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> target, </span></span></span><br><span class="line"><span class="function"><span class="params">                    List&lt;List&lt;Integer&gt;&gt; ans, </span></span></span><br><span class="line"><span class="function"><span class="params">                    Deque&lt;Integer&gt; path,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> begin)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt; candidates.length; i++)&#123;</span><br><span class="line">          <span class="comment">// 这一步是剪枝操作，很好理解</span></span><br><span class="line">            <span class="keyword">if</span>(candidates[i] &gt; target) <span class="keyword">return</span>;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates, target - candidates[i], ans, path, i);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="第41题：缺失的第一个正数"><a href="#第41题：缺失的第一个正数" class="headerlink" title=" 第41题：缺失的第一个正数 "></a><font color="red"> 第41题：缺失的第一个正数 </font></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p>
<blockquote>
<p>时间复杂度: $O(n)$</p>
<p>空间复杂度: $O(1)$</p>
</blockquote>
<h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: [1,2,0]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol>
<li>时间复杂度O(n)：只能进行遍历的操作</li>
<li>空间复杂度O(1)：所有操作必须是原地的</li>
</ol>
<p>这两点带来的局限性，导致了本题必须要抓住一个关键点：<strong>一个长度为n的数组nums，其序列中如果没有缺失的正数，则$nums[i] == i$</strong>，也就是说，如果在这个数组的<code>idx</code>位置其值不是<code>idx+1</code>，则这个位置的数就是缺失的。因此，这道题的解题思路就确定了：使数组<code>idx</code>位置的值可判断，不一定非要$nums[idx] == idx + 1$，也可以使<code>idx</code>位置的值为负(<a href="https://leetcode-cn.com/problems/first-missing-positive/solution/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/" target="_blank" rel="noopener">题解</a>) 。本题将$nums[idx] == idx +１$。</p>
<h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            exchange(nums, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i+<span class="number">1</span>) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 递归出口：位置上的值是正确的值，或者超出了范围</span></span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span> || num &gt; nums.length || nums[num - <span class="number">1</span>] == num) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[num - <span class="number">1</span>];</span><br><span class="line">            nums[num - <span class="number">1</span>] = num;</span><br><span class="line">            exchange(nums, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h1 id="第42题：接雨水"><a href="#第42题：接雨水" class="headerlink" title=" 第42题：接雨水 "></a><font color="red"> 第42题：接雨水 </font></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p>
<p><img src="/2020/06/27/LeetCode%E9%A2%98%E8%A7%A3-39-41-42/getRain.png" alt="接雨水示意图"></p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题比较难，我的第一反应特别蠢：从底向上一层层遍历，看每一层最多能接收多少雨水。这样的时间复杂度是$O(MN)$，LC直接通过不了。实际上这道题是有好的思路的，核心想法就是：<strong>确定每个<code>idx</code>位置上能装多少雨水。</strong>而每个<code>idx</code>上装雨水的量，取决于在这个位置左右两端最高的那堵墙，因此如果我们知道每个位置上左右两端的最高位置，则可以完成计算：$res = Math.min(leftMax[idx], rightMax[idx]) - height[idx]$</p>
<h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.length, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span> || len == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        rightMax[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            leftMax[i] = Math.max(leftMax[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 这一步有点技巧，确定右边最大的值需要从右到左遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            rightMax[i] = Math.max(rightMax[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            ans += Math.min(leftMax[i], rightMax[i]) - height[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul>
<li>时间复杂度：$O(n)$，只进行了遍历操作</li>
<li>空间复杂度：$O(n)$，保存了每个<code>idx</code>位置左右两端的最大值</li>
</ul>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>这道题其实还有更好的解法：<a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/" target="_blank" rel="noopener">双指针法</a>，空间复杂度降到了$O(1)$，这种方法特别巧妙，利用了从左到右和从右到左两种不同的状态来计算在<code>idx</code>位置上可以存的雨水。但是这种方法在面试时是很难想出来的，因此这里就不赘述了。</p>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Integer</title>
    <url>/2020/03/13/%E6%B5%85%E8%B0%88Integer/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本博客主要涉及以下几个内容：</p>
<ol>
<li>装箱与拆箱</li>
<li>装箱生成的Integer在哪里</li>
<li>案例</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h1><p>　　Java中有八种基本数据类型: byte, short, int, long, float, double, char, boolean。这八种基本数据类型对应着八个包装类，<strong>基本数据类型</strong>转换为<strong>包装类</strong>叫做装箱，反之叫做拆箱。</p>
<h2 id="为什么要进行装箱和拆箱？"><a href="#为什么要进行装箱和拆箱？" class="headerlink" title="为什么要进行装箱和拆箱？"></a>为什么要进行装箱和拆箱？</h2><p>　　Java中最主要有三类存储空间: 栈，堆，方法区。栈中存基本数据类型和堆中对象的引用；堆中一般存放运行时的动态数据，最主要有<code>new</code>出来的对象;方法区中存储的数据不是本文的重点，就不细说了，本文只涉及方法区中的常量池，常量池中存储的是常量。<br>　　基本数据类型因为经常被使用，所以为了提高效率，都放在栈中进行运算；但是栈中的数据并不具备持久性，对于Java中同样经常使用的容器，栈中的数据显然不具备放入容器中的资格，因此才有了装箱和拆箱的步骤。JDK5后，Java实现了自动装箱和拆箱。</p>
<h2 id="如何进行装箱和拆箱"><a href="#如何进行装箱和拆箱" class="headerlink" title="如何进行装箱和拆箱"></a>如何进行装箱和拆箱</h2><p>　　这里不放java反编译后的结果了，直接说结论。只给出<code>int</code>和<code>Integer</code>之间的转换。</p>
<ul>
<li>代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Integer in = <span class="number">9</span>; <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> i = in; <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure>
<ul>
<li>装箱调用：<code>Integer in = Integer.valueOf(9)</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>拆箱调用：<code>int i = in.intValue()</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="装箱生成的Integer去了哪里？"><a href="#装箱生成的Integer去了哪里？" class="headerlink" title="装箱生成的Integer去了哪里？"></a>装箱生成的Integer去了哪里？</h1><p>　　上面的源码引出了一个新的类<code>IntegerCache</code>, 这个类是<code>Integer</code>类的静态内部类，内部存在三个常量：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br></pre></td></tr></table></figure>
<p>　　常量<code>high</code>会在类中的静态代码块中被赋值为<code>127</code>，<code>cache[]</code>中存储了<code>value</code>为<code>-128 ~ 127</code>的<code>Integer</code>包装类。<br>　　由源码可知：当装箱的<code>int</code>值在<code>-128 ~ 127</code>中时，<code>Integer</code>会直接返回常量池中的对象，而这些对象，在<code>Integer</code>类加载的时候就被创建了，因此不会再开辟多余的空间。而当<code>int</code>的值超过范围，则会在堆中重新开辟<code>Integer</code>对象的空间。</p>
<h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">128</span>;</span><br><span class="line">Integer A = a;</span><br><span class="line">Integer AA = <span class="number">99</span>;</span><br><span class="line">Integer B = b;</span><br><span class="line">Integer BB = <span class="number">128</span>;</span><br><span class="line">System.out.println(AA == A); <span class="comment">// true</span></span><br><span class="line">System.out.println(BB == B); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>解释：</p>
<ol>
<li><code>A</code>和<code>AA</code>都指向常量池中的<code>Integer</code>对象</li>
<li><code>B</code>和<code>BB</code>都是在执行装箱操作后<code>new</code>出来的<code>Integer</code>对象，因此地址不同</li>
</ol>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>LeetCode题解(一):10, 15, 57, 59</title>
    <url>/2020/03/07/LeetCode%E9%A2%98%E8%A7%A3-%E4%B8%80-10-15-57-59/</url>
    <content><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><blockquote>
<p>第10题：正则表达式匹配(困难)<br>第15题：三数之和(中等)<br>第57题：和为s的连续正数序列(简单)<br>第59题：II.队列的最大值(中等)</p>
</blockquote>
<a id="more"></a>
<hr>
<h1 id="第10题：正则表达式匹配"><a href="#第10题：正则表达式匹配" class="headerlink" title="第10题：正则表达式匹配"></a><font color="red">第10题：正则表达式匹配</font></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 <code>&#39;.&#39;</code>和 <code>&#39;*&#39;</code>的正则表达式匹配。</p>
<blockquote>
<p><code>&#39;.&#39;</code>匹配任意单个字符<br><code>&#39;*&#39;</code>匹配零个或多个前面的那个元素</p>
</blockquote>
<h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul>
<li>s 可能为空，且只包含从 a-z 的小写字母</li>
<li>p 可能为空，且只包含从 a-z 的小写字母，以及字符<code>&#39;.&#39;</code>和 <code>&#39;*&#39;</code></li>
</ul>
<h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　见到字符串匹配，字符串操作的题，第一反应就是DP。而且DP数组中的下标如<code>i</code>一般都代表匹配字符串的<code>0: i - 1</code>或者<code>i: len - 1</code>。<br>　　很显然，这道题可以用DP求解，<code>dp[i][j]</code>表示<code>p[0: j-1]</code>可以和<code>s[0: i - 1]</code>匹配。</p>
<h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><ul>
<li><code>dp[0][0] = true</code>: 因为<code>null</code>匹配<code>null</code></li>
<li><code>dp[0&lt; i &lt;= slen][0] = false</code>: p为<code>null</code>， 无法匹配任何值</li>
<li><code>dp[0][0&lt; j＜= plen]</code>: 这个初始化稍微复杂一点，因为例如<code>a*</code>或者<code>a*b*</code>这种都是可以匹配<code>null</code>的，因此我们用一个循环来初始化这种状态。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)&#123;</span><br><span class="line">	<span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>　　这题最难的地方在状态转移方程的求解，即如何求得<code>dp[i][j]</code>？</p>
<ol>
<li>第一种情况: <code>s[i - 1] == p[j - 1] ||　ｐ[j - 1] == &#39;.&#39;</code>，此时<code>dp[i][j] = dp[i - 1][j - 1]</code></li>
<li>第二种情况: <code>p[j - 1] == &#39;*&#39;</code>，分别有两种可能需要考虑: <ul>
<li><code>s[i - 1] == p[j - 2] || p[j - 2] == &#39;.&#39;</code>，此时又有三种情况，只要一种成立即可:<ul>
<li><code>*</code> 匹配0次: <code>dp[i][j] = dp[i][j - 2]</code>, 因为匹配0次的话，<code>p[0: j]</code>的作用等同于<code>p[0: j - 2]</code></li>
<li><code>*</code> 匹配1次: <code>dp[i][j] = dp[i][j - 1]</code>, 这个很容易理解</li>
<li><code>*</code> 匹配多次: <code>dp[i][j] = dp[i - 1][j]</code>, 这是最难理解的，因为如果<code>*</code>匹配了多次，则s字符串增加一个与<code>p[j - 2]</code>相同的数并无影响</li>
</ul>
</li>
<li><code>s[i - 1] != p[j - 2] || p[j - 2] != &#39;.&#39;</code>，此时只可能有一种情况:<ul>
<li><code>*</code> 只能匹配0次: <code>dp[i][j] = dp[i][j - 2]</code></li>
</ul>
</li>
</ul>
</li>
<li>其他情况: <code>dp[i][j] = false</code></li>
</ol>
<h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slen = s.length(), plen = p.length();</span><br><span class="line">        <span class="comment">// dq[i][j] means p[0 : j] matches s[0 : i]</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[slen + <span class="number">1</span>][plen + <span class="number">1</span>]; </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= slen; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'.'</span>)</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p.charAt(j - <span class="number">2</span>) == <span class="string">'.'</span> || p.charAt(j - <span class="number">2</span>) == s.charAt(i - <span class="number">1</span>))&#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">2</span>] || dp[i][j - <span class="number">1</span>]; </span><br><span class="line">                    &#125;<span class="keyword">else</span> dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[slen][plen];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度: <script type="math/tex">O(MN)</script> </li>
<li>空间复杂度: <script type="math/tex">O(MN)</script></li>
</ul>
<h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>　　本题还可以用回溯法做，但是笔者特别讨厌用递归，虽然递归用起来很简洁，但是空间利用率实在是太感人了，计算起来也十分麻烦。笔者曾经用递归写过一个项目的方法，出现堆栈溢出问题的时候简直崩溃，因此立下flag：能不用递归就不用递归。因此回溯的算法就不写了。<br><strong>回溯法思路：</strong></p>
<ul>
<li>首字符匹配，且p的后一字符不是<code>*</code> : 匹配<code>(s.substring(1), p.substring(1))</code></li>
<li>首字符匹配，且p的后一字符是<code>*</code> : 匹配<code>(s, p.substring(2)) ||　(ｓ.substring(1), p)</code></li>
<li>首字符不匹配，且p的后一字符是<code>*</code> : 匹配<code>(s, p.substring(2))</code></li>
<li>递归出口:  <ul>
<li>首字符不匹配，且p的后一字符不是<code>*</code> : <code>return false</code></li>
<li>p为空: <code>return s为空</code></li>
<li>这里注意一下，s为空并不作为出口，而作为(首字符不匹配)的情况</li>
</ul>
</li>
</ul>
<h3 id="遇到过的问题"><a href="#遇到过的问题" class="headerlink" title="遇到过的问题"></a>遇到过的问题</h3><ul>
<li>将<code>*</code>看成了匹配零次或无数次任意字符，导致直接做错</li>
<li>匹配多次的方程没想出来</li>
</ul>
<hr>
<p>　</p>
<h1 id="第15题：三数之和"><a href="#第15题：三数之和" class="headerlink" title="第15题：三数之和"></a><font color="red">第15题：三数之和</font></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p>
<p><strong>注意:</strong> 答案中不可以包含重复的三元组。</p>
<h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　这道题最主要的就是要想到用双指针的方法去求解twoSum，想到了就很简单。写博客的时候不小心写上了，改名字有点费事，所以就贴个代码上去。暴力求解这种基本谁都能想到，但是如果用暴力去做算法题的话，就失去了做算法题的意义，不是吗？</p>
<h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// O(nlgn)</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// O(n^2)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[i], left = i+<span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">int</span> twoSum = nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(twoSum == target)&#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="keyword">while</span>(left + <span class="number">1</span> &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(right - <span class="number">1</span> &gt; i + <span class="number">1</span> &amp;&amp; nums[right] == nums[right-<span class="number">1</span>]) right--;</span><br><span class="line">                    left++;right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(twoSum &gt; target) right--;</span><br><span class="line">                <span class="keyword">else</span> left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度: <script type="math/tex">O(N^2)</script></li>
<li>空间复杂度: <script type="math/tex">O(1)</script></li>
</ul>
<hr>
<h1 id="第57题-和为s的连续正数序列"><a href="#第57题-和为s的连续正数序列" class="headerlink" title="第57题: 和为s的连续正数序列"></a><font color="red">第57题: 和为s的连续正数序列</font></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p>
<p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　这道题比较简单，采用滑动窗口法进行计算即可。笔者不擅长解答除了找规律外的数学问题，所以数学解法就不考虑了。数学解法固然巧妙，但是我为了找工作而刷题，就不需要整这些花里胡哨的了，只需要保证时间空间复杂度尽可能少一些就ok。</p>
<h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">2</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>) ans.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; right &lt;= target / <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (left + right) * (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++) temp[i - left] = i;</span><br><span class="line">                ans.add(temp);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) left++;</span><br><span class="line">            <span class="keyword">else</span> right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>[][]) ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>时间复杂度: <script type="math/tex">O(N)</script></li>
<li>空间复杂度: <script type="math/tex">O(N)</script>: 使用了一个数组来临时存储序列</li>
</ul>
<h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><p>　　这道题很简单，但是笔者一开始并没有想到用滑动窗口法去解决问题，我第一反应是先固定左端的数，然后用二分查找的算法去找右边的数。算法是没错的，时间复杂度<code>O(NlgN)</code>也算马马虎虎，但是死活提交不过。后来Debug才发现，原来是计算的<code>sum</code>越界了，<code>int</code>最大能取到<font color="brown">$ 2^{31} - 1 = 2147483647 = 0x7fffffff $</font>, 如果再加1，就会变最小负值，然后就一直是负数了，除非再加一次最大值。随便举个例子: 计算<code>1, 2, 3,..., 8000000</code>就越界了。</p>
<hr>
<h1 id="第59题：II-队列的最大值"><a href="#第59题：II-队列的最大值" class="headerlink" title="第59题：II.队列的最大值"></a><font color="red">第59题：II.队列的最大值</font></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p>
<p>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　这道题卡了我很久，原因是我忽略了<strong>均摊时间复杂度的含义</strong>: 进行N次操作，其每次操作的平均复杂度为O(1)。<br>　　要解决这道题有两个很重要的点: </p>
<ol>
<li>只要插入了一个最大值，在前面的值<code>pop_front</code>前，这个最大值就不会改变。</li>
<li>如何保证最大值被<code>pop</code>掉后，我们可以找到次大值？: 只需要将正常入队的序列进行某些操作后保存为一个<strong>非递增的辅助序列</strong>即可。<ul>
<li>解释：假设我们有序列<code>xAyBzC</code>，其中<code>A &gt; x; B &gt; y; C &gt; z; A &gt; B &gt; C</code>，那么辅助序列<code>ABC</code>就是在进行<code>max_value()</code>操作中只可能出现的三个最大值，因为有了<code>A</code>，前面的<code>x</code>就失去了价值，而<code>A</code>一旦被<code>pop</code>后，<code>A</code>前面的数就不会在序列里了，子序列<code>yBzC</code>中最大的就是<code>B</code>，以此类推。因此这是一个线性问题。</li>
</ul>
</li>
</ol>
<h2 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; aux;</span><br><span class="line">    Deque&lt;Integer&gt; dq;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aux = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.dq = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aux.size() == <span class="number">0</span> ? -<span class="number">1</span> : aux.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        dq.addLast(value);</span><br><span class="line">        <span class="keyword">while</span>(aux.peekLast() != <span class="keyword">null</span> &amp;&amp; aux.peekLast() &lt; value) aux.pollLast();</span><br><span class="line">        aux.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dq.size() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Integer 没进入常量池，不能用 == 来判断</span></span><br><span class="line">        <span class="keyword">if</span>(dq.peek().equals(aux.peek())) aux.pollFirst();</span><br><span class="line">        <span class="keyword">return</span> dq.pollFirst();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="踩过的坑-1"><a href="#踩过的坑-1" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><ol>
<li>没理解均摊复杂度</li>
<li>没想到用非递增的辅助序列</li>
<li>两个没有拆箱的<code>Integer</code>对象，不能用<code>==</code>来判断其<code>value</code>是否相等。(基于这点，笔者想要写一篇文章来详细解析一下这种包装类，届时会放链接)</li>
</ol>
]]></content>
      <categories>
        <category>算法题</category>
      </categories>
      <tags>
        <tag>面试题</tag>
        <tag>算法题</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Java中的HashMap以及红黑树</title>
    <url>/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本篇博客涉及以下几个内容：</p>
<ol>
<li>HashMap的部分源码讲解</li>
<li>红黑树的数据结构</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="HashMap的结构和源码"><a href="#HashMap的结构和源码" class="headerlink" title="HashMap的结构和源码"></a>HashMap的结构和源码</h1><p>　Java中集合一共可以分为两类，一类是Collection，代表是ArrayList；一类是Map，代表是HashMap。而HashMap存储结构是<strong>哈希表</strong>。</p>
<h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>　哈希表的本质是一个数组，但是性能比数组高很多，因为动态数组的插入和删除操作对应的时间复杂度是O(n)，而哈希表的增删改查操作时间复杂度均为O(1)。<br>　为什么快？<br>　哈希表利用函数映射的方式来将数据映射到其维护的数组上，这样执行增删改查操作时只需要通过这个函数就能找到数组的下标，从而实现快速定位。相比数组的顺序存储，哈希表是无序的，因此在执行删除操作时，并不需要移动其他下标的元素。<strong>用来执行元素映射的函数叫做哈希函数：hashcode()。</strong><br>　存储方式如下图：<br>  <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/hashtable.png" alt="哈希表"></p>
<h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>　由上述的存储方式可知，<strong>如果两个不同元素通过哈希函数的值相同，则单纯用数组存储就会有冲突。</strong>这种方法最直接的解决办法就是设计优秀的哈希函数，把冲突的可能性降至最低，但是再优秀的哈希函数，都会有可能发生冲突。因此，需要有一种方法来解决冲突问题。<br>　常见的方法有：</p>
<ol>
<li>线性探测法，发生冲突后顺序找下一块空的地址。（运气差的话增删改查都会变O(n)）</li>
<li>对冲突的地址使用另一个Hash函数</li>
<li>链地址法：数组的每个位置都存一个链表。（运气差的话，查找会变O(n)）</li>
</ol>
<p>　HashMap解决冲突的办法就是<strong>链地址法</strong>，数组的每个位置我们称之为桶。如果运气不好的话，所有的数字都在一个桶里，那么查找一个链表的时间复杂度是O(n)，这很低效。<strong>所以JDK8之后，当一个桶里存放的元素超过8个时，则这个桶里会自动变成红黑树，这样查找的效率就成了O(logn)。</strong></p>
<h2 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h2><h3 id="HashMap主干数组"><a href="#HashMap主干数组" class="headerlink" title="HashMap主干数组"></a>HashMap主干数组</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//下面是HashMap内部维护的一个数组，这个数组初始值为空，主干长度是2的次幂</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure>
<p><code>Node&lt;K,V&gt;</code>是HashMap的一个静态内部类(<strong>使用静态内部类是为了方便继承，TreeNode就继承了这个Node类</strong>)，源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Map.Entry是一个接口</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//此Node的hash值</span></span><br><span class="line">       <span class="keyword">final</span> K key; <span class="comment">// 此Node的key</span></span><br><span class="line">       V value; <span class="comment">// 此Node的value</span></span><br><span class="line">       Node&lt;K,V&gt; next; <span class="comment">//指向下一个Node</span></span><br><span class="line">       </span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line"> <span class="comment">/* ------- 以上是重点 ---------*/</span>      </span><br><span class="line"> 	<span class="comment">// get,set,toString,hashcode,equels</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>　其存储结构如下图：<br><img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/hashmapNode.png" alt="Node存储结构"></p>
<p>　当数组中某个桶存储的元素超过一定的数量后(默认是8个)，则Node会被转化为TreeNode进行存储，TreeNode继承自<code>LinkedHashMap.Entry&lt;K,V&gt;</code>，关于<code>LinkedHashMap</code>可以移步我的博客：<a href>浅谈Java中LinkedHashMap</a>，<code>TreeNode</code>的解析将在下文的红黑树种讲解。</p>
<h3 id="几个重要字段"><a href="#几个重要字段" class="headerlink" title="几个重要字段"></a>几个重要字段</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认字段值：</span></span><br><span class="line"><span class="comment">//1.数组的默认初始容量是16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//2.数组的最大容量为2的30次方(int最大是 2^31-1)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//3.当数组中存储的值超过目前容量的75%，执行数组的扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//4.当数组中一个桶存储的元素超过8个时，list将会转化为tree</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//5.红黑树的最小容量为64</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//6.执行扩容操作时会将小于元素小于6的数还原</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重要字段：</span></span><br><span class="line"><span class="comment">//1.HashMap中实际存储的'key-value'数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//2.数组负载因子，默认是75%</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//3.数组存储阈值，如果key-value的数量大于该阈值，则进行数组扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">/** 4.被修改次数，由于HashMap线程不安全，如果对HashMap进行迭代的时候，其他线程改变了HashMap的结构(增、删、改)，则就会抛出ConcurrentModificationException异常 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure>
<h3 id="HashMap构造器"><a href="#HashMap构造器" class="headerlink" title="HashMap构造器"></a>HashMap构造器</h3><p>　HashMap一共四种初始化的方式</p>
<ul>
<li>我们最常用的构造器是无参构造器：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个构造器不初始化table，为table分配空间会在内部的resize()函数中进行，下文会讲。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>HashMap也可以指定容量和负载因子进行初始化</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span>+</span><br><span class="line">                                               loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//此步将initalCapacity规范成2的次幂</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>剩余两种构造器比较容易</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这个不讲了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过一个Map实例化HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">//相当于一个拷贝工作，这个false我目前不是很理解，如果为true的话，在内部会执行afterNodeInserction函数，但是我看这个函数是空的，所以不是很理解。</span></span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="put函数"><a href="#put函数" class="headerlink" title="put函数"></a>put函数</h3><p>　上面我们看到，如果使用缺省的构造器，我们是不会初始化table的，而真正初始化table需要等到我们第一次使用put操作。这是一种懒加载的机制，用来节约内存资源。<br>　以下是源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*定义一个数组tab，一个链表p表示桶里的链表情况，n表示数组长度，i表示key在数组中的索引*/</span></span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">      <span class="comment">/*如果table没有初始化，则resize()，下文会讲*/</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line">      <span class="comment">/*如果key所在桶里为空，则为这个key-value新建一个Node存放*/</span></span><br><span class="line">      <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">      	<span class="comment">/*如果桶里不为空，则新建一个节点e用来寻找新插入或者修改的Node的位置*/</span></span><br><span class="line">          Node&lt;K,V&gt; e; K k;</span><br><span class="line">          <span class="comment">/*如果key相等，则不插入新节点，e指向要修改val的位置*/</span></span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              e = p;</span><br><span class="line">          <span class="comment">/*如果桶里是红黑树，则执行红黑树的插入操作*/</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">              e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">          	<span class="comment">/*若桶里只是链表，则遍历这个链表*/</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">              	<span class="comment">/*在表尾插入新的节点*/</span></span><br><span class="line">                  <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                      <span class="comment">/*如果链表的长度大于阈值，将链表转换成红黑树*/</span></span><br><span class="line">                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                          treeifyBin(tab, hash);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">/*若在遍历链表时，发现有Node的key与插入的key相等，则退出遍历*/</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  <span class="comment">/*p指向的Node沿着链表一直向后*/</span></span><br><span class="line">                  p = e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/*如果e不为null，则e指向要修改val的Node*/</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">              V oldValue = e.value;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                  e.value = value;</span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*新插入节点后增加HashMap的修改次数，*/</span></span><br><span class="line">      ++modCount;</span><br><span class="line">      <span class="comment">/*key-value的数量大于阈值后对数组进行扩容*/</span></span><br><span class="line">      <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">          resize();</span><br><span class="line">      afterNodeInsertion(evict);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>　我看了一下网上的流程图都不是很准确，我这里用文字表示一下，最近实在是太累了，等我写LinkedHashMap的时候把图补上。<br>　<strong>HashMap中put的流程如下：</strong></p>
<ol>
<li>判断table是否为空，为空则进行resize()初始化table</li>
<li>计算插入的Key的在table中的索引i</li>
<li>若table[i]中没有值，则新建一个Node插入该位置</li>
<li>若有值，则判断插入的key是否与table[i]中首节点的key相等，若相等则直接替换val</li>
<li>若key不等，则判断table[i]存放的是否为红黑树，若为红黑树，则进行红黑树的插入操作<ol>
<li>红黑树中也会进行key值的比较，若相等则直接修改val，若不等则插入新节点</li>
</ol>
</li>
<li>若table[i]中存放的是链表，则遍历链表<ol>
<li>若遍历过程中发现有key相等，则直接替换</li>
<li>若遍历到链表的结尾，则在结尾插入新的Node<ol>
<li>若此时table[i]内存放的元素大于8，则将链表转化成红黑树，并对红黑树进行扩容</li>
</ol>
</li>
</ol>
</li>
<li>插入成功后，若数组中存放的key-value数值大于数组阈值后，则进行resize()扩容操作。</li>
</ol>
<h3 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h3><p>　有put就有get，这是HashMap最常用的两个函数，其主要的难点在于红黑树的查找，这在下文会讲。<br>　以下是源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt; e;</span><br><span class="line">     <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">/*定义数组，链表和待查找的节点，n表示数组的长度，k表示遍历节点的key*/</span></span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">     <span class="comment">/*若不满足查找条件比如数组不存在，桶里没值，返回null*/</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">/*检查第一个节点，若想等则返回*/</span></span><br><span class="line">         <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">             ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             <span class="keyword">return</span> first;</span><br><span class="line">         <span class="comment">/*若不等，则看其下一个有没有值，没有则返回null，TreeNode继承的爷爷辈是Node，因此可以调用父类对象的next，即使其已经是TreeNode了*/</span></span><br><span class="line">         <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         	<span class="comment">/*若有值则寻找，红黑树查找或列表遍历*/</span></span><br><span class="line">             <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                 <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">return</span> e;</span><br><span class="line">             &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h3><p>　最后一项删操作，如果增和查的操作都了解的话，删操作也就通俗易懂。其大体的思路就是：查到需要删除的节点，然后执行红黑树的删除或者链表的删除。<br>　源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.remove and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to match if matchValue, else ignored</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue if true only remove if value is equal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*定义一个数组，一个链表，n表示数组的长度，index表示要删除的数组索引位置*/</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">/*table为空或者桶内没有数据，无法执行删除，返回null*/</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*找到要删除的节点，用node指向它*/</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*删除node*/</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="resize函数"><a href="#resize函数" class="headerlink" title="resize函数"></a>resize函数</h3><p>　在我们进行HashMap操作的时候会经常会有扩容的需求，因此了解扩容的机制十分重要。<br>　源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*此方法不能被重写*/</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">   	<span class="comment">/*保存旧的table，并保存旧的阈值和容量*/</span></span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">/*若超过最大容量，则将阈值设置成2^31-1*/</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">/*若当前容量在最小值和最大值之间，则把新容量和新阈值扩大一倍*/</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*若阈值不为0，但数组容量为0，将容量扩展成阈值大小*/</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="comment">/*第一次初始化table，设置容量为16，阈值为16*0.75*/</span></span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*通过新容量设置新阈值，如果新容量比最大容量小，则为'新容量*负载因子' */</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="comment">/*执行扩容，对里面每个元素进行重新排放*/</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h1 id="红黑树讲解"><a href="#红黑树讲解" class="headerlink" title="红黑树讲解"></a>红黑树讲解</h1><p>　JDK8之后，HashMap引入了红黑树，红黑树是一种自平衡二叉查找树。本节将通过数据《算法》和HashMap的部分源码来解析红黑树的结构。</p>
<h2 id="2-3平衡树"><a href="#2-3平衡树" class="headerlink" title="2-3平衡树"></a>2-3平衡树</h2><p>　理解红黑树的平衡是一件比较抽象的事情，很多博客并不讲红黑树是如何实现平衡的。本文通过2-3平衡树来讲解一下”平衡”的概念。</p>
<h3 id="完美平衡"><a href="#完美平衡" class="headerlink" title="完美平衡"></a>完美平衡</h3><p>　完美平衡是指，所有空结点到根结点的的距离相等，比如下图就是一个完美平衡的二叉树:<br><img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/BinaryTree.png" alt="完美平衡树"><br>　很明显可以看出来，如果一颗普通的二叉树要达到完美平衡，其对于结点的数量是有要求的: $ n  = 2^{k} - 1  $ , 如果结点数量不满足这个等式, 那么一颗二叉树始终不可能是平衡的。<br>　<font color="red"><strong>那么如何使一棵树不管有几个结点都能保持平衡呢?</strong></font><br>　这里设想一下, 左右子树在最理想的情况下高度差是多少? 答案很明显是1, 因为任意数都可以在$ 2^{k} $和$ 2^{k+1} $之间。因此如果我们把高的子树的高度减一, 那么这棵树就实现了完美平衡。</p>
<h3 id="2-3树的基本结构"><a href="#2-3树的基本结构" class="headerlink" title="2-3树的基本结构"></a>2-3树的基本结构</h3><p>　如何实现高度减一呢? 有一个特别简单的办法, 那就是新定义一个结点:3-结点。我们将普通二叉树的结点定义为：2-结点。2-结点存储一个key，并且有左右两个子树; 3-结点存储两个key, 并且有左中右三个子树。2-3树就是由2-结点和3-结点组成的树, 二叉树也是2-3树的一种。下面是一个2-3树示例:<br><img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/2-3Tree.png" alt="2-3平衡树"></p>
<h3 id="实现完美平衡"><a href="#实现完美平衡" class="headerlink" title="实现完美平衡"></a>实现完美平衡</h3><p>　2-3树可以始终保持完美平衡, 因为在2-3树中插入新值不会破坏其平衡性, 下面我们仔细讲一讲如何实现2-3树的插入操作。<br>　一个树在第一次生成的时候一定是平衡的, 因为只有一个2-结点, 当我们在一个平衡的树的底部插入新结点的时候会破坏其平衡性。因此, 我们在讲解2-3树的插入操作前, 必须有一个前提: <strong>2-3树在插入前是平衡的</strong>。<br>　当我们插入一个新结点时，会遇到以下的几种情况: </p>
<ul>
<li>在一个2-结点的底部插入新键: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/insert1.png" alt="2-结点插入"></li>
<li>在一个没有父节点的3-结点底部插入新键: 临时构建一个4-结点。<img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/insert2.png" alt="3-结点插入"></li>
<li>在一个父节点是2-结点的3-结点底部插入新键: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/insert3.png" alt="3-结点插入2"></li>
<li>在一个父节点是3-结点的3-结点底部插入新键: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/insert4.png" alt="3-结点插入3"> </li>
</ul>
<p>　可以看到, 2-3树之所以能保持平衡性, 是因为其在插入的过程中, 不会在底部增加高度, 而是自下而上去寻找一个2-结点能够吸收这个高度变化, 如果没有寻找到这个2-结点, 则会通过把遇到的3-结点创建为临时4-结点并分解的方式使左右子树的高度均增加1, 以保证树的平衡。(这里稍微再说一下, 如果这个3-结点不是根结点, 则增加的高度也不会破坏其平衡性, 因为分解4-结点的操作会在顶部生成一个2-结点, 而这个增加的2-结点相当于对3-结点的父结点进行一次插入操作)</p>
<h3 id="查找和插入操作的复杂度"><a href="#查找和插入操作的复杂度" class="headerlink" title="查找和插入操作的复杂度"></a>查找和插入操作的复杂度</h3><p>　要理解2-3树的操作复杂度, 需要知道树的高度。因为其平衡特性, 2-3树的高度在 $ log_{2}N $ (全是2-结点)和$ log_{3}N $ (全是3-结点)之间。因此, 其查找的复杂度在 $ O(logN) $; 其插入操作需要先查找, 然后进行结点的变换。单个结点变换的复杂度为$ O(1) $, 平均要进行$logN$次变换(最少变换一次: 父结点是2-结点; 最坏变换树的高度: 一路上去全是3-结点, 最后到根结点), 因此插入的复杂度是: $O(logN)+O(logN) = O(logN)$。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>　理解了2-3平衡树后, 红黑树就好理解了。 红黑二叉树的基本思想是用标准的二叉树(全是2-结点)以及一些额外的信息(替换3-结点)来表示2-3平衡树。这个额外的信息是: 红链接将两个2-结点组成一个3-结点, 黑链接表示2-3树的普通链接。红链接指向的结点我们会标记为红色结点。关于一个3-结点和红链接的表示如下图： <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/RBTree.png" alt="红黑树结点"> </p>
<h3 id="等价定义"><a href="#等价定义" class="headerlink" title="等价定义"></a>等价定义</h3><p>　红黑树可以说是2-3树的变种, 任意的2-3树都能转换成红黑树, 我们可以用一种等价的定义来描述红黑树(和网络上一般讲解的不太一样, 但是都是对的): 红黑树是满足下列条件的二叉查找树:</p>
<ul>
<li>红链接均为左链接(即所有的红色结点都是左结点, 根结点必然是黑色);</li>
<li>没有任何一个结点同时与两条红链接相连;</li>
<li>该树是完美黑色平衡的</li>
</ul>
<p>　满足上述定义的红黑树与相应的2-3树必然是一一对应的。完美黑色平衡是非常直观的，因为红结点不能单独作为2-结点，我们把红链接放平，就是一颗完美平衡的2-3树, 下面是一个简单的示例: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/RedFlat.png" alt="红黑树结点"> </p>
<h3 id="简单的红黑树结点"><a href="#简单的红黑树结点" class="headerlink" title="简单的红黑树结点"></a>简单的红黑树结点</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">	Key key;</span><br><span class="line">	Value val;</span><br><span class="line">	TreeNode left, right; <span class="comment">// 只有左子树和右子树, HashMap中有所不同, 下面再讲</span></span><br><span class="line">	<span class="keyword">int</span> N; <span class="comment">//这颗子树中的结点总数</span></span><br><span class="line">	<span class="keyword">boolean</span> color; <span class="comment">// 表示从父结点指向它的链接的颜色</span></span><br><span class="line">	</span><br><span class="line">	TreeNode(Key key, Value val, <span class="keyword">int</span> N, <span class="keyword">boolean</span> color)&#123;</span><br><span class="line">		<span class="keyword">this</span>.key = key;</span><br><span class="line">		<span class="keyword">this</span>.val = val;</span><br><span class="line">		<span class="keyword">this</span>.N = N;</span><br><span class="line">		<span class="keyword">this</span>.color = color;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>下面是几个需要用到的简单函数:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(TreeNode x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">return</span> x.color == RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(TreeNode x)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> x.N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="旋转和颜色变换"><a href="#旋转和颜色变换" class="headerlink" title="旋转和颜色变换"></a>旋转和颜色变换</h3><p>　进行插入的过程中可能会破坏上述性质:  出现红色右链接和两条连续的红链接。这些情况可以通过简单的旋转和颜色变换进行修复。其中旋转是一次进行链接变换的简单操作。</p>
<ul>
<li>左旋转: 把一条右红链接转换为左链接, 如图: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/rotateLeft.png" alt="红黑树结点"> </li>
<li>右旋转: 把一条左红链接转换为右链接, 如图: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/rotateRight.png" alt="红黑树结点"> </li>
<li>颜色变换: 当左右链接均为红色, 则把两条链接都变黑, 并把根结点变红, 如图: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/flipColor.png" alt="红黑树结点"></li>
</ul>
<p>　我们可以利用旋转操作帮我们保证红黑树和2-3树的一一对应, 因此我们无需担心树的平衡性。</p>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul>
<li>左旋转</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">rotateLeft</span><span class="params">(TreeNode h)</span></span>&#123;</span><br><span class="line">	TreeNode x = h.right;</span><br><span class="line">	h.right = x.right;</span><br><span class="line">	x.left = h;</span><br><span class="line">	x.color = h.color;</span><br><span class="line">	h.color = RED;</span><br><span class="line">	x.N = h.N;</span><br><span class="line">	h.N = <span class="number">1</span> + size(h.left) +size(h.right);</span><br><span class="line">	retrurn x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>右旋转</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">rotateRight</span><span class="params">(TreeNode h)</span></span>&#123;</span><br><span class="line">	TreeNode x = h.left;</span><br><span class="line">	h.left = x.right;</span><br><span class="line">	x.right = h;</span><br><span class="line">	x.color = h.color;</span><br><span class="line">	h.color = RED;</span><br><span class="line">	x.N = h.N;</span><br><span class="line">	h.N = <span class="number">1</span> + size(h.left) + size(h.right);</span><br><span class="line">	<span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>颜色变换</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">filpColors</span><span class="params">(TreeNode h)</span></span>&#123;</span><br><span class="line">	h.left.color = BLACK;</span><br><span class="line">	h.right.color = BLACK;</span><br><span class="line">	h.color = RED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Java内部类</title>
    <url>/2019/12/15/%E6%B5%85%E8%B0%88Java%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本篇博客主要涉及以下几个内容</p>
<ol>
<li>Java中的内部类</li>
<li>Java中的静态内部类</li>
<li>关于内部类常见的一些面试题</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="Java中的内部类"><a href="#Java中的内部类" class="headerlink" title="Java中的内部类"></a>Java中的内部类</h1><p>内部类就是在Java类内部定义的类，主要分为四种类型：</p>
<ol>
<li>成员内部类</li>
<li>静态内部类</li>
<li>局部内部类</li>
<li>匿名内部类</li>
</ol>
<h2 id="使用内部类的原因"><a href="#使用内部类的原因" class="headerlink" title="使用内部类的原因"></a>使用内部类的原因</h2><ol>
<li>Java拥有单继承的特性，而内部类可以独立继承一个类或实现接口。这一定程度上方便了开发。</li>
<li>内部类的信息与其他外围类信息独立，提供了更好的封装</li>
</ol>
<h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>作为外部类的成员变量存在，其性质如下：</p>
<ol>
<li>可以有访问修饰符</li>
<li>外部类在类中访问内部类需要通过new的方式</li>
<li>外部类加载，成员内部类不加载</li>
<li>不能有静态信息【因为如果外部类没有实例化，则内部类不会被加载(不符合类加载的几种条件)，因此静态变量不会进内存，这与static的概念矛盾了】</li>
<li>内部类的this关键字表示自己的对象，如要访问外部类的对象则使用<code>外部类名.this</code></li>
<li>在外部类外访问内部类需要使用<code>外部类的实例引用.new 内部类构造函数</code></li>
</ol>
<ul>
<li>以下demo体现了这些特性：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOuterInnerClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//访问内部类</span></span><br><span class="line">        <span class="comment">//1. 先要有外部类的应引用</span></span><br><span class="line">        OuterInnerClass outer = <span class="keyword">new</span> OuterInnerClass();</span><br><span class="line">        <span class="comment">//2. 通过该引用创建外部类</span></span><br><span class="line">        OuterInnerClass.InnerClass inner = outer.<span class="keyword">new</span> InnerClass();</span><br><span class="line">        <span class="comment">//3. 也可以通过自定义的方法创建</span></span><br><span class="line">        <span class="comment">//inner = outer.creatInner();</span></span><br><span class="line">        <span class="comment">//4.直接使用内部类</span></span><br><span class="line">        inner.print();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         输出结果如下：</span></span><br><span class="line"><span class="comment">         1. Outer Constructor..</span></span><br><span class="line"><span class="comment">         2. Inner Constructor</span></span><br><span class="line"><span class="comment">         3. Outer's val:10</span></span><br><span class="line"><span class="comment">         4. Inner's val:5</span></span><br><span class="line"><span class="comment">         5. outerPrint..</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterInnerClass</span> /*<span class="keyword">extends</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">IA</span>*/</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Outer Constructor.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">outerPrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"outerPrint.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> /*<span class="keyword">extends</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">IB</span>*/</span>&#123;</span><br><span class="line">    	<span class="comment">//内部类变量有重名</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> val = <span class="number">5</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Inner Constructor"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//外部类和内部类的成员变量重名如何区分？</span></span><br><span class="line">            System.out.println(<span class="string">"Outer's val:"</span> + OuterInnerClass.<span class="keyword">this</span>.val);</span><br><span class="line">            System.out.println(<span class="string">"Inner's val:"</span> + <span class="keyword">this</span>.val);</span><br><span class="line">            <span class="comment">//可以直接访问外部类的成员变量和方法</span></span><br><span class="line">            outerPrint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">creatInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 外部类中访问内部类通过new的方式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类的性质如下：</p>
<ol>
<li>可以有访问修饰符</li>
<li>静态内部类不依赖于外部类。因此外部类被加载，内部类不会被加载；而内部类被加载，外部类也不会被加载<ol>
<li>内部类创建：<code>Outer.Inner inner = new Outer.Inner()</code></li>
<li>访问内部类的静态成员：<code>Outer.Inner.staticValue</code></li>
</ol>
</li>
<li>静态内部类<strong>只可以关联外部类的静态资源</strong>（因为内部类被加载时，关联外部类的静态资源会使外部类加载，但是不能拥有外部类的实例）</li>
<li>与成员内部类的区别<ol>
<li>不需要依赖于外部类的实例创建</li>
<li>只能关联外部类静态资源</li>
<li>不存在this关键字</li>
</ol>
</li>
</ol>
<ul>
<li>以下demo可以体现以上性质：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticOuterInner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成静态内部类的实例</span></span><br><span class="line">        Outer.Inner inner = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">        <span class="comment">//类外访问静态内部类的静态资源</span></span><br><span class="line">        Outer.Inner.innerStaticMethod();</span><br><span class="line">        <span class="comment">//调用内部类的方法</span></span><br><span class="line">        inner.innerMethod();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         输出为：</span></span><br><span class="line"><span class="comment">         1. inner static block...</span></span><br><span class="line"><span class="comment">         2. Inner constructor...</span></span><br><span class="line"><span class="comment">         3. innerStaticMethod...</span></span><br><span class="line"><span class="comment">         4. Outer static block...</span></span><br><span class="line"><span class="comment">         5. Outer static value:10</span></span><br><span class="line"><span class="comment">         6. innerMethod...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Outer static block..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Outer constructor..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"inner static block..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">innerStaticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"innerStaticMethod..."</span>);</span><br><span class="line">            <span class="comment">//可以访问外部类的静态变量</span></span><br><span class="line">            System.out.println(<span class="string">"Outer static value:"</span> + a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Inner constructor..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"innerMethod..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outStaticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//类中访问静态内部类</span></span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>输出解释：</li>
</ul>
<ol>
<li>首先创建静态内部类的实例，先加载内部类执行静态代码块，随后执行构造方法。由静态内部类的性质可知，加载静态内部类，外部类是不加载的。</li>
<li>随后执行静态内部类的静态方法，此方法关联了外部类的静态变量，因此外部类被加载，但没有实例化。</li>
<li>最后执行了静态内部类实例的方法。可见在整个流程中，外部类只是加载了，并没有实例化。</li>
</ol>
<h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>在一个方法内定义的类，有如下性质：</p>
<ol>
<li>没有访问权限修饰符</li>
<li>仅在方法内有效</li>
<li>无法创造静态信息，因为这个类是临时的</li>
<li>可以访问外部类的所有信息（方法内部本身就是可以访问的）</li>
<li>可以访问方法的参数和局部变量（但是这些变量始终不能被改变）</li>
</ol>
<h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>常用来重写某个或某些方法，这个用的还是比较多的，比较常见的就是Java的动态代理实现，会实现一个匿名内部类并重写invoke()方法。</p>
<ul>
<li>使用动态代理的Demo</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnonInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IPerson person = PersonProxy.getPerson();</span><br><span class="line">        person.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     输出结果：</span></span><br><span class="line"><span class="comment">     1. 做饭...</span></span><br><span class="line"><span class="comment">     2. 吃饭...</span></span><br><span class="line"><span class="comment">     3. 洗碗...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">IPerson</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃饭..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> IPerson person = <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPerson <span class="title">getPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用匿名内部类InvocationHandler，重写invoke方法，对Person接口的所有方法进行增强</span></span><br><span class="line">        <span class="keyword">return</span> (IPerson) Proxy.newProxyInstance(person.getClass().getClassLoader()</span><br><span class="line">                , person.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object obj = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            System.out.println(<span class="string">"做饭..."</span>);</span><br><span class="line">                            obj = method.invoke(person);</span><br><span class="line">                            <span class="keyword">return</span> obj;</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                            System.out.println(<span class="string">"饭馊了..."</span>);</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没吃上饭:"</span> + e);</span><br><span class="line">                        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                            System.out.println(<span class="string">"洗碗..."</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL事务与隔离级别</title>
    <url>/2019/12/15/MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<ol>
<li>事务的特性</li>
<li>MySQL隔离级别</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>进行数据库的操作离不开事务，事务也是各大厂招聘的必问环节。</p>
<h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>ACID是事务的基本特性，也是事务这个概念成立的基础。</p>
<ul>
<li>Atomic（原子性）：表示一个事务中的所有操作，要么全部成功，要么全部失败回滚。</li>
<li>Consistance（一致性）：事务执行前后，数据库的数据要保持一致，逻辑上的一致。（这个实现必须要依赖于其他三个特性）<ul>
<li>只有满足一致性，事务才有意义，事务的提交才是正确的。</li>
</ul>
</li>
<li>Isolation（隔离性）：并发情况下，多用户开启的事务相互之间不能受影响。</li>
<li>Duration（持久性）：事务的提交是持久性的，会永久改变数据库。</li>
</ul>
<p>原子性、一致性和持久性比较容易理解，主要是隔离性的满足需要深入探讨。</p>
<p>隔离性主要是为了满足高并发情况下事务的隔离问题，因此先明确一下常见的隔离问题。</p>
<h2 id="事务的隔离问题"><a href="#事务的隔离问题" class="headerlink" title="事务的隔离问题"></a>事务的隔离问题</h2><ol>
<li>脏读：一个事务读到了另一个事务未提交的内容。</li>
<li>不可重复读：A事务中，多次读同一条数据，读到的数据不一致（可能是B事务提交了对这条数据的修改）。</li>
<li>幻读：A事务的两次读取中，读到了未出现过的数据行（可能是B事务插入了这条数据）。</li>
<li>丢失修改：A事务和B事务同时对一条数据进行了修改，B事务的提交覆盖了A事务的提交。</li>
</ol>
<p>在事务的隔离问题中，其中丢失修改是“写”的问题，而其余是“读”的问题。</p>
<p><font color="red">事务的隔离级别不是用来解决“写”的问题而存在的</font>，也因此我们将“丢失修改”的问题单独拿出来说。</p>
<h2 id="解决丢失修改的问题"><a href="#解决丢失修改的问题" class="headerlink" title="解决丢失修改的问题"></a>解决丢失修改的问题</h2><p>两种策略：</p>
<ul>
<li>悲观策略：事务A对于某项数据进行修改时，在数据上加上排它锁。</li>
<li>乐观策略：数据表上加上<code>version</code>字段，每次修改数据都要检验一下<code>version</code>是否正确，不正确就回滚。</li>
</ul>
<h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>在讲事务的隔离级别时，MVCC的概念必须要了解。MVCC是Innodb引擎实现隔离级别的一种具体方式，MVCC通俗点讲就是：给数据一个快照。这与CopyOnWrite的思想类似。这里有三个概念：</p>
<ul>
<li>一个事务只能读取<strong>已经提交</strong>的快照</li>
<li>当前事务能够读到自身未提交的快照</li>
<li>数据的读不更新快照，数据的写更新快照</li>
</ul>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>使用MVCC之后，所有的select操作都不会加锁，而是用快照读的方式。</p>
<h4 id="版本号：快照是基于版本号的"><a href="#版本号：快照是基于版本号的" class="headerlink" title="版本号：快照是基于版本号的"></a>版本号：快照是基于版本号的</h4><ul>
<li>系统版本号<code>sys_id</code>：每开启一个事务，版本号都会递增</li>
<li>事务版本号<code>trx_id</code>：事务开启前的当前版本号</li>
</ul>
<h4 id="Undo日志"><a href="#Undo日志" class="headerlink" title="Undo日志"></a>Undo日志</h4><p>每一条数据行都有三个隐藏的字段：<code>隐藏id（主键）、trx_id、roll_pt</code>。其中<code>roll_pt</code>是回滚指针，用来指向undo日志。在事务提交前，undo日志会记录数据行一开始的状态；提交后，undo日志不会立刻删除，而是会放在删除区等待删除。</p>
<p><strong>举例：行更新的过程</strong></p>
<ol>
<li>初始数据行</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字段1</th>
<th style="text-align:center">字段2</th>
<th style="text-align:center">字段3</th>
<th style="text-align:center">字段4</th>
<th style="text-align:center">字段5</th>
<th style="text-align:center">字段6</th>
<th style="text-align:center">主键id</th>
<th style="text-align:center">trx_id</th>
<th style="text-align:center">rool_p</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">122</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">6</td>
<td style="text-align:center">01</td>
<td style="text-align:center">00</td>
<td style="text-align:center">Null</td>
</tr>
</tbody>
</table>
</div>
<p>2.事务1修改了这行的所有内容，首先会给这行数据加写锁：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字段1</th>
<th style="text-align:center">字段2</th>
<th style="text-align:center">字段3</th>
<th style="text-align:center">字段4</th>
<th style="text-align:center">字段5</th>
<th style="text-align:center">主键id</th>
<th style="text-align:center">trx_id</th>
<th style="text-align:center">roll_pt</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">20</td>
<td style="text-align:center">30</td>
<td style="text-align:center">40</td>
<td style="text-align:center">50</td>
<td style="text-align:center">01</td>
<td style="text-align:center">01</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>生成一个undo日志1，<strong>该数据行的<code>roll_pt</code>会指向undo日志1的<code>主键id</code>上</strong>，而undo日志保留了初始数据行的状态：</p>
<p><strong>undo日志1：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字段1</th>
<th style="text-align:center">字段2</th>
<th style="text-align:center">字段3</th>
<th style="text-align:center">字段4</th>
<th style="text-align:center">字段5</th>
<th style="text-align:center">主键id</th>
<th style="text-align:center">trx_id</th>
<th style="text-align:center">roll_pt</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">2</td>
<td style="text-align:center">3</td>
<td style="text-align:center">4</td>
<td style="text-align:center">5</td>
<td style="text-align:center">01</td>
<td style="text-align:center">00</td>
<td style="text-align:center">Null</td>
</tr>
</tbody>
</table>
</div>
<p>3.事务一提交，释放写锁，事务二进行了修改: </p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字段1</th>
<th style="text-align:center">字段2</th>
<th style="text-align:center">字段3</th>
<th style="text-align:center">字段4</th>
<th style="text-align:center">字段5</th>
<th style="text-align:center">主键id</th>
<th style="text-align:center">trx_id</th>
<th style="text-align:center">roll_pt</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">11</td>
<td style="text-align:center">21</td>
<td style="text-align:center">31</td>
<td style="text-align:center">41</td>
<td style="text-align:center">51</td>
<td style="text-align:center">01</td>
<td style="text-align:center">02</td>
<td style="text-align:center">2</td>
</tr>
</tbody>
</table>
</div>
<p>此时会生成一个<strong>undo日志2</strong>保存事务二修改前的状态，该数据行的<code>roll_pt</code>指向undo日志2的主键id上：</p>
<p><strong>undo日志2</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字段1</th>
<th style="text-align:center">字段2</th>
<th style="text-align:center">字段3</th>
<th style="text-align:center">字段4</th>
<th style="text-align:center">字段5</th>
<th style="text-align:center">主键id</th>
<th style="text-align:center">trx_id</th>
<th style="text-align:center">roll_pt</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">10</td>
<td style="text-align:center">20</td>
<td style="text-align:center">30</td>
<td style="text-align:center">40</td>
<td style="text-align:center">50</td>
<td style="text-align:center">01</td>
<td style="text-align:center">01</td>
<td style="text-align:center">1</td>
</tr>
</tbody>
</table>
</div>
<p>由于undo日志1的值不会立即被删除，因此<strong>undo日志2的<code>roll_pt</code>会指向undo日志1的<code>主键id</code>上，形成一条版本链。</strong></p>
<h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p>MVCC中进行快照读的基准是ReadView。执行<code>select</code>操作，可能会创建一个ReadView（依赖于隔离级别），ReadView保存着系统中所有未提交事务的<code>trx_id</code>。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">TRX_ID</th>
<th style="text-align:center"></th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">TRX_ID_MIN</td>
<td style="text-align:center">…</td>
<td style="text-align:center">TRX_ID_MAX</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>TRX_ID_MIN：表示在生成readview时当前系统中活跃的读写事务中最小的事务id</li>
<li>TRX_ID_MAX：表示生成readview时系统中应该分配给下一个事务的id值（一般情况下是当前事务id + 1，高并发情况下可能更大）</li>
</ul>
<p>当用户想要读取某条数据行时，innodb会将这个行的版本号与readview中的版本号进行比较：</p>
<ul>
<li>trx_id &lt; TRX_ID_MIN：当前事务开启时，生成这个版本记录的事务已经提交了，所以一定可以读取</li>
<li>trx_id &gt; TRX_ID_MAX：生成这个版本的事务是本次事务开启readview之后才开启的，对当前事务不可见，不可读取数据（这种情况相爱trx_id的数据一定是无法提交成功的，因为我select的时候会加读锁，之后的事务的修改想要提交成功必须要等我释放锁）</li>
<li>TRX_ID_MIN &lt; trx_id &lt; TRX_ID_MAX：如果trx_id不在readview里，表示生成该版本号的事务已经提交， 可以读取数据；否则，说明未提交，这就不可以读了。</li>
</ul>
<p>补充：如果出现不可读的情况，将会沿着undo日志通过版本链查找最新可用的版本号进行读取。</p>
<h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><h2 id="读未提交（Read-Uncommited）"><a href="#读未提交（Read-Uncommited）" class="headerlink" title="读未提交（Read Uncommited）"></a>读未提交（Read Uncommited）</h2><p>顾名思义，可以读到其他事务未提交的数据。这种隔离级别是<strong>不加锁的</strong>，效率最高，也不用MVCC。</p>
<h2 id="读已提交（Read-Commited）"><a href="#读已提交（Read-Commited）" class="headerlink" title="读已提交（Read Commited）"></a>读已提交（Read Commited）</h2><p>事务提交后，可以被其他事务读取。但是事务B在两次读取的时间间隔内，事务A提交了修改，则事务B两次读取的数据就会不一样，这就是”不可重复读“的问题。</p>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>事务A在修改数据的时候加写锁，直到事务结束。</p>
<p>此时这种解决方法会遇到一个问题：<strong>其他事务想要读数据时，会等待锁的释放。</strong></p>
<p>因此Innodb引擎使用了MVCC来解决读写的一个并发情况。在这种隔离级别下：每次select都会生成一个readview，从而保证每次读取都只能读到已经提交的数据。但是，因为每次select都会生成一个新的readview，因此在这个事务执行期间，可以生成多个不同的readview从而读取到不一致的数据。无法解决不可重复读的情况。</p>
<h2 id="可重复读（Repeatable-Read）：MySQL默认"><a href="#可重复读（Repeatable-Read）：MySQL默认" class="headerlink" title="可重复读（Repeatable Read）：MySQL默认"></a>可重复读（Repeatable Read）：MySQL默认</h2><p>事务在执行期间，不会读取到其他事务对数据的<strong>修改</strong>。但是其他事务插入的数据依然会被update等操作捕捉到。</p>
<h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>事务开启后的第一次<code>select</code>操作生成了一次readview，后续的所有<code>select</code>都是读的第一次生成的快照。</p>
<p>但是所有<code>update</code>、<code>delete</code>操作都是当前读，所谓<strong><font color="red">当前读就是读取到最新已提交版本号的数据</font></strong>，所以当前读不走快照的。因此，当事务A在执行<code>update</code>或者<code>delete</code>操作时，会读取到其他事务提交的数据，这些新数据和之间<code>select</code>的数据不一致，间接产生了幻读问题。</p>
<p><strong>由此可见，MVCC可以解决由select操作引起的直接幻读，但是不能解决修改操作引起的间接幻读。</strong></p>
<p><em>业务场景：</em></p>
<p>快手公司准备给次日24：00之间注册的用户发放1元红包，这时开启事务后会执行update操作，但是24：00之后依然会有大量新用户注册入库，此时update会同时修改这些新用户的红包信息（错误发钱），这就产生了幻读问题，并给公司带来业务损失。</p>
<h3 id="如何解决幻读？"><a href="#如何解决幻读？" class="headerlink" title="如何解决幻读？"></a>如何解决幻读？</h3><p>Innodb其实在RR隔离级别下实现了幻读的解决：使用了<strong>Next-Key Locks</strong>。</p>
<p>当开启一个<code>select</code>的操作时，会锁住索引前后的间隔（左开右闭，行锁），这时其他事务进行<code>insert</code>操作会阻塞。</p>
<p>假设一个数据表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Id</th>
<th style="text-align:center">a</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">1</td>
<td style="text-align:center">5</td>
</tr>
<tr>
<td style="text-align:center">2</td>
<td style="text-align:center">8</td>
</tr>
<tr>
<td style="text-align:center">3</td>
<td style="text-align:center">11</td>
</tr>
<tr>
<td style="text-align:center">4</td>
<td style="text-align:center">18</td>
</tr>
</tbody>
</table>
</div>
<p>此时<strong>Next-Key Locks</strong>对于索引a的锁的间隔是：$(-oo, 5], (5, 8], (8, 11], (11, 18], (18, +oo]$</p>
<p>如果此时我们执行：<code>select * from table_name where a = 8</code></p>
<p>此时会锁住：$ (5, 8] U (8, 11] = (5, 11]$，此时其他事务无法这个范围内的行进行任何操作。</p>
<h2 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h2><p>所有事务串行处理，效率很低，但是足够安全。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈Java类加载顺序和static关键字</title>
    <url>/2019/12/15/%E6%B5%85%E8%B0%88Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E5%92%8Cstatic%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本篇博客主要包含以下几个内容</p>
<ol>
<li>Java中类加载的顺序</li>
<li>Java中static关键字的用法</li>
<li>面试的一些常见问题</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="Java中的类加载"><a href="#Java中的类加载" class="headerlink" title="Java中的类加载"></a>Java中的类加载</h1><p>JVM要执行一段Java程序分为两步：</p>
<ol>
<li>将类编译成.class字节码文件</li>
<li>进行类加载生成类</li>
</ol>
<h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>想要理解static必须要了解一下类加载的过程，主要分为三步：</p>
<ol>
<li>第一步：类文件加载</li>
<li>第二步：类链接<ol>
<li>验证</li>
<li>准备</li>
<li>解析</li>
</ol>
</li>
<li>第三步：类初始化</li>
</ol>
<h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类的加载一般通过JVM提供的类加载器ClassLoader完成，在以下几种情况下，JVM会把类加载进内存中进行使用：</p>
<ol>
<li>new 这个类的对象</li>
<li>访问这个类或接口的静态变量</li>
<li>调用这个类的静态方法</li>
<li>执行反射操作：Class.forName(“类名”)</li>
<li>加载这个类的子类</li>
<li>JVM启动时表明的启动类(<strong>这说明了一个类并不一定要被使用的时候才会被加载</strong>)</li>
</ol>
<h2 id="类文件加载"><a href="#类文件加载" class="headerlink" title="类文件加载"></a>类文件加载</h2><p>JVM在编译时会生成类的.class字节码文件，这个文件是存储在磁盘上的。当JVM运行时需要加载某个类时，会将这个文件读入内存，<strong>并由类加载器为其生成一个独一无二的java.lang.Class对象。</strong> 这个对象保存了一个类的所有信息，用暴力反射甚至可以操作其私有变量。</p>
<h2 id="类链接"><a href="#类链接" class="headerlink" title="类链接"></a>类链接</h2><p>这一步主要分为三小步</p>
<ol>
<li>验证：主要验证这个类是否有正确的内部结构(比如.class文件格式是否符合规范等)（这里我有疑问，如果验证失败了，其创建的Class对象是否还有意义？）</li>
<li>准备：为类中的静态变量分配内存，并设置初始值(同时也会在常量池中创建这个常亮)</li>
<li>解析：将内存中二进制数据的符号引用生成直接引用（这个引用在堆里，详情可见<a href="https://memoforward.cn/2019/09/25/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AJava%E4%B8%AD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/" target="_blank" rel="noopener">HashMap 为什么会出现内存泄漏问题以及 Java 中引用类型的存储位置</a>)</li>
</ol>
<h2 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h2><p>这一步主要给静态变量赋正确的值。<br>也就是说，当我定义<code>static a = 10</code>时，会先在第二步中进行初始化成0，然后在类初始化时被赋予正确的值。因为在程序运行时，每个类只会被加载一次，因此静态成员变量的初始化只会进行一次。</p>
<h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol>
<li>加载子类前会先加载父类</li>
<li>类加载完成后，才会执行类实例化的操作</li>
<li>类初始化和类实例化时不同的概念</li>
</ol>
<h1 id="static关键字的用法"><a href="#static关键字的用法" class="headerlink" title="static关键字的用法"></a>static关键字的用法</h1><p>static关键字主要用于五个方面：</p>
<ol>
<li>静态方法</li>
<li>静态成员变量</li>
<li>静态代码块</li>
<li>静态内部类</li>
<li>静态导入</li>
</ol>
<h2 id="静态变量和静态代码块"><a href="#静态变量和静态代码块" class="headerlink" title="静态变量和静态代码块"></a>静态变量和静态代码块</h2><p>类加载的时候被赋值和调用，其顺序与代码顺序一致。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line">    <span class="comment">//改变两段定义的位置程序性会报错</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(a); <span class="comment">// a:0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestStatic t = <span class="keyword">new</span> TestStatic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>类的静态方法会在类加载时分配入口地址，<strong>并且早于类对象的构造函数调用</strong>，因此静态方法是无法访问类的非静态成员变量的，因此在静态方法中也无法使用<code>this或者super</code>关键字。</p>
<h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>具体可以查看我的博客：<a href="https://memoforward.cn/2019/12/15/%E6%B5%85%E8%B0%88Java%E5%86%85%E9%83%A8%E7%B1%BB/" target="_blank" rel="noopener">浅谈Java内部类</a></p>
<h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><p>这个是JDK5之后的特性，用于导入某个类的<strong>静态方法</strong>，导入后可以直接使用方法名来使用该方法。其用法如下：<code>import static 包名.类名.方法名</code>，方法名可以改成通配符<code>*</code>，这样就可以导入所有静态方法。（我试了一下，静态成员变量无法导入）<br>例子继续按照上方的代码，增加了一个静态方法，并把该类放置在<code>memoforward包</code>下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"gogogogo....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>随后我在另一个类中静态导入方法<code>print()</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> memoforward.TestStatic.print;</span><br><span class="line"><span class="comment">//import static memoforward.TestStatic.*;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticImport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个程序的输出是：<code>10 和 gogogo...</code>，表示调用某个类静态方法后，这个类会先被加载。</p>
<h2 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h2><ul>
<li>静态成员变量和静态方法都是被所有对象共有的，任意对象都可以操作<strong>同一份</strong>静态变量，使用静态方法。</li>
<li>子类对象可以使用父类对象的静态成员变量（且仍是同一份数据），但是如果子类重新声明了同名静态变量，则JVM会为子类额外分为一块内存空间，此时会由对象的类型来确定到底调用哪一个静态变量（因此静态变量不存在继承的关系，其调用完全根据其类型，静态方法同理），学术点讲：静态方法是静态绑定的。</li>
<li>如果子类和父类有同名的静态变量或者静态方法，则根据其<strong>引用类型</strong>进行调用。</li>
</ul>
<p>测试代码：</p>
<ul>
<li>父类Father</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">17</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Father method..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类Son</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son method..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试：可见静态的变量和方法若有重名会根据其引用类型来确定，若没有重名，则子类调用父类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> memoforward.Father;</span><br><span class="line"><span class="keyword">import</span> memoforward.Son;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticExtends</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        Father fs = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(father.a); <span class="comment">// 10</span></span><br><span class="line">        System.out.println(son.a); <span class="comment">// 5</span></span><br><span class="line">        System.out.println(fs.a); <span class="comment">// 10 </span></span><br><span class="line">        System.out.println(son.b); <span class="comment">// 17</span></span><br><span class="line">        father.staticMethod(); <span class="comment">// Father staticMehtod...</span></span><br><span class="line">        son.staticMethod(); <span class="comment">// Son staticMethod...</span></span><br><span class="line">        fs.staticMethod(); <span class="comment">// Father staticMehtod...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h1><ul>
<li><p>问题一<br>Q：static关键字会改变变量的访问权限吗？<br>A：不会，能影响访问权限的只有<code>public、private和protected</code>关键字，如果一个静态变量被声明为<code>private</code>，则在类外是无法使用的。</p>
</li>
<li><p>问题二<br>Q：抽象方法可否是静态的？<br>A：不能，静态方法不能被重写，且抽象方法无法直接被类调用。</p>
</li>
<li><p>问题三<br>Q：以下代码的输出是什么</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Test"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person "</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"MyClass"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A：输出如下<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. test static</span><br><span class="line">2. myclass static</span><br><span class="line">2. person static </span><br><span class="line">3. person Test</span><br><span class="line">4. test constructors</span><br><span class="line">5. person MyClass</span><br><span class="line">6. myclass constructor</span><br></pre></td></tr></table></figure></p>
<p>Explanation:</p>
<ol>
<li>调用Test类的静态方法Main，首先会加载Test类，因此执行静态代码块，输出:<code>test static</code></li>
<li>使用new MyClass()，会先加载类MyClass，输出:<code>myclass static</code></li>
<li>执行子类实例化前，会先执行父类实例化，初始化操作的顺序：先给成员变量赋默认值，再执行构造函数，因此先执行父类<code>Test</code>中<code>new Person(&quot;Test&quot;)</code></li>
<li>加载<code>Person</code>类，并执行构造函数，先后输出:<code>person static</code>和<code>person Test</code></li>
<li>父类<code>Test</code>中成员变量<code>person</code>赋值完毕，执行构造函数,输出：<code>test constructor</code></li>
<li>随后进行子类对象<code>MyClass</code>初始化，因为<code>Person</code>类已经加载过，因此不会再加载了，所以先后输出:<code>person MyClass</code>和<code>myClass constructor</code></li>
</ol>
<p><font color="red"> Attention: </font><br>这里有个小细节：子类所有实例化操作（包括成员变量赋值和构造器）都慢于父类实例化的操作，而实例化操作的顺序是：先进行成员变量赋值，再执行构造函数。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java面试问题汇总（一）</title>
    <url>/2019/12/13/%E5%B8%B8%E8%A7%81%E7%9A%84Java%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E4%B8%80%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本篇文章主要包括如下内容：</p>
<ol>
<li>无序数组寻找第K大的值的算法</li>
<li>Java中static关键字的理解</li>
<li>Java中的HashMap</li>
<li>Java中的LinkedHashMap</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="无序数组寻找第K大的值"><a href="#无序数组寻找第K大的值" class="headerlink" title="无序数组寻找第K大的值"></a>无序数组寻找第K大的值</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个数组，寻找其第K大的值，并分析其复杂度</p>
<h2 id="笔者踩的坑"><a href="#笔者踩的坑" class="headerlink" title="笔者踩的坑"></a>笔者踩的坑</h2><p>遇到这种问题一定要思考一下，问一下面试官：</p>
<ol>
<li>数组是否是数字？</li>
<li>数组是否有序？ </li>
<li>数组中是否有重复的数字？</li>
</ol>
<p>笔者没问，回来后后悔不已，毕竟这是笔者第一次面试，把自己的菜展现的一览无余。</p>
<p><strong>我们假设这道题：无序，是数字，无重复。</strong></p>
<h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>寻找一个标志，遍历数组，将比它小的放在左边，比它大的放在右边（快排），记录比它小的数的个数，如果大于K，则在左边寻找，如果小于K，则在右边寻找。</p>
<h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> findKth(nums, k, <span class="number">0</span>, nums.length);</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = start;</span><br><span class="line">        <span class="keyword">int</span> flag = nums[start];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start+<span class="number">1</span>; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= flag) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p++;</span><br><span class="line">                exchange(nums, p, i);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exchange(nums,start, p);</span><br><span class="line">        <span class="keyword">if</span>(count == k -<span class="number">1</span>) <span class="keyword">return</span> nums[p];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count &gt; k -<span class="number">1</span>) <span class="keyword">return</span> findKth(nums, k, start, p);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> findKth(nums, k - <span class="number">1</span> - count, p+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Java中static关键字的理解"><a href="#Java中static关键字的理解" class="headerlink" title="Java中static关键字的理解"></a>Java中static关键字的理解</h1><p>具体可以移步我的博客：<a href>浅谈Java类加载机制和static关键字</a></p>
<h1 id="Java中的HashMap"><a href="#Java中的HashMap" class="headerlink" title="Java中的HashMap"></a>Java中的HashMap</h1><p>具体可以移步我的博客：<a href>浅谈Java中的HashMap以及红黑树</a></p>
<h1 id="Java中的LinkedHashMap"><a href="#Java中的LinkedHashMap" class="headerlink" title="Java中的LinkedHashMap"></a>Java中的LinkedHashMap</h1><p>具体可以移步我的博客：<a href>浅谈Java中LinkedHashMap的实现</a></p>
]]></content>
      <categories>
        <category>面试题</category>
      </categories>
      <tags>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL的数据结构以及辅助索引的使用</title>
    <url>/2019/09/28/MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文涉及的知识点如下</p>
<ol>
<li>MySQL的内部存储结构BTree和B+Tree</li>
<li>主键索引和辅助索引的结构 以及 查询操作的执行流程</li>
<li>InnoDB引擎和MyISAM引擎的差别</li>
</ol>
<a id="more"></a>
</blockquote>
<p>·　　之前学习MySQL都是一直半解，以为建立主键索引只是为了约束数据。直到自己学着做一些开源项目的时候，才发现有<strong>辅助索引</strong>这个神奇的设定，对应的SQL语句：<code>KEY aux_index(col_name)</code>，上网一搜才发现这是为了加快MySQL查询速度。于是我就对MySQL的数据存储结构产生了兴趣，在这里做一个小小的总结。</p>
<p>·　　我查看了官方的文档和许多博客，觉得这篇博客写的是真的好，分享给大家：<a href="https://www.kancloud.cn/kancloud/theory-of-mysql-index/41846" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p>
<h1 id="BTree-和-B-Tree"><a href="#BTree-和-B-Tree" class="headerlink" title="BTree 和 B+Tree"></a>BTree 和 B+Tree</h1><p>·　　B+Tree是BTree的扩展，而常用的MySQL引擎<strong>MyISAM和InnoDB</strong>都是用B+Tree作为数据结构存储的（在参考博客里有使用BTree的原因，涉及计算机磁盘的读写，本文不讨论这部分内容），因此在这里介绍一下这两个数据结构。</p>
<h2 id="索引的价值"><a href="#索引的价值" class="headerlink" title="索引的价值"></a>索引的价值</h2><p>·　　索引顾名思义就是目录，我们需要的内容可能是庞大的，但是索引都是很简洁的，所以索引的存储相比内容而言更具灵活性，也更容易被应用于复杂的数据结构。我们把庞大的内容放在内存里，通过索引去找到这些内容，不仅可以利用索引的灵活性构成高效的数据结构来提高查找效率，也可以一定程度下减少查找时所用的I/O读写时间。</p>
<h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h2><p>·　　BTree有一个重要的概念：度。<br>·　　这个概念似乎和正常的树不太一样，一般说来树节点的“度”表示此节点下拥有的子树的个数，是针对一个节点而言的，<strong>而BTree的度，表示这颗树的度</strong>。<br>·　　在介绍这个概念之前，我们要搞清楚BTree的节点中存的是什么。<strong>BTree的每个节点都储存了至少一个键值对，在每个键值对的前后都有一个指针。</strong> 具体的图如下：<br><img src="https://img-blog.csdnimg.cn/20190928201511856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>·　　上图中根节点储存有：<strong>三个键值对，四个指针。</strong> 每一个指针都会指向下一个节点，或者指向null。<br>·　　如果规定：<strong>一个节点中拥有<code>n</code>个指针和<code>n-1</code>个键值对，那么BTree的度<code>d</code>则约束了：<code>d ≤ n ≤ 2d</code>。</strong> 上图就是一个<code>d = 2</code>的BTree结构。<br>·　　根据上图我们显然可以猜到BTree树的性质</p>
<ol>
<li>每个节点中的键值对，根据键的大小，从左至右非递减。</li>
<li>指针左边的key都小于等于指针指向的子节点的所有key，右边的key都大于等于。</li>
</ol>
<p>·　　查找的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BTree_Search(node, m_key)&#123;</span><br><span class="line">	<span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	foreach(k : node.key)&#123;</span><br><span class="line">		<span class="keyword">if</span>(m_key == k) <span class="keyword">return</span> node.get(k);</span><br><span class="line">		<span class="keyword">if</span>(m_key &lt; k) <span class="keyword">return</span> BTree_Search(node.leftPointer(k), m_key);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> BTree_Search(node.rightPointer(last_key), m_key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTree_Search(root, m_key);</span><br></pre></td></tr></table></figure>
<p>·　　这里有一个有趣的小细节：BTree在最简单的情况下就是一个二叉树，因此BTree树的高最高是logN。</p>
<h2 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h2><p>·　　通过上面的BTree我们注意到，每个节点都会存数据，为了加快读写的速度，引入了B+Tree，舍去了非叶子节点的数据存储，仅在叶子结点中存储所有的value；同时，其对指针的数量进行了一些调整。概念图如下：<br><img src="https://img-blog.csdnimg.cn/20190928205253979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>·　　可见，在B+Tree中，每个节点中指针的数量和键的数量相同，并满足：<code>d ≤ n &lt; 2d</code>。而且叶子节点不存储指针。<br>·　　查找的伪代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">BTree_Search(node, m_key)&#123;</span><br><span class="line">	<span class="keyword">if</span>(node.isLeaf())&#123;</span><br><span class="line">		foreach(k : node.key)&#123;</span><br><span class="line">			<span class="keyword">if</span>(m_key == k) <span class="keyword">return</span> node.get(k);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	foreach(k : node.key)&#123;</span><br><span class="line">		<span class="keyword">if</span>(m_key == k) <span class="keyword">return</span> BTree_Search(node.rightPointer(k), m_key);</span><br><span class="line">		<span class="keyword">if</span>(m_key &lt; k) <span class="keyword">return</span> node.havaLeftPointer() ? BTree_Search(node.leftPointer(k), m_key) : <span class="keyword">null</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> BTree_Search(node.rightPointer(last_key), m_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="MySQL中的数据结构（索引实现）"><a href="#MySQL中的数据结构（索引实现）" class="headerlink" title="MySQL中的数据结构（索引实现）"></a>MySQL中的数据结构（索引实现）</h1><p>·　　空谈结构没有数据就是耍流氓，因此这里提供一个数据库表。我们假设：<strong>id为主键索引，name为辅助索引。</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>name</th>
<th>gender</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>cxy</td>
<td>male</td>
</tr>
<tr>
<td>2</td>
<td>lhw</td>
<td>female</td>
</tr>
<tr>
<td>3</td>
<td>tyy</td>
<td>female</td>
</tr>
<tr>
<td>4</td>
<td>dsx</td>
<td>male</td>
</tr>
</tbody>
</table>
</div>
<h2 id="InooDB引擎"><a href="#InooDB引擎" class="headerlink" title="InooDB引擎"></a>InooDB引擎</h2><p>·　　鄙人不才，只用过这一个引擎，主要是因为InooDB支持事务和行级锁。InooDB索引结构是B+Tree，其索引就是一个个key。但是主键索引和辅助索引在叶子节点的存储结构上有一点不同。</p>
<ul>
<li><strong>对于主键索引，其存储结构可能如下（仅做示意）：</strong><br><img src="https://img-blog.csdnimg.cn/20190928213309884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><strong>因此若执行<code>select * from this_table where id = 3</code>，就会执行</strong>：<br><img src="https://img-blog.csdnimg.cn/20190928214021332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><strong>辅助索引结构示意图：顺序是ASCII码</strong><br><img src="https://img-blog.csdnimg.cn/2019092821434353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>·　　<strong>可见，辅助索引中存储的是主键索引，而不是真正的数据值。</strong></li>
<li><strong>因此若执行<code>select * from this_table where name = cxy</code>，就会执行</strong><br><img src="https://img-blog.csdnimg.cn/20190928215014827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
<li><font color="red">**注意**</font></li>
</ul>
<ol>
<li>InooDB引擎必须要有主键，因为整个引擎都是以主键构成的B+Tree结构而存在的。如果我们不指定主键，mysql会自动给我们创建一个隐藏的主键。</li>
<li>InooDB的主键最好设置成：<strong>与业务无关且自增。</strong> 我们观察BTree的结构，一旦插入值，这个结构就要重建，很费时，如果主键是自增的，可以减少插入数据时BTree树的更新时间(降低数据写入的时间)。</li>
<li>辅助索引如果不手动创建，MySQL是不会帮我们创建的，<strong>如果没有辅助索引，我们通过name来找数据的时候，搜索复杂度是O(n)，非常耗时。</strong></li>
<li><strong>辅助索引并不是越多越好。</strong> 我们观察整个搜索流程会发现，<strong>辅助索引通过牺牲空间的方式来提升查询速度，如果辅助索引过多，必然会造成空间的浪费。</strong></li>
</ol>
<h2 id="MyISAM引擎"><a href="#MyISAM引擎" class="headerlink" title="MyISAM引擎"></a>MyISAM引擎</h2><p>·　　这个引擎我还没用过，因为其不支持事务，但是其查询速度非常快！<strong>因为，不管是主键索引还是辅助索引，其叶子节点都存放着数据的地址值</strong>，这表示，在MyISAM引擎中，主键并不是必须的，我们可以通过任何索引在一个logN时间内访问到数据。（但本质上，这还是一个通过空间换时间的算法）</p>
<ul>
<li><strong>简要画一下MyISAM的索引结构示意图</strong><br><img src="https://img-blog.csdnimg.cn/20190928221842902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>·　　辅助索引的结构是一样的。</li>
</ul>
<h2 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h2><p>·　　这个概念我是这么理解的，如果<strong>数据和索引在整个结构中不分离，则为聚集索引</strong>，因此在InooDB中主键索引是聚集索引，而辅助索引是非聚集索引；而在MyISAM中，所有的索引都是非聚集的。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　用了一晚上来写这个博客，还算是有所收获，也终于知道了MySQL数据库的存储结构，以及要在什么时候使用辅助索引。</p>
<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote>
<p>请联系邮箱：chenxingyu@bupt.edu.cn</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>HashMap为什么会出现内存泄漏问题以及Java中引用类型的存储位置</title>
    <url>/2019/09/25/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AJava%E4%B8%AD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文涉及如下知识点：</p>
<ol>
<li>HotSpot的垃圾处理机制</li>
<li>HashMap为什么存在内存泄漏问题</li>
<li>Java中的引用变量的存储位置</li>
</ol>
</blockquote>
<a id="more"></a>
<p>·　　最近在研究弱引用的时候，注意到了Java在内存管理时的细节，在这里给大家分享一下。</p>
<h1 id="JVM中垃圾处理的机制"><a href="#JVM中垃圾处理的机制" class="headerlink" title="JVM中垃圾处理的机制"></a>JVM中垃圾处理的机制</h1><p>·　　垃圾处理的算法非常多，本博客只介绍使用最广的HotSpot虚拟机的垃圾回收算法。简单说来，其使用了<strong>可达性分析算法</strong> ，通过选出一系列称为<strong>GC Roots</strong>的对象作为起点，当一个对象没有任何一条<strong>强引用链</strong>指向<strong>GC Roots</strong>时，则这个对象会被判定为可回收对象。弱引用不是本章讨论的重点，有兴趣的自行百度。<br><img src="https://img-blog.csdnimg.cn/2019092422030897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="图1-1"><br>·　　在上图中，object5、6、7会被回收。<br>·　　显然，此算法最核心的部分在于<strong>GC Roots</strong>的选取，所以我们要关注<font color="red"><strong>在什么位置的对象才能成为GC Roots</strong></font>,在《深入理解JVM虚拟机》中给出了答案：</p>
<ol>
<li><strong>虚拟机栈中引用的对象</strong></li>
<li><strong>方法区中类静态属性引用的对象</strong></li>
<li><strong>方法区中的常量对象</strong></li>
<li><strong>本地方法栈中JNI(Native方法)引用的对象</strong></li>
</ol>
<p>·这里不普及JVM的内存结构。</p>
<h1 id="Java中引用类型的存储位置"><a href="#Java中引用类型的存储位置" class="headerlink" title="Java中引用类型的存储位置"></a>Java中引用类型的存储位置</h1><p>·　　介绍可达性算法主要是为了给我下面的想法做铺垫。<br>·　　<font color="red"><strong>注意：以下的内容我没有从任何书籍和博客上看到明确的解答，所以仅是我个人的一些理解。</strong></font></p>
<ul>
<li><strong>Java中的引用到底存在哪里?</strong><br>·　　大部分人都认为，在java中，所有的引用都保存在栈中(虚拟机栈），而引用指向的对象实例则在堆里。<strong>我认为这是不准确的，如果一个对象实例中有另一个对象的引用，那么<font color="red">这个引用并非存在栈里，而是存在于堆中</font></strong>。<br>·　　下面给出我测试用的一段代码：</li>
<li>测试用类B：对象占用内存大小1MB</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试用类A：占用内存大小2MB</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试代码：为了避免不必要的干扰，我在创建实例前先进行了一次垃圾回收。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>·　　结果猜测：显然，<code>引用ａ</code>是存在于栈中的，而ａ指向的实例Ａ，以及实例Ａ中创建的实例Ｂ存在于堆中。现在不确定的点在于：指向实例B的<code>a.b</code>这个引用是存在于栈中，还是堆中呢？众所周知，栈中的数据会随着方法的结束而被释放，如果方法不结束，其数据就不会释放，因此我用<code>while(true){...}</code>使main方法永远不会结束，且每5秒进行一次垃圾回收，看堆中的储存情况。</p>
<ol>
<li>如果<code>a.b</code>保存在栈中，其就可作为<strong>GC Root</strong>存在，那么根据可达性算法，实例B永远不会被回收。</li>
<li>而如果<code>a.b</code>保存在堆中，一旦<code>引用a</code>被释放了，那么实例A和实例B就会如上图中的<code>object5、6、7</code>一样，被GC回收</li>
<li>根据以上两种理论，<strong>如果<code>a.b</code>保存在栈中，即使实例A被释放了，实例B也不会被释放，堆中至少有1MB的数据。而如果<code>a.b</code>保存在堆中，实例A和实例B都会被释放，堆中的数据至少会小于1MB。</strong></li>
</ol>
<ul>
<li>以下是程序的运行结果：<strong>堆内存中可粗略地细分为新生代和老年代</strong>，这里就不扩展了。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 3333K-&gt;744K(38400K)] 3333K-&gt;752K(125952K), 0.0042393 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 744K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;673K(87552K)] 752K-&gt;673K(125952K), [Metaspace: 3479K-&gt;3479K(1056768K)], 0.0078916 secs] [Times: user&#x3D;0.03 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 2713K-&gt;2176K(38400K)] 3386K-&gt;2849K(125952K), 0.0010460 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 2176K-&gt;0K(38400K)] [ParOldGen: 673K-&gt;2718K(87552K)] 2849K-&gt;2718K(125952K), [Metaspace: 3485K-&gt;3485K(1056768K)], 0.0079493 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 665K-&gt;64K(38400K)] 3384K-&gt;2782K(125952K), 0.0003627 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 64K-&gt;0K(38400K)] [ParOldGen: 2718K-&gt;670K(87552K)] 2782K-&gt;670K(125952K), [Metaspace: 3485K-&gt;3485K(1056768K)], 0.0039402 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 0K-&gt;0K(38400K)] 670K-&gt;670K(125952K), 0.0003178 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 0K-&gt;0K(38400K)] [ParOldGen: 670K-&gt;669K(87552K)] 670K-&gt;669K(125952K), [Metaspace: 3485K-&gt;3485K(1056768K)], 0.0066122 secs] [Times: user&#x3D;0.05 sys&#x3D;0.00, real&#x3D;0.01 secs]</span><br></pre></td></tr></table></figure>
<ol>
<li>第一次GC时，堆中的内存被清理到只有673K，并且进入了老年代：<code>[ParOldGen: 8K-&gt;673K(87552K)]</code>。</li>
<li>第二次GC前，我们创建了对象a，在堆内存中占用了2MB：<code>[PSYoungGen: 2713K-&gt;2176K(38400K)]</code>(<del>这里不做细微的误差分析，因为我也不清楚gc到底干了什么</del> )。随后这2MB内存进入了老年代：<code>[ParOldGen: 673K-&gt;2718K(87552K)]</code></li>
<li>第三次GC前，我们释放了实例A的链接，发现这2MB内存被释放了，老年代中仅剩原先的673K（可能有点误差）：<code>[ParOldGen: 2718K-&gt;670K(87552K)]</code></li>
<li>第四次GC，因为堆中已经没有实例A、B所以此垃圾回收没有释放任何空间。</li>
<li><font color="red">**总上所述：我认为类成员变量的引用必然在堆内存中。**</font>

</li>
</ol>
<h1 id="HashMap的内存泄漏问题"><a href="#HashMap的内存泄漏问题" class="headerlink" title="HashMap的内存泄漏问题"></a>HashMap的内存泄漏问题</h1><p>·　　有了上述问题的铺垫，我们可以正式聊一下HashMap中内存泄漏的问题， 因为之前看ThreadLocal的源码才意识到了这个问题，实在是惭愧，话不多说，我先解释一下内存泄漏的原因：</p>
<ol>
<li>首先要明确的一点是，<strong>Java中的参数都是按值传递的</strong>，即使是引用，在传递时也会生成引用的副本。</li>
<li>因此，HashMap的对象引用<code>map</code>在<code>put(key，value)</code>时，就会生成key，value引用的副本，我们姑且称为<code>key&#39;</code>和<code>value&#39;</code>。根据上面的理论，这个副本应该存在堆内存中。</li>
<li>当栈中的<code>key引用</code>被释放时，原来指向的实例<code>KEY</code>（姑且这么称呼），与栈中的<code>map引用</code>依然存在一条可达链：<strong>map —— HashMap实例 —— key’ —— KEY实例</strong> 这条强引用链。因此实例KEY不会被释放，虽然HashMap可以保存键为null的Entry，但是实例KEY我们就不会再用到了，而它迟迟不释放，就会造成内存泄漏的问题。</li>
</ol>
<ul>
<li>图示说明：可以很明显看出来<code>KEY</code>和<code>VALUE</code>有两条强引用链<br><img src="https://img-blog.csdnimg.cn/20190925084205942.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h2>我们将类A稍作修改，让其不关联类B：</li>
<li>类A</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="comment">//    public B b = new B();</span></span><br><span class="line">    <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>代码如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"0.--------------"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"1.--------------"</span>);</span><br><span class="line">        Map&lt;A, B&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"2.--------------"</span>);</span><br><span class="line">        map.put(a,b);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"3.--------------"</span>);</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"4.--------------"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 3333K-&gt;712K(38400K)] 3333K-&gt;720K(125952K), 0.0016227 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 712K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;629K(87552K)] 720K-&gt;629K(125952K), [Metaspace: 3206K-&gt;3206K(1056768K)], 0.0074770 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">1.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 3379K-&gt;2176K(38400K)] 4008K-&gt;2805K(125952K), 0.0012001 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 2176K-&gt;0K(38400K)] [ParOldGen: 629K-&gt;2676K(87552K)] 2805K-&gt;2676K(125952K), [Metaspace: 3226K-&gt;3226K(1056768K)], 0.0076292 secs] [Times: user&#x3D;0.03 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">2.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1996K-&gt;32K(38400K)] 4672K-&gt;2708K(125952K), 0.0005201 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 2676K-&gt;2675K(87552K)] 2708K-&gt;2675K(125952K), [Metaspace: 3226K-&gt;3226K(1056768K)], 0.0076530 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">3.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1331K-&gt;96K(38400K)] 4007K-&gt;2771K(125952K), 0.0003721 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 96K-&gt;0K(38400K)] [ParOldGen: 2675K-&gt;2677K(87552K)] 2771K-&gt;2677K(125952K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0027659 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">4.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1331K-&gt;160K(38400K)] 4009K-&gt;2837K(125952K), 0.0005946 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 160K-&gt;0K(38400K)] [ParOldGen: 2677K-&gt;2718K(87552K)] 2837K-&gt;2718K(125952K), [Metaspace: 3488K-&gt;3488K(1056768K)], 0.0065556 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs]</span><br></pre></td></tr></table></figure>
<ul>
<li>结果分析：因为FullGC对线程的停顿时间比较长，未被回收的对象会进入老年代，而新生代中会被清0，因此为了方便，<strong>我们仅关注老年代的情况</strong>。</li>
</ul>
<ol>
<li>程序一开始先进行一次清理，避免不必要的干扰，老年代中有628K：<code>[ParOldGen: 8K-&gt;629K(87552K)]</code>。</li>
<li>随后，我们创建了HashMap实例，实例A和实例B，在这次的GC中，老年代中多了约2MB内存：<code>[ParOldGen: 629K-&gt;2676K(87552K)]</code>。</li>
<li>然后我们将实例A，B放进hashMap对象：<code>map.put(a,b)</code>，put操作会在堆内存中会有额外的开销（会新建一些对象用来进行put操作），因此新生代中会有新内存的使用（但很快就被清理掉了）：<code>[PSYoungGen: 1996K-&gt;32K(38400K)]</code>。我们通过观察老年代：<code>[ParOldGen: 2676K-&gt;2675K(87552K)]</code>，发现实际上这个put操作并没有为HashMap开辟新的内存空间，因为map仅仅只是把内部的引用指向了实例A, B而已。</li>
<li>这一步我们将栈中的引用a释放：<code>a = null;</code>，我们希望看到实例A被回收，但是GC并没有这样做，老年代中的值几乎没有变化：<code>[ParOldGen: 2675K-&gt;2677K(87552K)]</code></li>
<li>为了避免意外，令线程沉睡5秒后，再次清理，发现实例A仍在堆内存中：<code>[ParOldGen: 2677K-&gt;2718K(87552K)]</code>，因此可以判断这造成了一定的内存泄漏。</li>
<li><strong>事实上，HashMap中的某一个特定key很难被清理掉，因为用map.clear()会清理掉整个map。但是HashMap的内存泄漏一般不会很严重，因为只有在极少数情况下，我们才想去手动释放一个key。</strong></li>
</ol>
<h2 id="再次证明内存泄漏的代码"><a href="#再次证明内存泄漏的代码" class="headerlink" title="再次证明内存泄漏的代码"></a>再次证明内存泄漏的代码</h2><p>·　　笔者不太会手动去真正释放HashMap的key，因此，我做了一个实验，先把类A关联上类B，但是不实例化这个B。</p>
<ul>
<li>类A</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> B b;</span><br><span class="line">    <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实验步骤</li>
</ul>
<ol>
<li>实例化A,B得<code>引用a，b</code>，并把<code>a.b = b</code></li>
<li>令 <code>b = null</code>, 再令<code>a.b = null</code>，比较内存变化情况</li>
<li>再令 <code>a = null</code>，查看内存</li>
</ol>
<ul>
<li>实验代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"0.--------------"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"1.--------------"</span>);</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"2.--------------"</span>);</span><br><span class="line">        a.b = b;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"3.--------------"</span>);</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"4.--------------"</span>);</span><br><span class="line">        a.b = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"5.--------------"</span>);</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">0.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 3333K-&gt;776K(38400K)] 3333K-&gt;784K(125952K), 0.0013798 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 776K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;673K(87552K)] 784K-&gt;673K(125952K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0198551 secs] [Times: user&#x3D;0.05 sys&#x3D;0.00, real&#x3D;0.02 secs] </span><br><span class="line">1.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 2713K-&gt;2144K(38400K)] 3387K-&gt;2817K(125952K), 0.0047306 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 2144K-&gt;0K(38400K)] [ParOldGen: 673K-&gt;2718K(87552K)] 2817K-&gt;2718K(125952K), [Metaspace: 3487K-&gt;3487K(1056768K)], 0.0091880 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">2.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1331K-&gt;32K(38400K)] 4050K-&gt;2750K(125952K), 0.0003588 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 2718K-&gt;2718K(87552K)] 2750K-&gt;2718K(125952K), [Metaspace: 3487K-&gt;3487K(1056768K)], 0.0080175 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">3.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 665K-&gt;32K(38400K)] 3383K-&gt;2750K(125952K), 0.0004018 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 2718K-&gt;2718K(87552K)] 2750K-&gt;2718K(125952K), [Metaspace: 3487K-&gt;3487K(1056768K)], 0.0037897 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">4.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 665K-&gt;32K(38400K)] 3383K-&gt;2750K(125952K), 0.0005433 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 2718K-&gt;1694K(87552K)] 2750K-&gt;1694K(125952K), [Metaspace: 3487K-&gt;3487K(1056768K)], 0.0051309 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">5.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 665K-&gt;32K(38400K)] 2359K-&gt;1726K(125952K), 0.0045968 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 1694K-&gt;670K(87552K)] 1726K-&gt;670K(125952K), [Metaspace: 3488K-&gt;3488K(1056768K)], 0.0044260 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 665K-&gt;32K(38400K)] 1335K-&gt;702K(125952K), 0.0003409 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 670K-&gt;670K(87552K)] 702K-&gt;670K(125952K), [Metaspace: 3488K-&gt;3488K(1056768K)], 0.0030132 secs] [Times: user&#x3D;0.05 sys&#x3D;0.00, real&#x3D;0.00 secs]</span><br></pre></td></tr></table></figure>
<ul>
<li>结果分析</li>
</ul>
<ol>
<li>程序一开始先进行一次清理，避免不必要的干扰，老年代中有673K：<code>[ParOldGen: 8K-&gt;673K(87552K)]</code>。</li>
<li>创建了实例A,B后，老年代中多了2MB：<code>[ParOldGen: 673K-&gt;2718K(87552K)]</code></li>
<li>将实例A与实例B关联<code>a.b = b</code>后，堆内存无变化：<code>[ParOldGen: 2718K-&gt;2718K(87552K)]</code></li>
<li>令栈中的<code>引用b=null</code>，发现内存不释放：<code>[ParOldGen: 2718K-&gt;2718K(87552K)]</code>，这与HashMap的内存泄漏完全一致</li>
<li>此时，我们释放掉<code>a.b</code>对实例B的引用<code>a.b = null</code>，发现实例B被清理了：<code>[ParOldGen: 2718K-&gt;1694K(87552K)]</code>，但是实例A仍然占用了1MB的堆内存。</li>
<li>随后我们再次释放<code>引用a = null</code>，发现此时实例A也被清理了：<code>[ParOldGen: 1694K-&gt;670K(87552K)]</code></li>
<li><strong>这个实验证明了：GC Root与实例B之间确实有强引用链，而这个强引用链是 类A成员变量类B的引用提供的</strong></li>
</ol>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　Java的内存管理机制还是很巧妙的，相比C++方便了很多，越往后面学发现这些底层的东西才是java的灵魂的所在啊。</p>
<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote>
<p>请联系邮箱：chenxingyu@bupt.edu.cn</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>ThreadLocal的深入理解</title>
    <url>/2019/09/24/ThreadLocal%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本篇文章深入探讨了ThreadLocal的实现以及使用场景<br>本文章全部基于个人理解，如有错误请邮箱联系本人，多谢</p>
</blockquote>
<a id="more"></a>
<p>·　　最近对多线程，高并发产生了兴趣(<del>其实是面试大厂的时候对性能提升这一块有较高的要求</del> )，以前只会用 <code>synchronized</code> 关键字来实现线程安全，其实这是比较狭隘的，解决线程安全的问题有很多种方法，比如：非阻塞同步(乐观锁机制：在一个可能有线程安全问题的方法中，去判断此操作的结果是否符合预期，如果不符合就放弃此操作的输出，并重新对开始一轮新的操作直到符合预期后再输出)，使用可重入的代码(无法对共享变量进行修改的代码)以及我们今天要提及的<code>ThreadLocal</code>。<br>·　　我写博客主要还是为了给自己看，多了一些自己的理解，但是可能并不精炼。而讲<code>ThreadLocal</code>的好文已经有很多了，这也不是什么新技术，各位还是看比较权威的文章更好一点，我这里实名推荐一篇：<a href="https://blog.csdn.net/fengcaho0616/article/details/79154697" target="_blank" rel="noopener">(转载)ThreadLocal实现原理</a>，<strong>但是我仍要强烈鄙视一下这篇文章的博主，明明是转载的，却不标明出处。</strong></p>
<h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>·　　我在前言里说了辣么多解决线程安全的方法，这时候人本能就会想到两个问题：1. 哪个最好？2. 如果有最好的，还要用其他的干什么。<br>·　　在这里我仅说一下我的理解：</p>
<ol>
<li><strong><code>synchronized</code>方法是最能解决线程安全问题的方法，因为多线程能够安全地操作同一块内存地址的区域，这是其他方法做不到的。</strong> 但是这个方法弊端也很明显，多线程串行执行一个任务，效率极低(当然现在的锁进行了很多的优化措施，至少不会让某个线程在一个任务上长时间阻塞了，这个不是重点)。</li>
<li>非阻塞同步方法解决了线程串行的问题，但是存在ABA隐患(这也不是重点，所谓ABA请自行搜索啦)。</li>
<li><code>ThreadLocal</code>方法，它并不能解决一部分的线程安全问题，因为就算你使用了<code>ThreadLocal</code>，你也无法阻止多线程操作同一块内存空间的隐患，而<code>ThreadLocal</code>却解决了在web领域的一个重大的问题：<strong><font color="red">各线程的独立操作共享数据</font></strong>。</li>
</ol>
<h1 id="ThreadLocal使用场景解释"><a href="#ThreadLocal使用场景解释" class="headerlink" title="ThreadLocal使用场景解释"></a>ThreadLocal使用场景解释</h1><p>·　　很多小伙伴都懵逼了，“独立操作共享数据”是什么意思？其实很简单，我这里的解释需要涉及一点Servlet的知识才可以懂。</p>
<ul>
<li><font color="brown"><strong>ThreadLocal是干嘛的</strong></font><br>·　一句话总结：<code>ThreadLocal实例</code>能够把某个对象与当前<code>thread</code>绑定。于是在任何时刻，当前<code>thread</code>都能通过<code>ThreadLocal</code>获得该对象。</li>
<li><font color="brown"><strong>Servlet的线程安全问题</strong></font><br>·　我们都知道原生的Servlet是单例的，会产生线程安全问题，但是这具体是怎么产生的呢？这里给出一个例子：当线程A和线程B同时去访问同一个Servlet，并同时给<code>request</code>域对象中设置了 相同的键 和 不同的值，这时候，这两个线程就会抢夺资源，导致最终转发给用户的<code>reques</code>t可能并不是用户想要的。</li>
<li><font color="brown">**Servlet安全问题的解决思路**</font>
·　如果，线程A和线程B能够独立操作该Servlet中的`request`对象，操作的方式仅对自己的线程的可见，这样这条线程在整个“客户端--服务端--客户端”的流程中，都能保存数据的一致性。**所以，解决方法就是：每个线程都会创建一个仅对自己可见的`request`代理对象，当线程死亡后，该`request`代理对象也随之销毁。** 而<font color="red">“创建一个仅对自己可见的`request`代理对象”，就需要用到我们的`ThreadLocal`。</font></li>
<li><font color="brown"><strong>ThreadLocal使用场景的思考</strong></font><br>·　可见，<code>ThreadLocal</code>方法，<strong>并不能实现多线程安全操作共享变量(如果不新建Request代理对象，就会依然存在安全问题，因为Request对于多线程而言还是单例的)</strong>，所以我认为它不能解决所有线程安全问题，(但是，它的优势在于：<strong>每个线程看似都能并发地独立”修改”某个共享变量(将<code>thread</code>与这个共享变量的代理对象绑定)，极大地提高时间利用率</strong>。<br>·　关于我的对线程安全的理解，我举个很通俗的比方，耳熟能详的 “生产者 —- 产品 —- 消费者” 问题上，<code>ThreadLocal</code>就不能帮我们解决线程安全问题，因为创建产品的代理对象没有意义。而在上述的Servlet问题中，我们并不关心线程间操作<code>request</code>的顺序是什么样的，我们只需要各线程能且只能看到自己的数据而已。</li>
<li><font color="brown"><strong>个人的理解</strong></font><br>·　根据我的理解，<code>threadLocal</code>被设计出来主要是用来解决并发条件下的数据隔离问题，是用空间换取时间的一种手段。<strong>其实归根结底，threadLocal用来解决Servlet的线程安全问题，理念上就是用了多例模式而已(给共享变量创建副本)，只不过这多出来的‘例’仅对当前线程可见</strong>。不过也不尽然，如果我们非要把与某个线程绑定的对象再与其他线程绑定也是没有问题的，但这就失去了使用<code>threadLocal</code>的意义，我们一般只会把某个对象与特定的一个<code>thread</code>绑定，这样我们就可以通过这个<code>thread</code>在任何时刻访问到这个对象，而其他<code>thread</code>无法做到。这意味着<strong>threadLocal使用场景并不局限在解决线程安全的问题上</strong> ：我们从数据库连接池获取连接的时候，我们只希望一条线程在它的生命周期内只能获取到一个连接对象，且这个连接对象在线程死亡前不会被释放。这就需要我们用threadLocal在当前线程第一次申请连接时，将某个池里的连接与当前线程绑定，以后每次要申请连接，该线程都只会得到这个连接，在线程死亡后，连接被归还。</li>
<li><font color="red">**一句话总结：两种情况下需要用`threadLocal`**</font></li>
</ul>
<ol>
<li>每个线程希望操作自己独有的对象，如<code>Request</code>对象</li>
<li>在一个线程中，同一个对象需要在多个方法中共享，如进行事务管理时，某个业务操作需要用到多个DAO方法，这些方法我们希望使用同一个<code>Connection</code>对象。</li>
</ol>
<h1 id="ThreadLocal结构的简单说明"><a href="#ThreadLocal结构的简单说明" class="headerlink" title="ThreadLocal结构的简单说明"></a>ThreadLocal结构的简单说明</h1><ul>
<li><font color="brown"><strong>什么是ThreadLocal</strong></font><br>·　一句话总结：本地线程副本<br>·　这句话有一层重要含义：<code>threadLocal</code>不特定属于某个线程，它用来管理所有的本地线程。也就是说，<font color="red"><strong>threadLocal本身是一个全局变量，每个线程通过它来获得仅对自己可见的局部变量</strong>。</font><br>·　用刚才Servlet的问题来举个例子（并不准确，但是便于理解）：出现安全问题是因为多线程共同访问了同一个Request对象，但是我们使用了ThreadLocal之后，<strong>每个线程都只会去访问一个<code>ThreadLocal&lt; Request &gt;</code>对象，并从这个对象中获取只对当前线程可见的Request代理对象。</strong><br>·　这意味着，一个线程其实可以从多个ThreadLocal对象中获取相对应的多个值。即：每个线程既可以通过ThreadLocal&lt; Request &gt;对象获得自己的Request代理对象，也可以同时通过<code>ThreadLocal&lt; Connection &gt;</code>对象获取自己的数据库连接对象。只不过这两者的使用理念不同，<strong>前者主要是为了保证多线程之间的数据隔离，后者主要是为了保证对象在单线程中对多方法共享</strong>。</li>
</ul>
<h2 id="对象是如何与线程相绑定的"><a href="#对象是如何与线程相绑定的" class="headerlink" title="对象是如何与线程相绑定的"></a>对象是如何与线程相绑定的</h2><p>·　 一句话总结：通过ThreadLocal的内部类<code>ThreadLocalMap</code>。<br>·　 下面是Thread源码的一部分：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>
<p>·　　由源码可知，在Thread内部有一个由ThreadLocal维护的<code>ThreadLocalMap</code>对象。因此我们可知，实现绑定的关键在于这个<code>ThreadLocalMap</code>类，下面是其一部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">        * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">        * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">        * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">        * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">        * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">           <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">           Object value;</span><br><span class="line"></span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               <span class="keyword">super</span>(k);</span><br><span class="line">               value = v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The table, resized as necessary.</span></span><br><span class="line"><span class="comment">        * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> Entry[] table;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>·　　由源码可知，<strong><code>ThreadLocalMap</code>本质上是一个<code>Entry</code>数组</strong>，Entry又是其内部类。这个内部类的key是一个threadLocal的弱引用(super(k))，value是我们要与当前线程绑定的对象。<br>·　　因此，我们可以简要的画出ThreadLocal的结构图：<br><img src="https://img-blog.csdnimg.cn/20190924110421984.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p>·　在这个图里有几点必要重要的信息：</p>
<ol>
<li>全局的<code>ThreadLocal</code>对象在整个存储的结构中，是作为一个key而存在的，而且还是这个key的弱引用。</li>
<li>Map是每个线程独有的，和全局的ThreadLocal不存在从属关系，也就是说，这个map里可以存放多个不同的ThreadLocal对象作为key，这些ThreadLocal对象对于线程的ThreadLocalMap而言是同级的。(虽然很基础，但是我还是提一嘴，这个内部类是静态的，所以ThreadLocalMap本质上不特定属于某一个ThreadLocal对象)</li>
</ol>
<h2 id="深入理解的注意事项"><a href="#深入理解的注意事项" class="headerlink" title="深入理解的注意事项"></a>深入理解的注意事项</h2><p>·　　在讲ThreadLocal如何进行线程的绑定等一系列操作前，我们还是先缕清一些问题。</p>
<ul>
<li><font color="brown"> <strong>为什么使用弱引用</strong></font><br>·　本人在做了一些研究之后，给大家简单地解释一下：在上图中，我们可以明显的看到<strong>ThreadLocal对象有两条对其的引用，一条来自外界的引用，一条来自内部Entry对其的引用</strong>，因为内部引用的释放我们一般是不愿意去操作的（因为太底层了），因此我们<strong>希望只要释放ThreadLocal的外部引用，这个ThreadLocal实例就能被垃圾回收</strong>。但是，如果内部引用是强引用，那么即使外部引用被释放了，也有一条强引用链：<strong>“CurrentThread Ref —- CurrentThread —- ThreadLocalMap —- Entry —- Entry.key —- ThreadLocal”</strong> 这样我们就无法有效地回收ThreadLocal了，久而久之GC如果一直回收不掉这个实例，而我们又不使用这个ThreadLocal了，那就导致了内存泄漏，很容易造成OutOfMemory异常。<strong>但是，如果这条强引用链最后的引用变成了弱引用，那GC就能顺利释放掉ThreadLocal对象了（GC会回收掉只有弱引用引用的对象）</strong>。如果想进一步了解Java内存泄漏的情况，可以看一下我的另一篇博客：<a href="https://memoforward.github.io/2019/09/25/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AJava%E4%B8%AD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/" target="_blank" rel="noopener">HashMap为什么会出现内存泄漏问题 以及 Java中引用类型的存储位置</a>。</li>
<li><p><font color="brown"><strong>使用了弱应用就不存在内存泄漏的问题了吗</strong></font><br>·　显然不是，从图中很容易看出，即使ThreadLocal对象被释放掉了，与线程绑定的Entry的Value并没有被释放掉，而我们也不会再使用这个Entry了，这同样也是内存泄漏的问题（这里的强引用链就不写了）。为了避免这样的问题，<strong>在释放掉ThreadLocal的外部引用前，我们一般会利用ThreadLocal对象先把这个Entry对Value的强引用释放掉</strong>，这就是在下一章要提到的threadLocal.remove()方法。</p>
</li>
<li><p><font color="brown"><strong>为什么要使用ThreadlLocal进行对象与线程的绑定</strong></font><br>·　仔细想一想，如果让我们自己设计，我们可能会想着直接用线程去绑定某个对象：在线程内部维护一个<code>List&lt;HashMap&lt;T,V&gt;&gt;</code>的结构：T表示要绑定的对象类型，V是这个对象实例的引用。但是仔细一想，这样做实在是不精明，因为首先这个结构过于复杂，其次并非所有线程都需要这个List来保存本地变量副本的(如用synchronized去保证线程安全的情况)，而HashMap的构造必需分配内存空间，当线程量多的时候造成的内存空间浪费将会十分严重。而我们反观ThreadLocalMap的设计，首先结构简单，其实Thread类维护的这个Map采用懒加载的方式，不使用的话就不会在堆空间中分配内存，可谓是鬼斧神工。</p>
</li>
</ul>
<h1 id="ThreadLocal部分源码"><a href="#ThreadLocal部分源码" class="headerlink" title="ThreadLocal部分源码"></a>ThreadLocal部分源码</h1><p>·　　本节内容十分简单，主要涉及到ThreadLocal自身的<strong>set(), get(), remove()</strong> 方法。假设我们的对象为<code>ThreadLocal&lt;?&gt; tl = new ThreadLocal&lt;&gt;();</code> 代码的详解，请参考这篇博客：<a href="https://blog.csdn.net/fengcaho0616/article/details/79154697" target="_blank" rel="noopener">(转载)ThreadLocal实现原理</a>，我这里仅仅只是概括而已。</p>
<ul>
<li><font color="brown"> **tl.set()**</font>

</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>·　　这源码再清晰不过了：获取当前线程对象，并得到其内部维护的map，并把要绑定的对象放入map，其键为this，表示threadLocal对象的弱引用。createMap(t, value)体现了懒加载的特性，源码就不贴了，就是分配内存空间，这里主要看一下<strong>map.set(this，value)</strong>：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">          <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">          <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">          <span class="comment">// path would fail more often than not.</span></span><br><span class="line">          Entry[] tab = table;</span><br><span class="line">          <span class="keyword">int</span> len = tab.length;</span><br><span class="line">          <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">               e != <span class="keyword">null</span>;</span><br><span class="line">               e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">              ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                  e.value = value;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  replaceStaleEntry(key, value, i);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">          <span class="keyword">int</span> sz = ++size;</span><br><span class="line">          <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">              rehash();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure>
<p>·　这里再详细的源码就不贴了，我说明一下map.set做了什么事情：</p>
<ol>
<li><font color="red">这里必须说明一下，threadLocalMap采用线性探测的方式向Entry数组里填入数据</font>，至于什么线性探测这里不细说了，这是解决hash冲突的最简单的方式。</li>
<li>如果Entry数组中有key（代码里是k）与set的key一样，则直接用新value覆盖掉原value</li>
<li>如果发现有Entry数组中无效槽<code>k==null</code>，则替换掉这个无效槽，并把key，value填入</li>
<li>若Entry数组中所有槽均有效，则在连续段末尾处放入key，value，随后检测一下这个Entry数组是否需要扩容。</li>
<li>至于<code>key.threadLocalHashCode</code>，这是一个魔数，这里不细说。数学是美妙的，一般底层程序中经常会出现类似的魔数。</li>
</ol>
<ul>
<li><font color="brown"> **tl.get()**</font>

</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>·　　这个代码就更简单了：当前线程的Map通过这个threadLocal对象获得了与其绑定的值，这与我们第二节的理解完全一致，<strong>不过再强调一遍加深印象：一个threadLocal实例只能保证一个对象与当前线程绑定，这个线程要与多个对象绑定，最好把这些对象封装起来(比如Servlet的域对象们，SpringMVC的源码似乎就是这么做的)。</strong><br>·　　如果这个map还没有初始化的话，会执行：<code>setInitialValue();</code>，该操作新建一个表，并把此null赋值给<code>Entry.value</code></p>
<ul>
<li><font color="brown"> **tl.remove()**</font>

</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>·　　这里同样不继续看<code>m.remove(this)</code>的源码了，这里的remove主要就干一件事：<code>Entry.value = null</code>。保证了这个Value对象能被垃圾回收器及时回收。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　ThreadLocal的设计十分巧妙，通过自身的对象去实现线程与数据之间的绑定，而这个绑定又以自己的弱应用作为key，这极大程度上简化了本应该很复杂的数据结构，因为这巧妙地解决了与线程绑定的对象数据类型不确定这个问题，否则就要用我上面提到的<code>List&lt;HashMap&lt;T,V&gt;&gt;</code>来存储。我仍不是很清楚设计师是怎么想出来这种设计模式的，也不知道这种设计理念是什么，总之路漫漫其修远兮，吾将上下而求索。</p>
<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote>
<p>请联系邮箱：chenxingyu@bupt.edu.cn</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>并发</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringJDBC模板的使用以及实现事务管理</title>
    <url>/2019/09/04/SpringJDBC%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文主要涉及如下知识点：</p>
<ol>
<li>SpringJDBC模板实战</li>
<li>Spring基于XML配置实现事务管理</li>
<li>Spring基于注解配置实现事务管理</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="SpringJDBC模板"><a href="#SpringJDBC模板" class="headerlink" title="SpringJDBC模板"></a>SpringJDBC模板</h1><p>·　　当还未接触到SpringJDBC模板以及Mybatis等框架时，我们一直在使用DButils来对JDBC进行封装操作，SpringJDBC模板和DButils的操作可以说是十分相似。所以我们操作起来几乎没有难度，相比DBUtils需要额外引入连接池才可以使用，Spring自己内置了连接池（<font color="red">DriverManagerDataSource</font>），可以说是十分方便。<br>·　　使用SpringJDBC模板需要的jar包是：<strong>spring-jdbc</strong><br>·　　与数据库交互需要使用:<strong>mysql-connection-java</strong></p>
<h2 id="使用SpringJDBC模板"><a href="#使用SpringJDBC模板" class="headerlink" title="使用SpringJDBC模板"></a>使用SpringJDBC模板</h2><p>·　　使用SpringJDBC模板特别简单，只需要两个步骤：</p>
<ol>
<li>配置DriverManagerDataSource连接池，并注入jdbcTemplate对象</li>
<li>使用JdbcTemplate对象来进行数据库的交互<ul>
<li>JdbcTemplate的使用几乎和dbutils一样，查询用query，增删改用update，参数也是差不多。其中查询操作，DButils使用的返回值接口是ResultSetHandle&lt; T &gt;,而Spring所用的接口是RowMapper&lt; T &gt;，我们一般用其实现类<font color="red">BeanPropertyRowMaper&lt; T &gt; </font></li>
</ul>
</li>
</ol>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul>
<li>引入jar包,Maven依赖如下</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用于Spring整合tesng测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.testng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testng<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用SpringJDBCTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>把DataSource和jdbcTemplate交给SpringIOC去管理（非自己定义的bean用xml创建），同时开启组件扫描，xml完整配置如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contxt</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contxt:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springaop"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>创建数据库springaop，并创建客户表t_account</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>aname</th>
<th>money</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>cxy</td>
<td>2000.0</td>
</tr>
<tr>
<td>2</td>
<td>lhw</td>
<td>2000.0</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>编写Account端的操作，只编写通过客户姓名查询以及更新客户的操作（因为事务管理要用）</li>
</ul>
<p><strong>//AccountDao</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.memoforward.domain.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>//AccountDaoImpl</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>...;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"accountDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; aList = jdbcTemplate.query(<span class="string">"select * from t_account where aname = ?"</span>, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account<span class="class">.<span class="keyword">class</span>), <span class="title">accountName</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(aList.size() != <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"查询失败..."</span>);</span><br><span class="line">        <span class="keyword">return</span> aList.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update t_account set aname=?,money=? where id = ?"</span>,account.getAname(),account.getMoney(),account.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>`　　可见，SpringTemplate还是相当简单的，没有什么特殊的思想，对开发来说并没有方便很多，这里就不进行测试了。<br>·　　<font color="red">这里注意一下：</font><del>JDBC实现了threadLocal，所以即使它是单例的，也是线程安全的 (说实话我不是很懂….，以后成长起来再来解释一下)</del>，它会根据当前的线程去取数据库的连接。</p>
<h1 id="Spring实现事务管理"><a href="#Spring实现事务管理" class="headerlink" title="Spring实现事务管理"></a>Spring实现事务管理</h1><p>·　　有关事务管理的内容，不是本博客的重点，本篇文章只是略微介绍一下Spring事务管理的使用（因为这个是相当的方便）。Spring事务管理是基于AOP的，用来增强业务层的业务逻辑，有兴趣可以参考我关于AOP的教程：<a href="https://memoforward.github.io/2019/08/31/SpringIOC%E5%AE%9E%E6%88%98%EF%BC%88xml-%E6%B3%A8%E8%A7%A3%EF%BC%89/" target="_blank" rel="noopener">SpringAOP实战</a>。</p>
<h2 id="进行事务管理的原因"><a href="#进行事务管理的原因" class="headerlink" title="进行事务管理的原因"></a>进行事务管理的原因</h2><p>·　　虽然不着重讲事务管理的细节，但是这里给出一个特别经典的案例：<strong>转帐案例</strong>，来表明事务管理的重要性。<br>·　　我们在业务层实现一个转账方法，并设置一点小细节：模拟在转账过程中的停电事件，停电的时间点在：甲方已经转账成功，但乙方还未收到钱。停电事件用一个flag控制。<br>业务层实现如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>...;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Double money, <span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">        Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">        source.setMoney(source.getMoney() - money);</span><br><span class="line">        target.setMoney((target.getMoney() + money));</span><br><span class="line">        accountDao.update(source);</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"断电了...."</span>);</span><br><span class="line">        accountDao.update(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果我们设置flag为true，并进行转账：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTranser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    accountService.transfer(<span class="string">"cxy"</span>,<span class="string">"lhw"</span>,<span class="number">1000.0</span>,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数据库里的金额就变成了：可见1号的钱少了，结果2号的钱没多。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>id</th>
<th>aname</th>
<th>money</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>cxy</td>
<td>1000.0</td>
</tr>
<tr>
<td>2</td>
<td>lhw</td>
<td>2000.0</td>
</tr>
</tbody>
</table>
</div>
<p>造成这种现象的原因很简单，因为<B>：业务层会调用持久层（DAO）的方法，默认情况是：每次dao层的方法执行结束之后，事务都被自动提交了。</B><br>·　　因此，就需要对这个转账方法进行事务的管理：开启事务，如果异常就回滚，不异常就用提交，最后是释放连接。我在之前的文章里，用动态代理实现了事务管理，有兴趣可以参考一下：<a href="https://memoforward.github.io/2019/09/01/Java%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%A7%A3%E9%87%8A/" target="_blank" rel="noopener">Java两种动态代理实战+动态代理死循环的解释</a>。<br>·　　因为Spring中声明事务管理是基于aop的，所以很显然，事务管理的内容必然就是一个advice通知。而相比普通的切面，事务管理很常用，因此spring就自己把其封装了。</p>
<h2 id="xml的事务管理配置"><a href="#xml的事务管理配置" class="headerlink" title="xml的事务管理配置"></a>xml的事务管理配置</h2><ul>
<li>首先还是要引入相应的jar包：<strong>spring-tx和aspectjweaver</strong>，一个是事务管理的依赖，一个是用于识别切入点表达式。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置步骤：</li>
</ul>
<ol>
<li>配置事务管理器(DataSourceTransactionManagement)并注入Datasource。（事务管理器的接口是PlatformTransactionManagement）</li>
<li>配置事务通知&lt; tx:advice &gt;并将事务管理器添加至标签属性</li>
<li>配置aop，写切入点表达式并用&lt; aop: advisor &gt;引入事务通知</li>
<li>在事务通知下配置子标签&lt; tx:attributes &gt; ，在&lt; tx:attrributes &gt;标签下用&lt; tx:method &gt;配置业务方法（只有配置了切入点才能知道增强哪个包的方法，因此这步在最后）</li>
</ol>
<ul>
<li>xml配置如下：注意事务管理是业务层的和持久层没有关系。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contxt</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contxt:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">&lt;!-- 1.配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManagement"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">&lt;!-- 2.配置事务通知并引入事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span>  <span class="attr">transaction-manager</span>=<span class="string">"txManagement"</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!-- 4.配置事务增强属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        	<span class="comment">&lt;!-- 6.对不同的方法进行不同的事务管理--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 3.开启aop并引入事务通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.memoforward.service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springaop"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>关于&lt; tx:method &gt;的属性：这个标签是针对不同的方法进行不用的事务增强而设计出来的，spring为其提供了6种属性：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>isolation</td>
<td>用于指定事务的隔离级别。默认是数据库的默认隔离级别。</td>
</tr>
<tr>
<td>propagation</td>
<td>用于指定事务的传播行为。默认值是：REQUIRED，表示一定会开启事务。也有SUPPORTS表示支持当前事务（如果当面没有事务，则不开启事务），一般用于查询方法。</td>
</tr>
<tr>
<td>read-only</td>
<td>用于指定事务是否只读。只有查询方法才能是true。</td>
</tr>
<tr>
<td>timeout</td>
<td>用于指定事务的超时时间，默认是-1，表示永不超时。设置的单位级别是秒。</td>
</tr>
<tr>
<td>rollback-for</td>
<td>用于指定一个异常，当产生该异常时，事务回滚，产生其他异常，事物不回滚。不设置则所有异常都回滚 。</td>
</tr>
<tr>
<td>no-rollback-for</td>
<td>用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常，事物回滚。不设置则所有异常都回滚 。</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>结果：这就不进行测试了，因为非常简单。当配置了如上的事务后，在“转账”操作未结束的时候，所有的dao方法都不会提交，因此保证了转账的安全性。</li>
</ul>
<h2 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h2><p>·　　Spring事务管理同样也可以进行注解配置，注解配置比较简单，但是有不方便的地方。<br>·　　Spring进行注解配置的步骤是：</p>
<ol>
<li>配置事务管理器</li>
<li>开启Spring对注解配置事务的支持（&lt; tx:annotation-driven &gt;）,纯注解配置的话在配置类上用@EnableTransactionManagement来开启。</li>
<li>在需要事务支持的地方使用@Transactional，其属性就是上述标签&lt; tx:method &gt; 的属性。这个注解用在类上表示此种事务对该类的所有方法都生效；用在方法上表示：此种事务仅对该方法生效。<font color="red">注意：</font>我还不太清楚如果使用该注解对不同的事务管理器进行操作。</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contxt</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contxt:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManagement"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"txManagement"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springaop"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其业务层改为如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(readOnly = <span class="keyword">true</span>, propagation = Propagation.SUPPORTS)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(readOnly = <span class="keyword">false</span>, propagation = Propagation.REQUIRED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Double money, <span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">        Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">        source.setMoney(source.getMoney() - money);</span><br><span class="line">        target.setMoney((target.getMoney() + money));</span><br><span class="line">        accountDao.update(source);</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"断电了...."</span>);</span><br><span class="line">        accountDao.update(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果：进行了该注解配置后，转账操作也正常回滚了。</li>
</ul>
<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>·　　Spring声明式事务管理十分有用，用起来很方便，就是需要记忆的部分有点多，不过孰能生巧，多练多写才是王道。这里Spring有关业务层的内容就全部结束。我最近也变的很忙，关于java后台的学习笔记也要稍微停滞一段时间。闲暇之余可能会更新一些有关深度学习的内容（<del>为了毕业</del>），加油吧。</p>
<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote>
<p>请联系邮箱：chenxingyu@bupt.edu.cn</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringAOP实战</title>
    <url>/2019/09/02/SpringAOP%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文主要涉及如下知识点</p>
<ol>
<li>SpringAOP的基本概念</li>
<li>基于XML配置的SpringAOP实战</li>
<li>基于注解配置的SpringAOP实战</li>
<li>环绕通知</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h1><p>·　　AOP(Aspect Oriented Programming)面向切面编程，是OOP面向对象编程的升级，AOP是基于OOP的。OOP比较好理解，生活中万物都是对象，但是AOP乍一看不是很好理解。不过没关系，我稍微一点拨，肯定就能懂。<br>·　　说到底，其实就是“切面”这个概念我们不熟悉，我的理解是这样的：<strong>切面是某种对象的共同特征</strong>。什么意思呢？我举个简单的例子：我们一生中会玩很多的游戏，每个游戏都在不同的平台，那我们每次玩游戏，都要登录某个平台。<strong>面向对象编程的思维是这样的</strong>：我们这个人，就是一个对象，而我们玩游戏，就是这个对象使用了某种方法，所以在编程时我们把<B>“人”这个概念抽取成了对象，把“玩游戏”这个概念抽取成一个个不同的方法</B>。而在这个基础上，<strong>面向切面的编程方式</strong> 被提出了，因为我们发现，我们有无数种对应玩游戏的方法，但是每一种方法我们都需要进行登录的操作，所以我们把<B>“登录”这个操作抽取出来，称作是所有”玩游戏”方法的切面，而每个玩游戏的方法，就是一个个切入点</B>。<br>·　 　可见，“登录”是所有“玩游戏”方法的共同特征，所以切面这个概念不如对象一般直观，因为，所有的切面都是人为抽取出来的，具有一定的思考性。而<strong>面向切面编程</strong>最重要的两个优势在于：1.可以简化代码量；2.可以让业务代码仅关注业务逻辑，使代码结构更清晰。<br>·　　不管是哪一种优势，对于开发来说，都是至关重要的。</p>
<h1 id="切面的一些专业术语"><a href="#切面的一些专业术语" class="headerlink" title="切面的一些专业术语"></a>切面的一些专业术语</h1><p>·　　SpringAOP的实现是基于动态代理的，本人写过一遍有关动态代理的教程：<a href="https://memoforward.github.io/2019/09/01/Java%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%A7%A3%E9%87%8A/" target="_blank" rel="noopener">Java两种动态代理实战+动态代理死循环的解释</a>。<br>·　　要会看的懂SpringAOP的相关文档就必须懂有关切面的相关术语，<strong>首先Aspect就是切面</strong>的意思。这<del>个要是不知道，就快先去把6级考了再说。**</del><br><strong>术语如下：</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>术语</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>joinpoint 连接点</td>
<td>可以被拦截到的方法，但不一定会被增强</td>
</tr>
<tr>
<td>pointcut 切入点</td>
<td>被增强的方法（可见切入点一定是连接点，而反之则不然）</td>
</tr>
<tr>
<td>advice 通知（增强）</td>
<td>指在拦截到切入点后，如何增强某个方法</td>
</tr>
<tr>
<td>target</td>
<td>指被代理的对象</td>
</tr>
<tr>
<td>weaving 织入</td>
<td>指一个过程：增强某个类并形成代理类的过程</td>
</tr>
<tr>
<td>proxy 代理</td>
<td>一个类被织入后，就生成了一个代理类</td>
</tr>
<tr>
<td>aspect 切面</td>
<td>指切入点和通知的结合</td>
</tr>
</tbody>
</table>
</div>
<p>·　　如果你能把上述玩游戏的例子和这里的术语对应上，那你术语部分就过关啦！<br><strong>其中advice术语是实现aop的关键，其有五种通知类型：</strong></p>
<ul>
<li>１．前置通知（before）：只在原方法之前调用的增强</li>
<li>２．后置通知（after-returning）：原方法完成之后调用的增强</li>
<li>３．异常通知（after-throwing）：原方法出异常后调用的增强</li>
<li>４．最终通知（after）：不管怎么样都会调用的增强，最后才会调用</li>
<li>５．环绕通知（around）：通过写代码来实现对切入点的管理（以上一般都是用配置，来决定顺序），环绕通知一般用于注解开发。</li>
</ul>
<h1 id="SpringAOP实战"><a href="#SpringAOP实战" class="headerlink" title="SpringAOP实战"></a>SpringAOP实战</h1><p>·　　本来想搞利用aop实现事务的管理的，不过既然在开头用了玩游戏的例子，那么索性，这里的案例就用玩游戏了。<br>·　　<strong>需求如下</strong>：玩家只需要关注玩游戏就行。代理类的任务在于：在玩游戏<strong>之前实现登录操作</strong>，游戏结束<strong>后执行退出操作</strong>，如果玩游戏途中<strong>出现了游戏BUG，就执行回档操作（异常）</strong>，最终不管怎么样，玩游戏是要钱的，<strong>最后要执行扣钱操作。</strong></p>
<h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>·　　引入jar包，<strong>aop需要的jar包是aspectjweaver</strong>，用于解析切入点表达式（下文会讲）以及spring-aop（这个一般引入spring-context依赖就会自己引入了），然后什么ioc的包等等，我就不说了，这次案例会用到一点点的IOC的知识，如果不会，可以参考我的IOC教程<a href="https://memoforward.github.io/2019/08/31/SpringIOC%E5%AE%9E%E6%88%98%EF%BC%88xml-%E6%B3%A8%E8%A7%A3%EF%BC%89/" target="_blank" rel="noopener">SpringIOC实战（xml+注解）</a>。</p>
<ul>
<li>依赖如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置玩家类(由Spring进行管理)<br>可见我们希望切面能增强所有玩游戏的方法，而不增强吃饭这个方法，其中我们看见玩LOL时会出现异常。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.player;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playLOL</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩英雄联盟..."</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"LOL崩溃了...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playDota2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩Dota2..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playWOW</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩魔兽世界..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playTaiWu</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩太吾绘卷..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"游戏玩累了，吃饭..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>配置通知类（由Spring进行管理）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"playerAdvice"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerAdvice</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.登录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---1.游戏登录---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.退出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---2.游戏退出---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3/异常回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---3.游戏回档---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.扣钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loseMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---4.游戏扣费---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="用XML配置切面"><a href="#用XML配置切面" class="headerlink" title="用XML配置切面"></a>用XML配置切面</h2><p>·　　使用SpringAOP需要在xml文件中引入aop的约束，这里就不贴了。<br>·　　关于XML配置，共有如下的几个标签需要用到。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标签名</th>
<th>属性</th>
<th>作用</th>
<th>层级</th>
</tr>
</thead>
<tbody>
<tr>
<td>aop:config</td>
<td>无</td>
<td>开启aop的控制</td>
<td>1</td>
</tr>
<tr>
<td>aop:pointcut</td>
<td>id：指切入点表达式的id；expression：写切入点表达式</td>
<td>告诉切面将增强哪些方法（切入点）</td>
<td>2或3</td>
</tr>
<tr>
<td>aop:aspect</td>
<td>id：该切面的id；ref：该切面对应的通知类</td>
<td>声明一个切面</td>
<td>2</td>
</tr>
<tr>
<td>aop : before</td>
<td>method：该前置通知对应在通知类中的方法；pointcut-ref：切入点表达式id / pointcut：切入点表达式</td>
<td>声明一个前置通知</td>
<td>3</td>
</tr>
<tr>
<td>aop : after-returning</td>
<td>和上面类似</td>
<td>声明一个后置通知</td>
<td>3</td>
</tr>
<tr>
<td>aop : after-throwing</td>
<td>和上面类似</td>
<td>声明一个异常通知</td>
<td>3</td>
</tr>
<tr>
<td>aop : after</td>
<td>和上面类似</td>
<td>声明一个最终通知</td>
<td>3</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><strong>有关切入点表示的补充</strong><br>·　 切入点表达式有关键字：execution。在关键字内部写表达式，规则是：<strong>（访问修饰符 返回值 全限定类名.方法名）</strong>，且不同的execution之间可以用<strong>and、or、！</strong>等关键字来增强表达式的逻辑。</li>
</ul>
<p><strong>举个例子</strong>：如果要切入点要选Player类中的playLOL方法，则表达式可以这么写：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.memoforward.player.Player.playLOL())</span><br></pre></td></tr></table></figure>
<p>·　　显然这么写太复杂了，因此有如下的简化措施：</p>
<ol>
<li>访问修饰符可省略</li>
<li>返回值可以用通配符<B> * </B> 表示任意返回值类型</li>
<li>包名可以用 <B> * </B>表示任意一个包；用 <B> *. </B>表示当前包及其所有子包</li>
<li>类名和方法名都可以用<B> * </B>表示任意类和任意方法</li>
<li>可用 <B>(．.) </B>表示任意参数和任意参数类型（如果不想用用任意类型，基础类型可以直接写，引用类型用 ‘包名.类名’ 的方式）</li>
</ol>
<p>`　　因此有全通配写法：该项目下所有包的所有方法（不推荐使用）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">execution(* *..*.*(..))</span><br></pre></td></tr></table></figure>
<ul>
<li>一般情况下：我们只需要切到业务层实现类下的所有方法就可以了。</li>
</ul>
<h2 id="xml配置文件如下"><a href="#xml配置文件如下" class="headerlink" title="xml配置文件如下"></a>xml配置文件如下</h2><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    	<span class="comment">&lt;!--&lt;aop:pointcut id="pt2" expression="..."/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"playerAdvice"</span> <span class="attr">ref</span>=<span class="string">"playerAdvice"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.memoforward.player.*.*(..)) and !execution(* com.memoforward.player.*.eat(..))"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"login"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"quit"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"rollback"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"loseMoney"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意事项：</strong><ol>
<li>用了两个execution语句实现了增强 除了eat方法外的所有方法。</li>
<li>注意切入点表达式的位置：如果在&lt; aop: aspect &gt;标签内，则这个表达式只对这个切面生效；如果在切面标签外，则对所有切面生效，但其必须要声明在切面之前。</li>
</ol>
</li>
</ul>
<h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:beans.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testSpringAOP</span> <span class="keyword">extends</span> <span class="title">AbstractTestNGSpringContextTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Player player;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAOP01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player.eat();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playDota2();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playTaiWu();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playWOW();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playLOL();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试结果如下：可见除了eat方法，其他方法都被增强了，而且出异常的LOL也成功进行了游戏回档。</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">游戏玩累了，吃饭...</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩Dota2...</span><br><span class="line">--<span class="number">-2.</span>游戏退出---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩太吾绘卷...</span><br><span class="line">--<span class="number">-2.</span>游戏退出---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩魔兽世界...</span><br><span class="line">--<span class="number">-2.</span>游戏退出---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩英雄联盟...</span><br><span class="line">--<span class="number">-3.</span>游戏回档---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: LOL崩溃了....</span><br></pre></td></tr></table></figure>
<h2 id="基于注解的AOP开发"><a href="#基于注解的AOP开发" class="headerlink" title="基于注解的AOP开发"></a>基于注解的AOP开发</h2><ul>
<li>基于注解的开发有两个步骤：</li>
</ul>
<ol>
<li>在配置文件中开启aop自动代理权限</li>
<li>配置切面的通知类</li>
</ol>
<ul>
<li>配置文件开启权限</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>配置切面通知类：@Aspect；@Pointcut；以及各种通知注解，很简单。<br><strong>注意：切入点表达式需要把 and 换成 &amp;&amp;</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"playerAdvice02"</span>)</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerAdvice02</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.memoforward.player.*.*(..)) &amp;&amp; !execution(* com.memoforward.player.*.eat(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.登录</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---游戏登录---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.退出</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---游戏退出---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3/异常回滚</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---游戏回档---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.扣钱</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loseMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---游戏扣费---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试如下：此时已经换成了PlayerAdvice02切面。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> ...;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:beans.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testSpringAOP</span> <span class="keyword">extends</span> <span class="title">AbstractTestNGSpringContextTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Player player;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAOP</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player.eat();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playTaiWu();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playLOL();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>结果如下</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">游戏玩累了，吃饭...</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩太吾绘卷...</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">--<span class="number">-2.</span>游戏退出---</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩英雄联盟...</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">--<span class="number">-3.</span>游戏回档---</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: LOL崩溃了....</span><br></pre></td></tr></table></figure>
<ul>
<li><font color="red"><b>问题（该问题已经被修复，注解可以放心使用）</b></font><br>·　　<del>仔细一点就能发现，<strong>最终通知和后置通知的顺序反了</strong>，这是注解开发的一个大问题，目前还没有被修复，</del>因此如果要用注解开发的话，一般使用<strong>环绕通知</strong>的方式，所谓环绕通知和动态代理的实现方法基本没什么区别。下面将简单介绍一下：</li>
</ul>
<h2 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h2><p>·　　环绕通知和动态代理的内部几乎是一样的写法，不同的点在于：动态代理的参数包含了被代理类的字节码对象；而在环绕通知中，因为Spring已经管理的被代理的类，因此就不必我们手动提供了，取而代之的，是<strong>Spring提供的的一个接口：ProceedingJoinPoint</strong>，此接口有两个方法，一个是获取被代理类方法的参数，一个是调用被代理类的方法。<br>代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"pt1()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">playerAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        login();</span><br><span class="line">        obj = pjp.proceed(args);</span><br><span class="line">        quit();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    	<span class="comment">//注意pjp对象的方法需要用Throwable来处理异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        rollback();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(throwable);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        loseMoney();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试结果如下：可见执行顺序已经恢复正常</li>
</ul>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">游戏玩累了，吃饭...</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩太吾绘卷...</span><br><span class="line">--<span class="number">-2.</span>游戏退出---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩英雄联盟...</span><br><span class="line">--<span class="number">-3.</span>游戏回档---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: java.lang.RuntimeException: LOL崩溃了....</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　SpringAOP说难不难，但是重要的是这种面向切面的编程思想以及动态代理。Spring还剩最后一项事务管理。我会在下一次博客把它补上。</p>
<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote>
<p>请联系邮箱：chenxingyu@bupt.edu.cn</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java两种动态代理实战+动态代理死循环的解释</title>
    <url>/2019/09/01/Java%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%A7%A3%E9%87%8A/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本篇文章主要涉及两个知识点</p>
<ol>
<li>Java中基于接口和子类的动态代理实现</li>
<li>动态代理死循环的出现原因以及解决方法</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="动态代理的概念和作用"><a href="#动态代理的概念和作用" class="headerlink" title="动态代理的概念和作用"></a>动态代理的概念和作用</h1><p>·　　动态代理是SpringAOP的实现方式，因此要深入理解SpringAOP就必须要深入理解动态代理机制。<br>·　　<strong>什么是代理</strong>：谈动态的代理，不得不谈代理概念，而<strong>动态代理就是在运行阶段创建代理对象（通过字节码创建，十分有效率）</strong>。代理可以理解成中介的意思，当我们买电脑的时候不去电脑的生产厂商买，而是去淘宝买的时候，这里的淘宝就是代理，其代理的对象就是电脑厂商。当有了代理之后，用户一般就只和代理交互了。<br>·　　代理最大的两个作用就是：１．在不改变原来对象的代码上，对该对象进行增强。２．业务层的对象只需要考虑业务逻辑，而不必考虑其他的逻辑。举个简单的例子：我们在操作数据库的时候，都需要进行事务的管理，而事务的逻辑和业务层的逻辑显然是不同的，因此可以用代理的模式去实现两个逻辑的分离。<br>·　　<strong>本博客的案例就是</strong>：用动态代理的方式去增强业务层的方法，实现业务层的事务管理。</p>
<p>·　　要看死循环问题的朋友请戳：<a href="#pro">动态代理的死循环问题</a></p>
<h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="动态代理的实现方式"><a href="#动态代理的实现方式" class="headerlink" title="动态代理的实现方式"></a>动态代理的实现方式</h2><p>·　　动态代理有两种实现方式：</p>
<ol>
<li>第一种是JDK提供的基于接口的动态代理，要求被代理的类必须至少实现一个接口</li>
<li>第二种是第三方cglib提供的基于子类的动态代理，要求被代理类不能被final修饰（因为被final修饰的类不能被继承）导入cglib依赖(asm包)。</li>
</ol>
<h2 id="编写必要的类"><a href="#编写必要的类" class="headerlink" title="编写必要的类"></a>编写必要的类</h2><ul>
<li>1．业务层接口和实现类：该类的编写与<a href="https://memoforward.github.io/2019/08/31/SpringIOC%E5%AE%9E%E6%88%98%EF%BC%88xml-%E6%B3%A8%E8%A7%A3%EF%BC%89/" target="_blank" rel="noopener">SpringIOC实战（xml+注解）</a>中StudentService一模一样。这里就不贴了。<br>使用Spring注入数据源和QuerryRunner，配置文件如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springioc"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>2．线程绑定获取连接的工具类</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource ds;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection conn = tl.get();</span><br><span class="line">        <span class="keyword">if</span>(conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn = ds.getConnection();</span><br><span class="line">                tl.set(conn);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>3．有关事务管理的类</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入连接工具</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ConnectionUtils connUtils;</span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection conn = connUtils.getConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提交</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connUtils.getConnection().commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connUtils.getConnection().rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            connUtils.getConnection().close();</span><br><span class="line">            <span class="comment">//线程解绑</span></span><br><span class="line">            connUtils.removeThread();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用动态代理实现业务管理"><a href="#使用动态代理实现业务管理" class="headerlink" title="使用动态代理实现业务管理"></a>使用动态代理实现业务管理</h1><h2 id="不使用代理如何实现？"><a href="#不使用代理如何实现？" class="headerlink" title="不使用代理如何实现？"></a>不使用代理如何实现？</h2><ul>
<li>如果不使用动态代理，业务层的代码是这样写的（注入了txManager）：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">findAllStudents</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        txManager.beginTransaction();</span><br><span class="line">        List&lt;Student&gt; stuList = stuDao.findAllStudents();</span><br><span class="line">        txManager.commit();</span><br><span class="line">        <span class="keyword">return</span>  stuList;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        txManager.rollback();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        txManager.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们希望在业务层只实现业务层的逻辑，即：我们希望只写这样的代码：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">findAllStudents</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> stuDao.findAllStudents();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>·　这就需要我们使用动态代理的技术，在不改变源码的基础上对Service类进行增强了。</p>
<h2 id="基于接口的动态代理的实现"><a href="#基于接口的动态代理的实现" class="headerlink" title="基于接口的动态代理的实现"></a>基于接口的动态代理的实现</h2><ul>
<li>1．使用<strong>Proxy类中的newProxyInstance静态方法</strong>来创建代理，被代理类至少要实现是一个接口。</li>
<li>2．该方法有三个参数一个返回值：</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th>如何构造</th>
</tr>
</thead>
<tbody>
<tr>
<td>Classloader</td>
<td>用于加载代理对象的字节码，与被代理对象的类加载器相同</td>
<td>被代理对象.getClass().getClassLoader()</td>
</tr>
<tr>
<td>Class[]</td>
<td>用于让代理对象实现被代理对象的所有方法</td>
<td>被代理对象.getClass().getInterfaces()</td>
</tr>
<tr>
<td>InvocationHandle接口对象</td>
<td>用代理对象对原对象的方法进行增强</td>
<td><strong>实现该接口对象的invoke方法来对原方法进行增强（一般用匿名内部类的方式实现）</strong></td>
</tr>
<tr>
<td>返回值 return</td>
<td>返回一个Object对象，需要强转成被代理的对象类型。<del>可以把代理对象看成是一个与被代理对象实现相同接口的增强类（可以这么理解，但实际上还有些区别）</del></td>
<td>\</td>
</tr>
</tbody>
</table>
</div>
<p>·　　其中，invoke方法有三个入参，分别是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object proxy</td>
<td>代理对象的引用</td>
</tr>
<tr>
<td>Method method</td>
<td>通过字节码获得的需要被增强的方法的引用</td>
</tr>
<tr>
<td>Object[] args</td>
<td>被增强的方法的入参</td>
</tr>
</tbody>
</table>
</div>
<p><strong>值得注意的是：</strong> 通过method.invoke调用的方法，始终会返回一个Object类型。也就是说，如果原方法返回void就放回null，如果原方法放回基本类型，就返回包装类。</p>
<ul>
<li>实现动态的ServiceProxy类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProxy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentService stuService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TransactionManager txManager;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//类似用&lt;bean factory-bean&gt;来创建bean</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"stuServiceProxy"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentService <span class="title">getStuServiceProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (StudentService)Proxy.newProxyInstance(</span><br><span class="line">        		stuService.getClass().getClassLoader(), </span><br><span class="line">        		stuService.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object obj = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                        	<span class="comment">//开启事务</span></span><br><span class="line">                            txManager.beginTransaction();</span><br><span class="line">                            <span class="comment">//执行业务逻辑</span></span><br><span class="line">                            obj = method.invoke(stuService,args);</span><br><span class="line">                            <span class="comment">//提交事务</span></span><br><span class="line">                            txManager.commit();</span><br><span class="line">                            <span class="keyword">return</span> obj;</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        	<span class="comment">//异常回滚</span></span><br><span class="line">                            txManager.rollback();</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        	<span class="comment">//释放连接</span></span><br><span class="line">                            txManager.release();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>为了观测到业务层的方法被执行，将业务层代码改为：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">findAllStudents</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"方法被执行了...."</span>);</span><br><span class="line">    <span class="keyword">return</span> stuDao.findAllStudents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试：注入代理的对象的bean之后就可以直接使用了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpringAnnotation</span> <span class="keyword">extends</span> <span class="title">AbstractTestNGSpringContextTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"stuServiceProxy"</span>)</span><br><span class="line">    StudentService stuServiceProxy;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProxy</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       stuServiceProxy.findAllStudents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试结果如下：可见事务管理被执行了，而业务层的代码并没有改变</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开启事务...</span><br><span class="line">方法被执行了....</span><br><span class="line">提交事务...</span><br><span class="line">释放连接...</span><br></pre></td></tr></table></figure>
<h2 id="基于子类的动态代理实现"><a href="#基于子类的动态代理实现" class="headerlink" title="基于子类的动态代理实现"></a>基于子类的动态代理实现</h2><p>·　　基于接口的代理要求被代理类必须实现至少一个接口，多多少少有些不方便。因此才有了这种基于接口的代理实现。<br>·　　其实，创建代理的方式和基于接口的代理步骤极为相似：</p>
<ul>
<li>1．使用<strong>Enhancer类的create静态方法</strong>创建代理对象</li>
<li>2．该方法有三个参数一个返回值</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>作用</th>
<th>如何构造</th>
</tr>
</thead>
<tbody>
<tr>
<td>Class</td>
<td>获得代理对象的字节码，有了字节码被代理类的所有信息都能得到</td>
<td>被代理对象.getClass()</td>
</tr>
<tr>
<td>Callback接口对象</td>
<td>用代理对象对原对象的方法进行增强</td>
<td><strong>一般实现其子类接口MethodIntereptor方法拦截器（实现有intercept方法）</strong></td>
</tr>
<tr>
<td>返回值 return</td>
<td>返回一个Object对象，需要强转成被代理的对象类型。</td>
<td>/</td>
</tr>
</tbody>
</table>
</div>
<p>·　　其中，intercept方法有三个入参，分别是：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>参数</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object o</td>
<td>代理对象的引用</td>
</tr>
<tr>
<td>Method method</td>
<td>通过字节码获得的需要被增强的方法的引用</td>
</tr>
<tr>
<td>Object[] objects</td>
<td>被增强的方法的入参</td>
</tr>
<tr>
<td>MethodProxy methodProxy</td>
<td>代理对象的方法对象，用来执行父类（即被代理的对象）的方法</td>
</tr>
</tbody>
</table>
</div>
<div id="pro"></div>

<h3 id="关于动态代理的死循环问题"><a href="#关于动态代理的死循环问题" class="headerlink" title="关于动态代理的死循环问题"></a>关于动态代理的死循环问题</h3><p>·　　我们看到基于子类的动态代理在实现拦截的时候，拦截方法多了一个入参：<strong>MethodProxy</strong>。这个方法从作用上讲，是和Method一样的：<br>·　１.　Method method是<strong>被代理对象的方法字节码</strong>对象。使用方法是：method.invoke(被代理对象，方法参数)<br>·　２．MethodProxy methodProxy是<strong>代理对象的方法字节码</strong>对象。使用方法是：methodProxy.invokeSuper(代理对象，方法参数）<br>使用methodProxy有两点好处：<br>·　１．不需要给代理对象传入被代理对象，效率更高。<br>·　２．不会出现死循环的问题。<br>·　　第一点无需解释了，invoke方法的入参就说明了这个问题。主要是第二点：让我们来回顾一下，什么时候态代理会出现死循环的问题？<strong>答：在实现拦截器的时候，又调用了代理对象的方法。</strong> 这是什么意思呢？用刚才基于接口的动态代理为例，如果我在inovke拦截放法中增加<strong>proxy.toString()</strong> 这一句话：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Proxy.newProxyInstance(xxx, xxx,</span><br><span class="line">              <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                  	...</span><br><span class="line">                  	proxy.toString();</span><br><span class="line">                  	...</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br></pre></td></tr></table></figure>
<p>·　　就立刻会出现死循环的问题。为什么呢？<strong><font color="red">答案其实很简单:</font></strong> 因为，代理对象是没有自己的方法的，它的所有方法都是基于被代理对象，<strong>而调用代理对象方法的时候，都会经过拦截器方法。因此，如果在拦截器中再调用代理对象的方法，就会再次进入拦截器，这样就形成了死循环。</strong><br>·　　而基于子类的动态实现，是构建一个继承被代理对象的对象来实现代理的，因此其<strong>可以使用代理对象父类的方法（就是被代理对象）而不必经过拦截器</strong>，这就是上面所用的invokeSuper方法，用这种方法既可以不用注入被代理对象，又避免了死循环的问题，非常推荐使用！！<br>·　　<strong>但是这个方法有一个细节</strong>：不能用代理对象去使用没有在被代理对象中声明的方法，即使这个方法是其父类的，比如toString方法。即：如果代理对象想运行诸如toString这种方法，应当在被代理类中重写toString。因为：如果使用了父类的toString方法，methodProxy会自动去找父类Object，于是又生成了一次Object类的代理对象。语言比较枯燥，具体如下图：<br><img src="https://img-blog.csdnimg.cn/20190901173012817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="问题"><br>·　可见，toString方法会被执行两次，两个输出的都不是同一个值，一个是根据Object的字节码输出的值，一个是根据被代理对象的字节码生成的值。因此，如果要使用原被代理对象父类的方法，则这个方法至少被增强两次。值得注意的是：在第8步中，有可能走到final也有可能走到exception。在本案例中，会在第7步时会抛出异常，<strong>因为在第6步执行完之后，该线程的连接被释放了，于是当方法执行完后，事务提交时会再申请一个没有被开启事务的链接（因为新的链接autoCommit默认是true）</strong>，因此提交会失败。</p>
<h3 id="生成代理对象的类"><a href="#生成代理对象的类" class="headerlink" title="生成代理对象的类"></a>生成代理对象的类</h3><p>·　　因为，基于子类的动态代理不需要接口，所以我们让StudentServiceImpl不再实现StudentService接口，从而直接获得StudentServicImpl对象（<del>其实就是因为我懒了，不想再写一个类了…</del> ）。生成代理类的工厂如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.cglib;</span><br><span class="line"><span class="keyword">import</span>...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServiceProxy</span> </span>&#123;</span><br><span class="line"><span class="comment">//	  不再注入被代理对象</span></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    StudentServiceImpl stuService;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TransactionManager txManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"stuServiceProxy02"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentServiceImpl <span class="title">createStuServiceProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (StudentServiceImpl) Enhancer.create(StudentServiceImpl<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">MethodInterceptor</span>() </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Object obj = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    txManager.beginTransaction();</span><br><span class="line"><span class="comment">//                    obj = method.invoke(stuService,objects);</span></span><br><span class="line">					<span class="comment">//可以对比一下这两种方式的优劣</span></span><br><span class="line">                    obj = methodProxy.invokeSuper(o,objects);</span><br><span class="line">                    txManager.commit();</span><br><span class="line">                    <span class="keyword">return</span> obj;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    txManager.rollback();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    txManager.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试类注入新的代理对象并运行：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpringAnnotation</span> <span class="keyword">extends</span> <span class="title">AbstractTestNGSpringContextTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"stuServiceProxy02"</span>)</span><br><span class="line">    StudentServiceImpl stuServiceProxy02;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProxy02</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        stuServiceProxy02.findAllStudents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试结果如下：成功！</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">开启事务...</span><br><span class="line">方法被执行了....</span><br><span class="line">提交事务...</span><br><span class="line">释放连接...</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　动态代理还是比工厂模式难很多的，但是这种面向切面的变成方式确实简化了重复无用的劳动，十分有趣。看到上面的两种实现方法，虽然大同小异，但是第三方的cglib肯定是要比原JDK的方法要先进一些的（<del>不然这个第三方还有什么存在的必要</del> ），而Spring的AOP也使用cglib来进行动态代理的。<br>·　　其实在写动态代理的时候，我们就已经感觉到了，虽然理解起来不是很难，但是写起来确实是很复杂啊，所以Spring用配置的方式来简化了我们的代码量，可谓功德无量。下一篇博客，我就会简单的讲解一下SpringAOP的使用。</p>
<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote>
<p>请联系邮箱：chenxingyu@bupt.edu.cn</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>SpringIOC实战（xml+注解）</title>
    <url>/2019/08/31/SpringIOC%E5%AE%9E%E6%88%98%EF%BC%88xml-%E6%B3%A8%E8%A7%A3%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本篇文章涉及到了如下知识点：</p>
<ol>
<li>SpringIOC的概念和作用</li>
<li>通过XML配置进行SpringIOC实战</li>
<li>通过注解配置进行SpringIOC实战</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="SpringIOC的概念及作用"><a href="#SpringIOC的概念及作用" class="headerlink" title="SpringIOC的概念及作用"></a>SpringIOC的概念及作用</h1><p>·　　<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/1158025?fromtitle=ioc&amp;fromid=4853&amp;fr=aladdin" target="_blank" rel="noopener">百度百科的定义</a>：控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。<br>·　　在我的上一篇博客<a href="https://memoforward.github.io/2019/08/29/Java%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/" target="_blank" rel="noopener">Java工厂模式实战</a>中讲到，工厂可以用来降低程序之间的耦合程度，而利用工厂来创建单例对象就是在工厂中构建了一了Map集合。SpringIOC就是这样的一个工厂，叫做<strong>IOC容器，本质上就是一个存放Bean对象的Map集合</strong>。与<a href="https://memoforward.github.io/2019/08/29/Java%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/" target="_blank" rel="noopener">Java工厂模式实战</a>博客中不同的是，SpringIOC是通过构造函数来读取配置文件的，这样的设定更加灵活。<br>·　　而SpringIOC的工厂接口就是ApplicationContext（在BeanFactory的基础上做了升级），其具体的实现类用来执行不同配置选项的加载。很显然，IOC容器是工厂模式附属品，作用自然就是给我们的程序解耦。<strong>其叫做控制翻转的真正含义就是</strong>：在书写程序时，我们放弃了创建对象的控制权（即：new一个新对象），把这个控制权转交给了Spring工厂去创建。注：在web项目中，我们创建的对象一般被叫做JavaBean，Bean不仅仅指一些实体对象，而是指<strong>所有可重复使用的</strong>的对象。<br>·　　注：本篇博客不涉及源码的解读，仅仅只是将IOC的配置和作用做了个总结。</p>
<h1 id="IOC的环境依赖"><a href="#IOC的环境依赖" class="headerlink" title="IOC的环境依赖"></a>IOC的环境依赖</h1><h2 id="需要导入的jar包"><a href="#需要导入的jar包" class="headerlink" title="需要导入的jar包"></a>需要导入的jar包</h2><p>·　　spring-context包，版本用最新的5.0以上。<br>·　　当引入这个依赖后之后，Maven会自动把所有的关键包都导入，如果要手动添加，需要添加的包如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190830081015364.PNG" alt="jar包"><br>·　　这些包看名字就大致能知道是有什么作用，ioc需要用到的包是：beans（IOC管理），context（扩展），core（核心），expression（SpEL表达式）。而AOP是SpringAOP的必备包，而JCL是Spring整合JVM日志的一个包（一般不用）。</p>
<h2 id="本次案例的需求"><a href="#本次案例的需求" class="headerlink" title="本次案例的需求"></a>本次案例的需求</h2><p>·　　大家都知道Spring是用作web开发的框架，因此本次案例就针对业务层和持久层，利用Spring进行Bean的管理，来实现对数据库的增删改查。以下是要创建的类和数据库对象（为了方便，使用dbUtils包操作数据库）：</p>
<ul>
<li>数据库：springioc（包含t_stu表，字段为：sid（主键），sname，grade）<br><img src="https://img-blog.csdnimg.cn/20190830142331834.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="数据库"></li>
<li>持久层接口：StudentDao</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>持久层实现：StudentDaoImpl</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao.impl;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDaoImpl</span> <span class="keyword">implements</span> <span class="title">StudentDao</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StudentDaoImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"StudnetDaoImpl被创建了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学生被保存了...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>业务层接口：StudentService(调用持久层方法来实现业务逻辑，在数据CRUD中，两部分的功能是一模一样的)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service;</span><br><span class="line"><span class="keyword">import</span> com.memoforward.dao.StudentDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>业务层实现：StudentServiceImpl</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service.impl;</span><br><span class="line"><span class="keyword">import</span> com.memoforward.dao.StudentDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentServiceImpl</span> <span class="keyword">implements</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line">	StudentDao stuDao;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentServiceImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"StudentServiceImpl被创建了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stuDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="使用XML进行SpringIOC的配置"><a href="#使用XML进行SpringIOC的配置" class="headerlink" title="使用XML进行SpringIOC的配置"></a>使用XML进行SpringIOC的配置</h1><p>·　　既然IOC容器是用工厂进行了Bean的管理，那么我们自然就会想到用配置文件来告知Spring创建何种类的对象。<br>·　　Spring配置文件的基本约束和格式如下（理论上文件名可以任取，但一般是applicationContext.xml）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--创建Bean--&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>·　　在用加载配置文件，生成ApplicationContext工厂接口后就可以使用IOC来获取bean对象了。<br><strong>注意</strong>：<font color="red">使用ApplicationContext加载配置文件的同时，所有在配置文件中的单例bean就被创建了。</font></p>
<h2 id="bean的三种创建方式"><a href="#bean的三种创建方式" class="headerlink" title="bean的三种创建方式"></a>bean的三种创建方式</h2><ul>
<li>1．<strong>利用无参构造方法</strong>创建，给定全限定类名就行了。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--1. 通过调用构造函数加载--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentDao01"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.dao.impl.StudentDaoImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2．如果<strong>另有一个类的方法可以生成这个bean</strong>，比如如下的：DaoFactory中的createStudentDao</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.memoforward.dao.StudentDao;</span><br><span class="line"><span class="keyword">import</span> com.memoforward.dao.impl.StudentDaoImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentDao <span class="title">createStudentDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StudentDao <span class="title">createStudentDaoByStaticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>则可以有如下配置创建bean：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--2. 通过其他类的方法创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"daoFactory"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.factory.DaoFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentDao02"</span> <span class="attr">factory-bean</span>=<span class="string">"daoFactory"</span> <span class="attr">factory-method</span>=<span class="string">"createStudentDao"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>3．第三种方法是通过<strong>其他类的静态方法</strong>来创建，如DaoFactory的createStudentDaoByStaticMethod<br>则配置如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--3. 通过其他类的静态方法创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentDao03"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.factory.DaoFactory"</span> <span class="attr">factory-method</span>=<span class="string">"createStudentDaoByStaticMethod"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>测试如下：加载配置后，三个bean都被创建成功了</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBeanTest01</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试结果</span></span><br><span class="line">StudnetDaoImpl被创建了...</span><br><span class="line">StudnetDaoImpl被创建了...</span><br><span class="line">StudnetDaoImpl被创建了...</span><br></pre></td></tr></table></figure>
<h2 id="Bean的作用范围与生命周期"><a href="#Bean的作用范围与生命周期" class="headerlink" title="Bean的作用范围与生命周期"></a>Bean的作用范围与生命周期</h2><p>·　　这里的Bean的作用范围和生命周期与我的上一篇博客<a href="https://memoforward.github.io/2019/08/29/Java%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/" target="_blank" rel="noopener">Java工厂模式实战</a>里的对象一模一样，这里就不细讲了。<br>·　　在bean标签里表示作用范围的属性是：<strong>scope</strong>。值只需要记住两个：singleton（单例），prototype（多例）。<br>·　　能体现生命周期的属性是：init-method和destroy-method，分别表示该bean在创建和销毁时会调用的方法，一般不用。</p>
<h2 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h2><p>·　　我们在StudentServiceImpl中需要有一个StudentDao来带给业务层以持久层的逻辑，这时就需要我们把StudentDao的Bean注入到StudnetServiceImpl的对象中。<br>·　　利用XML配置文件的方式实现注入有两种方式：</p>
<ul>
<li>1．<strong>利用构造函数进行注入</strong><br>·　　在StudentServiceImpl中添加有参构造：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StudentServiceImpl</span><span class="params">(StudentDao stuDao)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.stuDao = stuDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>·　　添加如下的配置，<strong>注入</strong>上面id为<strong>studentDao01</strong>的bean（设置成多例，测试方便）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--1. 通过构造函数注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentService01"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.service.impl.StudentServiceImpl"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"stuDao"</span> <span class="attr">ref</span>=<span class="string">"studentDao01"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：&lt; constructor-arg &gt;标签有两种属性：<br>·　　 1)（表示要注入什么数据）name，index，type：分别表示要注入的数据的名称，在构造函数中的位置，数据的类型。我们一般用name属性。<br>·　　2)（表示数据具体的内容）value：注入String和基本数据类型；ref：注入其他的bean。</p>
<ul>
<li>2.　<strong>利用set方法来进行注入</strong><br>·　　在StudentServiceImpl方法中添加set方法：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuDao</span><span class="params">(StudentDao stuDao)</span> </span>&#123;</span><br><span class="line">	System.out.println(<span class="string">"StudentServiceImpl有参构造被调用了...."</span>);</span><br><span class="line">    <span class="keyword">this</span>.stuDao = stuDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>·　　添加如下的配置，<strong>注入</strong>上面id为<strong>studentDao02</strong>的bean：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--2.通过set方法来注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentService02"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.service.impl.StudentServiceImpl"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"stuDao"</span> <span class="attr">ref</span>=<span class="string">"studentDao02"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>：&lt; property &gt;标签只有两种属性，其一是name，表示set的数据名称；其二是value/ref，和上述一样。</p>
<ul>
<li>测试如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDI</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">       System.out.println(<span class="string">"******************"</span>);</span><br><span class="line">       StudentService studentService01 = ac.getBean(<span class="string">"studentService01"</span>, StudentService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       studentService01.save();</span><br><span class="line">       System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">       StudentService studentService02 = (StudentService) ac.getBean(<span class="string">"studentService02"</span>);</span><br><span class="line">       studentService02.save();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试结果如下</span></span><br><span class="line">StudnetDaoImpl被创建了...</span><br><span class="line">StudnetDaoImpl被创建了...</span><br><span class="line">StudnetDaoImpl被创建了...</span><br><span class="line">******************</span><br><span class="line">StudentServiceImpl有参构造被调用了....</span><br><span class="line">学生被保存了....</span><br><span class="line">-----------------</span><br><span class="line">StudentServiceImpl被创建了...</span><br><span class="line">学生被保存了....</span><br></pre></td></tr></table></figure>
<ul>
<li><p>测试结果分析：<br>·　　单例的Bean会在配置文件被加载的同时被创建，多例bean会在被调用的时候被创建。同时，两种依赖也被成功注入了。</p>
</li>
<li><p>3．复杂类型的注入(不做测试了)<br>·　　配置框架如下：</p>
</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--3.复杂类型的注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"xxx"</span> <span class="attr">class</span>=<span class="string">"xxx.xx.xxx"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"yyy"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>zzz<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>zzz<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>zzz<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"xx"</span> <span class="attr">value-type</span>=<span class="string">"?"</span> <span class="attr">value</span>=<span class="string">"yy"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">"xxx"</span> <span class="attr">value-ref</span>=<span class="string">"xxx"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>·　　其中list,set,array实现基本一样，因此标签互换也是没有关系的；复杂数据类型的注入就是套路，记住就好了。</p>
<h2 id="XML配置总结"><a href="#XML配置总结" class="headerlink" title="XML配置总结"></a>XML配置总结</h2><p>·　　XML配置优点就是直观；但是缺点也比较明显：写起来比较复杂。<br>·　　为了能够简化配置文件，加快开发速度，IOC的注解开发也是不错的选择。</p>
<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><font color="red">注意</font></h2><p>·　　当一个类中有被Spring注入的属性，那就不要自己再去new这个类的实例了，因为自己new出来的实例，里面的属性Spring并不会自动帮你注入,Spring只在它自己管理的Bean中注入属性。</p>
<h1 id="使用注解进行SpringIOC的配置"><a href="#使用注解进行SpringIOC的配置" class="headerlink" title="使用注解进行SpringIOC的配置"></a>使用注解进行SpringIOC的配置</h1><p>·　　使用注解和使用XML本质上一模一样，都是为了降低程序间的耦合。<br>·　　使用注解之后，一般就不必在配置文件中配置Bean了，但是需要在配置文件开启组件扫描，让Spirng在程序主方法运行前去扫描可能带有注解的包，并创建实例对象或者进行依赖的注入。</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>·　　扫描包需要加入context约束，配置如下(扫描com.memoforward包及其子包)：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>功能</th>
<th>属性</th>
<th>作用位置</th>
</tr>
</thead>
<tbody>
<tr>
<td><font color="Blue"><strong>创建Bean的注解如下：</strong></font></td>
</tr>
<tr>
<td>@Componnet</td>
<td>创建对象的注解，和&lt; bean &gt;的功能相同</td>
<td>value：创建的beanId，默认为类名（首字母变小写）</td>
<td>一般作用在类上</td>
</tr>
<tr>
<td>@Controller/@Serivce/@Repository</td>
<td>针对MVC模式设计出来，功能同上，只是名字不一样</td>
<td>value：创建的beanId，默认为类名</td>
<td>一般作用在类上</td>
</tr>
<tr>
<td><font color="Blue"><strong>依赖注入的注解如下：</strong></font></td>
</tr>
<tr>
<td>@Autowired（最常用）</td>
<td>自动按类型注入，只要该类型在IOC容器中有唯一的bean对象</td>
<td>无</td>
<td>一般作用在成员变量和方法上（注入方法参数）</td>
</tr>
<tr>
<td>@Qulaifier</td>
<td>在按类型注入的基础上，再按照名称注入</td>
<td>value：beanId</td>
<td>能单独在方法上注入参数，但不能直接在类上使用（与@Autowired同用）</td>
</tr>
<tr>
<td>@Resource</td>
<td>直接按照bean 的id注入</td>
<td>name：beanId</td>
<td>类和方法上</td>
</tr>
<tr>
<td>@Value</td>
<td>注入String和基本类型</td>
<td>value：SpEL表达式</td>
<td>成员变量和方法上</td>
</tr>
<tr>
<td><font color="red"><strong>注意：集合类型只能xml注入</strong></font></td>
</tr>
<tr>
<td><font color="Blue"><strong>作用范围和生命周期相关的注解：</strong></font></td>
</tr>
<tr>
<td>@Scope</td>
<td>作用和&lt; bean &gt;中scope属性一样</td>
<td>value：singleton和prototype</td>
<td>作用在类上</td>
</tr>
<tr>
<td>@PreDestroy和@PostConstruct</td>
<td>bean对象创建和销毁时调用的方法</td>
<td>无</td>
<td>作用在方法上</td>
</tr>
</tbody>
</table>
</div>
<h2 id="修改上述的代码，改用注解"><a href="#修改上述的代码，改用注解" class="headerlink" title="修改上述的代码，改用注解"></a>修改上述的代码，改用注解</h2><ul>
<li>持久层接口：StudentDao</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>持久层实现：StudentDaoImpl（<strong>加上@Repository注解，表示这是一个持久层的Bean</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao.impl;</span><br><span class="line"><span class="keyword">import</span>...</span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"stuDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDaoImpl</span> <span class="keyword">implements</span> <span class="title">StudentDao</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">StudentDaoImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"StudnetDaoImpl被创建了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学生被保存了...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>业务层接口：StudentService(调用持久层方法来实现业务逻辑，在数据CRUD中，两部分的功能是一模一样的)</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service;</span><br><span class="line"><span class="keyword">import</span> com.memoforward.dao.StudentDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>业务层实现：StudentServiceImpl（<strong>加上@Service注解，表示这是一个业务层的Bean；@Autowired自动注入StudentDao属性</strong>）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service.impl;</span><br><span class="line"><span class="keyword">import</span>...</span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"stuService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentServiceImpl</span> <span class="keyword">implements</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentDao stuDao;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentServiceImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"StudentServiceImpl被创建了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stuDao.save();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpringIOCAnnotation</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">       System.out.println(<span class="string">"******************"</span>);</span><br><span class="line">       StudentService stuService = ac.getBean(<span class="string">"stuService"</span>, StudentService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       stuService.save();</span><br><span class="line">       System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">       StudentDao stuDao = ac.getBean(<span class="string">"stuDao"</span>, StudentDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       stuDao.save();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果如下：</span></span><br><span class="line">StudnetDaoImpl被创建了...</span><br><span class="line">StudentServiceImpl被创建了...</span><br><span class="line">******************</span><br><span class="line">学生被保存了....</span><br><span class="line">------------------</span><br><span class="line">学生被保存了....</span><br></pre></td></tr></table></figure>
<p>·由上述例子可见：配置文件被加载时，所有加上与@Component功能一致的注解的Bean被创建，且是单例的。同时@Autowired确实成功注入了对象。</p>
<h1 id="使用注解和XML的建议"><a href="#使用注解和XML的建议" class="headerlink" title="使用注解和XML的建议"></a>使用注解和XML的建议</h1><p>·　　实际工程中，建议使用“XML+注解”的开发模式，因为这种模式比较简单和直观。<br>·　　如果是我们自己创建的Bean对象，推荐使用注解。<br>·　　如果是jar包中的Bean对象，推荐使用XML进行开发。<br>·　　<strong>因此，我们的配置文件中一般会有两个内容：一个是需要开启组件扫描，另一个是第三方的bean（比如数据库的DataSource）</strong><br>·　　在第三章，我们介绍了纯XML的开发，在这篇博客的最后，我们再简单介绍一下纯注解式开发。接下来，我们将使用“XML+注解”实现第二章的案例需求。</p>
<h1 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h1><h2 id="添加增删改查方法"><a href="#添加增删改查方法" class="headerlink" title="添加增删改查方法"></a>添加增删改查方法</h2><p>·　　主要改动的地方有三处：添加学生Bean，修改StudentDao即它的实现类，修改StudentService即它的实现类。</p>
<ul>
<li>创建Student类，并提供set、get以及toString方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer sid;</span><br><span class="line">    <span class="keyword">private</span> String sname;</span><br><span class="line">    <span class="keyword">private</span> Double grade;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getSid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSid</span><span class="params">(Integer sid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sid = sid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSname</span><span class="params">(String sname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sname = sname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getGrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGrade</span><span class="params">(Double grade)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"sid="</span> + sid +</span><br><span class="line">                <span class="string">", sname='"</span> + sname + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", grade="</span> + grade +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>StudentService及实现</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.查询所有学生</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">findAllStudents</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.查询某个学生</span></span><br><span class="line">    <span class="function">Student <span class="title">findStudentBySid</span><span class="params">(Integer sid)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.添加某个学生</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(Student stu)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.删除某个学生</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteStudentBySid</span><span class="params">(Integer sid)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.修改某个学生</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(Student stu)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red">注意：StudentServiceImpl类中注入了stuDao属性。</font><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"stuService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServiceImpl</span> <span class="keyword">implements</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentDao stuDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">findAllStudents</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuDao.findAllStudents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">findStudentBySid</span><span class="params">(Integer sid)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuDao.findStudentBySid(sid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(Student stu)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        stuDao.addStudent(stu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteStudentBySid</span><span class="params">(Integer sid)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        stuDao.deleteStudentBySid(sid);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(Student stu)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        stuDao.updateStudent(stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>StudentDao及它的实现类</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.查询所有学生</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">findAllStudents</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.查询某个学生</span></span><br><span class="line">    <span class="function">Student <span class="title">findStudentBySid</span><span class="params">(Integer sid)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.添加某个学生</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(Student stu)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.删除某个学生</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteStudentBySid</span><span class="params">(Integer sid)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.修改某个学生</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(Student stu)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><font color="red">注意：StudentDaoImpl类中注入了QueryRunner对象</font>，该对象在第三方jar中，且其构造函数要传入数据库的数据源，因此在配置文件中<strong>还要创建两个bean，一个是QueryRunner，一个是C3p0的数据源对象</strong>。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"stuDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDaoImpl</span> <span class="keyword">implements</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    QueryRunner runner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">findAllStudents</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        List&lt;Student&gt; stuList = runner.query(<span class="string">"select * from t_stu"</span>, <span class="keyword">new</span> BeanListHandler&lt;Student&gt;(Student<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        <span class="keyword">return</span> stuList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">findStudentBySid</span><span class="params">(Integer sid)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Student stu = runner.query(<span class="string">"select * from t_stu where sid = ?"</span>, <span class="keyword">new</span> BeanHandler&lt;Student&gt;(Student<span class="class">.<span class="keyword">class</span>), <span class="title">sid</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(Student stu)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        runner.update(<span class="string">"insert into t_stu(sname,grade) values(?,?)"</span>,stu.getSname(),stu.getGrade());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteStudentBySid</span><span class="params">(Integer sid)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        runner.update(<span class="string">"delete from t_stu where sid = ?"</span>, sid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(Student stu)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        runner.update(<span class="string">"update t_stu set sname=?,grade=? where sid=?"</span>,stu.getSname(),stu.getGrade(),stu.getSid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>QueryRunner的使用并不是我们今日讨论的重点，就不说了。</p>
<ul>
<li>由StudentDaoImpl的实现可知，我们的xml配置文件需要做出一点修改，完整的配置如下：</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"ds"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springioc"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>现在我们就万事具备，只欠测试了！但是在测试前，为了测试的方便我还是要讲一个小知识点：<strong>Spring整合TestNG</strong>，实现在测试类中自动注入。</li>
</ul>
<h1 id="Spring整合TestNG"><a href="#Spring整合TestNG" class="headerlink" title="Spring整合TestNG"></a>Spring整合TestNG</h1><p>·　　一般情况下，测试模块是不与Spring框架直接联系的，因为例如Junit和TestNG都集成了main方法，这个主方法去检测测试类中的方法上有没有@Test注解，来判断是否执行该方法。这个过程是通过反射的，不会注意到<strong>例如@Autowired这类的注解</strong>，为了测试的方便（不然每个测试的方法都要new一个StudentService），Spring提供了与TestNG整合的方法。方法如下：<br>（<strong>注：为什么不整合Junit，因为testNG在功能和性能上都比junit好很多</strong>）</p>
<ul>
<li>1．添加必要的依赖：spring-text和testng</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.testng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testng<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>2．<strong>使测试类继承AbstractTestNGSpringContextTests类</strong></li>
<li>3．在测试类上添加注解@ContextConfiguration：开启测试类对配置的加载<ul>
<li>该注解有两个属性数组：location，表示配置文件的位置；classes，表示配置类的位置（纯注解开发使用） </li>
</ul>
</li>
</ul>
<p>·　　完成以上三步后，就可以在测试中注入IOC容器中的Bean了。<br>·　　使用如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpringAnnotation</span> <span class="keyword">extends</span> <span class="title">AbstractTestNGSpringContextTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentService stuService;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//测试代码</span></span><br><span class="line">	....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="案例测试"><a href="#案例测试" class="headerlink" title="案例测试"></a>案例测试</h1><h2 id="测试代码和结果"><a href="#测试代码和结果" class="headerlink" title="测试代码和结果"></a>测试代码和结果</h2><ul>
<li>1．”查”方法的测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tsetFind</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Student&gt; stuList = stuService.findAllStudents();</span><br><span class="line">        <span class="keyword">for</span>(Student student : stuList)&#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">        Student stu = stuService.findStudentBySid(<span class="number">3</span>);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>“查”方法测试结果：可见查方法是没有问题的</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student&#123;sid&#x3D;1, sname&#x3D;&#39;cxy&#39;, grade&#x3D;100.0&#125;</span><br><span class="line">Student&#123;sid&#x3D;2, sname&#x3D;&#39;lhw&#39;, grade&#x3D;99.5&#125;</span><br><span class="line">Student&#123;sid&#x3D;3, sname&#x3D;&#39;cwh&#39;, grade&#x3D;86.5&#125;</span><br><span class="line">Student&#123;sid&#x3D;4, sname&#x3D;&#39;sd&#39;, grade&#x3D;59.9&#125;</span><br><span class="line">-----------------</span><br><span class="line">Student&#123;sid&#x3D;3, sname&#x3D;&#39;cwh&#39;, grade&#x3D;86.5&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>2．”增”方法测试：增加了cxx学生，成绩为75.9</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">    stu.setSname(<span class="string">"cxx"</span>);</span><br><span class="line">    stu.setGrade(<span class="number">75.9</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stuService.addStudent(stu);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>“增”方法测试结果：可见cxx已经成功被添加（sid为7是因为我之前自己做过测试）<br><img src="https://img-blog.csdnimg.cn/20190831095054662.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="增"></li>
<li>3．”改”方法测试：将cxx的成绩改成40</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">    stu.setSid(<span class="number">7</span>);</span><br><span class="line">    stu.setSname(<span class="string">"cxx"</span>);</span><br><span class="line">    stu.setGrade(<span class="number">40.0</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stuService.updateStudent(stu);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>“改”方法测试结果：修改成功<br><img src="https://img-blog.csdnimg.cn/20190831095203528.PNG" alt="改"></li>
<li>4．”删”方法测试</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stuService.deleteStudentBySid(<span class="number">7</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>“删”方法测试结果：删除成功<br><img src="https://img-blog.csdnimg.cn/20190831095238618.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="删"><h2 id="该案例存在的一点问题"><a href="#该案例存在的一点问题" class="headerlink" title="该案例存在的一点问题"></a>该案例存在的一点问题</h2>·　　很明显的一个问题，该案例没有实现<strong>事务管理</strong>。因为业务层的逻辑较为单一，所以对这个案例毫无影响，但是当业务层逻辑较为复杂时，就必须实现事务管理了，笔者的下一篇文章会介绍一下java的动态代理技术来对业务层的方法进行增强，从而实现事务管理（开启，提交，回滚，释放连接），文章已经写好了：<a href="https://memoforward.github.io/2019/09/01/Java%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%A7%A3%E9%87%8A/" target="_blank" rel="noopener">Java 两种动态代理实战 + 动态代理死循环的解释</a>。</li>
</ul>
<h1 id="IOC的纯注解开发（个人不喜欢用）"><a href="#IOC的纯注解开发（个人不喜欢用）" class="headerlink" title="IOC的纯注解开发（个人不喜欢用）"></a>IOC的纯注解开发（个人不喜欢用）</h1><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><p>·　　看过一本书叫做《Spring实战》，作者建议使用纯注解开发，于是我专门去学习了一下。其实纯注解的意思就是把配置文件变成了配置类，就像配置文件不一定只有一个一样，配置类也可以有多个。<br>·　　配置类中有哪些内容呢？之前我们讲过，使用注解开发之后，在配置文件中一般有两个内容：一个是开启扫描组件，另一个是声明第三方的jar包。因此在配置类中，我们主要的就是解决这两个问题。<br>·　　加载配置类的方法是AnnotationConfigApplicationContext(参数是注解类们的字节码)，其实和ClassPathXmlAoolicationContext没什么不同嘛。</p>
<h2 id="Spring有关配置类的注解"><a href="#Spring有关配置类的注解" class="headerlink" title="Spring有关配置类的注解"></a>Spring有关配置类的注解</h2><div class="table-container">
<table>
<thead>
<tr>
<th>注解</th>
<th>功能</th>
<th>属性</th>
<th>作用位置</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Configuration</td>
<td>表示该类是一个配置类，当被ApplicationContext加载时可不写</td>
<td>无</td>
<td>作用在类上</td>
</tr>
<tr>
<td>@ComponentScan</td>
<td>需要扫描的包</td>
<td>value/basePackages：指定包（可以是多个）</td>
<td>作用在类上</td>
</tr>
<tr>
<td>@Bean</td>
<td>把当前方法的返回值作为bean对象存入spring的ioc容器中</td>
<td>name：指定bean的Id</td>
<td>作用在方法上(如果该方法有参数，则Spring会自动去IOC容器中查找Bean，没有则无法返回)</td>
</tr>
<tr>
<td>@import</td>
<td>导入其他的配置类</td>
<td>value(class):其他配置类的字节码（被import的是子类）</td>
<td>作用在类上</td>
</tr>
<tr>
<td>@PropertySource</td>
<td>引入property配置文件</td>
<td>value：“classpath：文件的配置”</td>
<td>作用在类上</td>
</tr>
</tbody>
</table>
</div>
<h2 id="配置文件转化成配置类"><a href="#配置文件转化成配置类" class="headerlink" title="配置文件转化成配置类"></a>配置文件转化成配置类</h2><ul>
<li>1．原始配置文件如下：<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"ds"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springioc"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li>
<li>２．为了能把所有的注解都用上，建两个配置类，并把Datasource用properties文件存储。</li>
<li>配置文件：jdbc.properties</li>
</ul>
<figure class="highlight properties"><table><tr><td class="code"><pre><span class="line"><span class="meta">jdbc.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.jdbcUrl</span>=<span class="string">jdbc:mysql:///springioc</span></span><br><span class="line"><span class="meta">jdbc.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure>
<ul>
<li>JDBC配置类：JDBCConfig</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过配置文件注入属性</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driverClass&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String driverClass;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.jdbcUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String jdbcUrl;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.user&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryRunner <span class="title">createQueryRunner</span><span class="params">(DataSource ds)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QueryRunner(ds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ComboPooledDataSource ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ds.setDriverClass(driverClass);</span><br><span class="line">            ds.setJdbcUrl(jdbcUrl);</span><br><span class="line">            ds.setUser(user);</span><br><span class="line">            ds.setPassword(password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>总配置类：IOCConfig</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.memoforward"</span>)</span><br><span class="line"><span class="meta">@Import</span>(JDBCConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">IOCConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用时加载配置类（测试时如何使用？）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//@ContextConfiguration(locations = "classpath:applicationContext.xml")</span></span><br><span class="line"><span class="comment">//改用加载配置类的方式</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = IOCConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TestSpringAnnotation</span> <span class="keyword">extends</span> <span class="title">AbstractTestNGSpringContextTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有整合就用如下的方式加载配置类</span></span><br><span class="line">    <span class="comment">//ApplicationContext ac = new AnnotationConfigApplicationContext(IOCConfig.class);</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentService stuService;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//以下是测试代码</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>·　　测试可以正常运行，说明我们配置成功了。这种方式，甚至比xml还要繁琐，而且也不是那么的简单易懂，我个人是很不喜欢这样用。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　IOC是Spring框架的重中之重，但是说白了就是一个Map集合的工厂类而已，这种设计理念是真的不错，我们要站在巨人的肩膀上，多加思考，让写代码变得越来越简单，目标就是在：让天下没有秃顶的程序员！</p>
<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote>
<p>请联系邮箱：chenxingyu@bupt.edu.cn</p>
</blockquote>
]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>SSM</tag>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Java工厂模式实战</title>
    <url>/2019/08/29/Java%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本篇主要涉及如下知识点：</p>
<ol>
<li>工厂模式设计概念</li>
<li>Java实现一个简单的工厂类</li>
<li>对工厂类实现优化，使其能够支持单例和多例</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>·　　工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。简而言之，工厂模式就是改变了我们创建对象的方法。</p>
<ul>
<li>传统创建对象的方法是：new 出一个实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Person student = <span class="keyword">new</span> Student()；</span><br></pre></td></tr></table></figure>
<ul>
<li>而工厂模式创建实例的方式可能如下:</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Student student = (Student)BeanFactory.getPerson(<span class="string">"student"</span>);</span><br></pre></td></tr></table></figure>
<p>·　　这意味着两点：<strong>其一</strong>，工厂模式创建的实例是隐藏细节的，我们并不完全知道工厂创建的到底是什么实例（上述代码可能返回的是一个Teacher对象，而被强转成了Student）；<strong>其二</strong>，工厂模式降低了类之间的耦合（依赖）。使用传统模式来创建实例，一旦实例出现了问题（比如Student类的构造方法被改变），则代码不可能编译成功，整个项目就会面临崩溃；而工厂模式创建对象，其依赖仅仅只是一个字符串而已，即使不能运行成功，至少其编译是没问题的，类之间的依赖程度大大减少。</p>
<h1 id="工厂模式创建对象实战"><a href="#工厂模式创建对象实战" class="headerlink" title="工厂模式创建对象实战"></a>工厂模式创建对象实战</h1><h2 id="工厂模式创建对象原理"><a href="#工厂模式创建对象原理" class="headerlink" title="工厂模式创建对象原理"></a>工厂模式创建对象原理</h2><p>·　　最常见的工厂模式创建对象的流程如下：“<strong>创建工厂——读取配置文件——获取配置属性对应的值(全限定类名)——根据类名使用反射创建实例对象</strong>”。对应的知识点为<a href="https://memoforward.github.io/2019/08/27/Java%E4%B8%ADXML%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%88Dom4j-Xpath%EF%BC%89/" target="_blank" rel="noopener">读取XML文件</a> 以及 <a href="https://memoforward.github.io/2019/08/24/Java%E5%8F%8D%E5%B0%84%E8%AE%B2%E8%A7%A3%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/" target="_blank" rel="noopener">Java 反射讲解与案例实战</a>，具体的知识点可以参考链接的这两篇博客。</p>
<h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>·　　<strong>目标</strong>：使用工厂PersonFactory得到Student和Teacher类的两个对象。<br>·　　需要导入支持xml读取的dom4j包和jaxen包；以及用于测试的testng包。</p>
<ul>
<li>两个类实现了Person接口，具体如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student对象被创建了...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学生码代码..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Teacher对象被创建了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老师码代码...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写配置文件persons.xml</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">persons</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.Student"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">"teacher"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.Teacher"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>编写工厂</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonFactory01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Document document = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//静态代码块读取配置文件</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            document = reader.read(PersonFactory01.class.getClassLoader().getResourceAsStream("persons.xml"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getPerson</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//获取到配置文件中需要找到的标签</span></span><br><span class="line">        Element element = (Element) document.selectSingleNode(<span class="string">"/persons/person[@id='"</span>+ id +<span class="string">"']"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        	<span class="comment">//通过该标签的class属性值获取类名，并通过反射创建实例</span></span><br><span class="line">            obj = Class.forName(element.attributeValue(<span class="string">"class"</span>)).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPersonFactory01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PersonFactory01 personFactory = <span class="keyword">new</span> PersonFactory01();</span><br><span class="line">        Student student = (Student)personFactory.getPerson(<span class="string">"student"</span>);</span><br><span class="line">        student.code();</span><br><span class="line">        Teacher teacher = (Teacher)personFactory.getPerson(<span class="string">"teacher"</span>);</span><br><span class="line">        teacher.code();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试结果如下</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student对象被创建了....</span><br><span class="line">学生码代码...</span><br><span class="line">Teacher对象被创建了...</span><br><span class="line">老师码代码....</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Passes: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<p>·　　可见学生对象和老师对象都被BeanFactory成功的创建了。</p>
<h1 id="上例的工厂模式改进"><a href="#上例的工厂模式改进" class="headerlink" title="上例的工厂模式改进"></a>上例的工厂模式改进</h1><h2 id="上例的问题"><a href="#上例的问题" class="headerlink" title="上例的问题"></a>上例的问题</h2><p>·　　理论上，上例已经可以解决很多的问题了，但是会面临一个问题：<strong>当我每一次构造对象，我都会用newInstance创建一个新的实例对象。</strong> 如果某个类我只希望创建一个实例对象（每次getPerson都获得同一个对象），上述的工厂就不再适用了。举个简单的例子：一个班只有一个老师，我每次找老师都只想找到同一个老师。<br>·　　上面的问题就是我们熟知的<strong>单例</strong>和<strong>多例</strong>的问题，有的时候我们并不想用多例的模式去操作Bean，因此对上例工厂模式的改进就是：把多例模式的工厂转换为单例模式的工厂。</p>
<ul>
<li>多例测试代码：如果连续获取5次Teacher对象，得到5个不同的实例。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">	Teacher teacher = (Teacher)personFactory.getPerson(<span class="string">"teacher"</span>);</span><br><span class="line">	System.out.println(teacher);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试结果如下：</span></span><br><span class="line">Teacher对象被创建了...</span><br><span class="line">com.memoforward.Teacher@<span class="number">11758f</span>2a</span><br><span class="line">Teacher对象被创建了...</span><br><span class="line">com.memoforward.Teacher<span class="meta">@e</span>720b71</span><br><span class="line">Teacher对象被创建了...</span><br><span class="line">com.memoforward.Teacher@<span class="number">1</span>b26f7b2</span><br><span class="line">Teacher对象被创建了...</span><br><span class="line">com.memoforward.Teacher@<span class="number">491</span>cc5c9</span><br><span class="line">Teacher对象被创建了...</span><br><span class="line">com.memoforward.Teacher@<span class="number">74</span>ad1f1f</span><br></pre></td></tr></table></figure>
<h2 id="工厂类的改写"><a href="#工厂类的改写" class="headerlink" title="工厂类的改写"></a>工厂类的改写</h2><p>·　　之前我们在工厂类中，使用了静态代码块去加载了配置文件，创造了单例的静态document树对象。因此，创造单例模式的工厂的思路就是：<strong>构建单例的静态Map集合去存储不同类的实例对象</strong>。很显然，对Map对象的赋值操作也是在静态代码块中实现的，这意味着，每个类的实例对象都是在配置文件被加载的同时被创建的。</p>
<ul>
<li>单例Person工厂的代码如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonFactory02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Document document;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; beanMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String beanId = <span class="keyword">null</span>;</span><br><span class="line">            Object obj;</span><br><span class="line">            document = reader.read(PersonFactory02.class.getClassLoader().getResourceAsStream("persons.xml"));</span><br><span class="line">            <span class="comment">//选取persons的所有子元素</span></span><br><span class="line">            List&lt;Element&gt; elements = document.selectNodes(<span class="string">"/persons/person"</span>);</span><br><span class="line">            <span class="keyword">for</span>(Element element : elements)&#123;</span><br><span class="line">                beanId = element.attributeValue(<span class="string">"id"</span>);</span><br><span class="line">                obj = Class.forName(element.attributeValue(<span class="string">"class"</span>)).newInstance();</span><br><span class="line">                beanMap.put(beanId,obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getPerson</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试如下：分别获取3个Student和3个Teacher对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPersonFactory02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PersonFactory02 pf = <span class="keyword">new</span> PersonFactory02();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        Student student = (Student)pf.getPerson(<span class="string">"student"</span>);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">        Teacher teacher = (Teacher)pf.getPerson(<span class="string">"teacher"</span>);</span><br><span class="line">        System.out.println(teacher);</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试结果如下：每次得到的都是同一个对象，且对象只创建一次。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student对象被创建了....</span><br><span class="line">Teacher对象被创建了...</span><br><span class="line">com.memoforward.Student@77ec78b9</span><br><span class="line">com.memoforward.Teacher@1a3869f4</span><br><span class="line">---------------------------------</span><br><span class="line">com.memoforward.Student@77ec78b9</span><br><span class="line">com.memoforward.Teacher@1a3869f4</span><br><span class="line">---------------------------------</span><br><span class="line">com.memoforward.Student@77ec78b9</span><br><span class="line">com.memoforward.Teacher@1a3869f4</span><br><span class="line">---------------------------------</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Passes: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>补充</strong>：单例模式对象的初始化操作在加载配置文件的时候就完成了，即在new PersonFactory02()的时候，两个对象就被创建了吗，而静态代码块只会执行一次，因此这两个对象永远不会改变。</li>
</ul>
<h2 id="工厂的再改进"><a href="#工厂的再改进" class="headerlink" title="工厂的再改进"></a>工厂的再改进</h2><p>·　　以上的两个工厂类明显都不太行，一个只能支持多例，一个只能支持单例。因此最理想的工厂应该根据用户的需求自己判断创建多例和单例的对象。这当然呀没有什么难度，但是需要在配置文件中声明其对象的作用范围。</p>
<ul>
<li>配置文件修改：加入scope属性，值为singleton的时候为单例，值为prototype的时候为多例；如果不写此属性，则默认为单例。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">persons</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.Student"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">"teacher"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.Teacher"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>工厂类如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Document document;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; beanMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String beanId = <span class="keyword">null</span>;</span><br><span class="line">            Object obj;</span><br><span class="line">            document = reader.read(PersonFactory.class.getClassLoader().getResourceAsStream("persons.xml"));</span><br><span class="line">            <span class="comment">//选取persons的所有子元素</span></span><br><span class="line">            List&lt;Element&gt; elements = document.selectNodes(<span class="string">"/persons/person"</span>);</span><br><span class="line">            <span class="keyword">for</span>(Element element : elements)&#123;</span><br><span class="line">                Attribute attr = element.attribute(<span class="string">"scope"</span>);</span><br><span class="line">                String scope = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">if</span>(attr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    scope = attr.getStringValue();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(scope.equals(<span class="string">"singleton"</span>) || scope.equals(<span class="string">""</span>) || scope == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    beanId = element.attributeValue(<span class="string">"id"</span>);</span><br><span class="line">                    obj = Class.forName(element.attributeValue(<span class="string">"class"</span>)).newInstance();</span><br><span class="line">                    beanMap.put(beanId,obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getPerson</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beanMap.get(id) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> beanMap.get(id);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Object obj = <span class="keyword">null</span>;</span><br><span class="line">            Element element = (Element) document.selectSingleNode(<span class="string">"/persons/person[@id='"</span>+ id +<span class="string">"']"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                obj = Class.forName(element.attributeValue(<span class="string">"class"</span>)).newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试如下：分别获取两次Teacher和两个Student。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPersonFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PersonFactory pf = <span class="keyword">new</span> PersonFactory();</span><br><span class="line">    System.out.println(<span class="string">"****************"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">        Student student = (Student)pf.getPerson(<span class="string">"student"</span>);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">        Teacher teacher = (Teacher)pf.getPerson(<span class="string">"teacher"</span>);</span><br><span class="line">        System.out.println(teacher);</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试结果如下：可以看到：配置加载时，只有Teacher对象被创建；每次获得Teacher和Student时，都会创建新的Studnet对象，而Teacher的对象不变。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Teacher对象被创建了...</span><br><span class="line">****************</span><br><span class="line">Student对象被创建了....</span><br><span class="line">com.memoforward.Student@1b26f7b2</span><br><span class="line">com.memoforward.Teacher@491cc5c9</span><br><span class="line">---------------------------------</span><br><span class="line">Student对象被创建了....</span><br><span class="line">com.memoforward.Student@74ad1f1f</span><br><span class="line">com.memoforward.Teacher@491cc5c9</span><br><span class="line">---------------------------------</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Passes: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<h1 id="单例和多例对象的生命周期"><a href="#单例和多例对象的生命周期" class="headerlink" title="单例和多例对象的生命周期"></a>单例和多例对象的生命周期</h1><p>·　　这个问题只要弄懂了原理就特别简单：单例对象是在工厂类被加载时被创建的，因此生命周期与工厂类是一样的；而多例对象本质与被new出来的对象没有区别，因此当没有任何引用指向这个对象时，会被垃圾回收器回收。</p>
<ul>
<li>单例生命周期<ol>
<li>出生：当工厂被创建时被创建</li>
<li>存在：工厂类存在，单例对象一直存在</li>
<li>死亡：工厂类销毁或关闭时，单例对象被释放</li>
</ol>
</li>
<li>多例生命周期<ol>
<li>出生：当要调用该对象时被创建</li>
<li>存在：只要该对象还在使用，就一直存在</li>
<li>死亡：没有任何引用指向该对象时（该对象不再使用），被垃圾回收器回收</li>
</ol>
</li>
</ul>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　Java的工厂模式算是一种有名的设计模式了，个人十分喜欢这种设计思路，而且Spring的IOC也是这样来实现的，笔者的下一篇文章会在这篇文章的基础上讲一讲Spring的IOC。</p>
<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote>
<p>请联系邮箱：chenxingyu@bupt.edu.cn</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>slf4j+log4j2使用及log4j2配置文件解析</title>
    <url>/2019/08/28/slf4j-log4j2%E4%BD%BF%E7%94%A8%E5%8F%8Alog4j2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本篇文章主要涉及以下知识点：</p>
<ol>
<li>常用的日志框架（日志门面以及日志实现）</li>
<li>slf4j+log4j2的使用</li>
<li>log4j2的傻瓜通用配置</li>
</ol>
</blockquote>
<a id="more"></a>
<h1 id="一些问题的修改与更新"><a href="#一些问题的修改与更新" class="headerlink" title="一些问题的修改与更新"></a>一些问题的修改与更新</h1><h2 id="将日志自动保存到不同的日志文件（19-10-03更新）"><a href="#将日志自动保存到不同的日志文件（19-10-03更新）" class="headerlink" title="将日志自动保存到不同的日志文件（19-10-03更新）"></a>将日志自动保存到不同的日志文件（19-10-03更新）</h2><p>·　　自己在做项目的时候遇到了一个问题：<strong>重新运行项目，如何把日志保存到不同的log文件？</strong><br>·　　我之前写的那个模板有一个重大的问题：每次运行程序，只要日志文件没超过maxSize，log都只会记录到这个文件。但是调试的时候，这种操作令人十分不爽，因此，在查询了官网之后，给模板进行了修改。</p>
<p><font color="red"><strong>修改如下：</strong></font><br>·　　<strong>因为在普通的字符串里无法使用pattern的语法，因此使用<code>fileName=&quot;$${date:MM-dd-HH-ss}&quot;</code> 作为保存的日志名称，这样每次运行程序，日志必然会保存在不同的文件下。</strong><br>·　　实际上，我们完全可以构造两个FileAppender，这样就可以根据我们的需要来使用不同的日志文件记录方式了：本文的模板已更新，不喜可删。</p>
<h1 id="什么是slf4j和log4j2"><a href="#什么是slf4j和log4j2" class="headerlink" title="什么是slf4j和log4j2"></a>什么是slf4j和log4j2</h1><p>·　　目前开源的日志框架有很多，如logback，log4j等，这面临了一个问题：当使用不同的日志框架或者这些日志框架面临了重大更新的时候，如果其实现函数有所改变，那么旧版本的框架就会崩溃，这很不利于项目的维护和新框架的推广。因此才诞生了例如slf4j这样的<strong>日志门面</strong>。<br>·　　日志门面，顾名思义就是日志框架对外的表现形式，理论上只要日志框架实现了日志门面的接口，不管其怎么更新，开发者都不需要对项目的依赖，或者项目的代码做出过多的改变。目前还在坚持更新且性能良好的日志门面非slf4j莫属，因此强烈建议使用slf4j作为我们书写日志的接口。<br>·　　日志框架方面，logback是log4j的升级版，这两个框架与slf4j是一个开发者开发出来的，因此其整合十分之稳定。但是log4j2作为apache最新推出的日志框架，在异步记录日志的方面性能比logback要更加的优异，<del>因此本着要用就用最好的的原则</del> ，使用lo4gj2作为日志记录的框架。<br>注：log4j2只是假借了log4j之名而已，log4j的真正升级版是logback。</p>
<h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>·　　日志的环境依赖总共有4部分，分别是<strong>slf4j接口</strong>部分，<strong>log4j2的日志框架</strong>实现部分，<strong>log4j2异步日志</strong>插件部分以及s<strong>lf4j与log4j2的桥接</strong>部分。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>包名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>slf4j-api</td>
<td>目前的版本1.7就可。slf4j的接口包，我们对日志进行的所有操作都用的是这个包的API</td>
</tr>
<tr>
<td>log4j-core</td>
<td>版本必须在2.1以上，是log4j2的核心包</td>
</tr>
<tr>
<td>log4j-api</td>
<td>版本与核心包一致，log4j2的接口包，用来直接调用log4j2框架的，必须导入，不然无法与slf4j对接</td>
</tr>
<tr>
<td>log4j-web</td>
<td>版本与核心包一致，用于web项目的log4j2，阻止web项目出现警告</td>
</tr>
<tr>
<td>com.lmax.disruptor</td>
<td>版本随意，开启log4j2的异步日志记录的功能</td>
</tr>
<tr>
<td>log4j-slf4j-impl</td>
<td>版本与核心包一致，用于slf4j与log4j对接，即用slf4j的接口实现操作日志</td>
</tr>
</tbody>
</table>
</div>
<p>这里给出一份Maven完整依赖：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j2.version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">log4j2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.7.28<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j2.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j2.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-web --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j2.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.lmax/disruptor --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lmax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>disruptor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-slf4j-impl --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j2.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>·　　看多很多的博客，都没有官网的配置全面，因此给出官网传送门：<a href="https://logging.apache.org/log4j/2.x/manual/configuration.html" target="_blank" rel="noopener">log4j2官网详细配置说明</a><br>·　　本博客给出一种粘贴复制即可用的配置，并给出一些个人认为比较重要的说明。</p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>·　　基本上所有的配置都写在了Properties里，因此，只需要改Properties就可以用了（建议自定义Logger，不建议修改Appenders）。<br>Apperders里定义了两种日志记录的格式：1. 在控制台输出name=“Console”，2. 在文件输出name=“File”。使用RollingRandomAccessFileAppender是因为其性能最好，且支持日志自动归档。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://www.cnblogs.com/hafiz/p/6170701.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span> <span class="attr">name</span>=<span class="string">"MyApp"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--日志文件保存的路径--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filePath"</span> <span class="attr">value</span>=<span class="string">"src/logs/$$&#123;date:MM-dd-HH-mm-ss&#125;-untitled.log"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filePath_onlyOne"</span> <span class="attr">value</span>=<span class="string">"src/logs/untitled.log"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--日志文件归档后保存的压缩文件路径--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filePattern"</span> <span class="attr">value</span>=<span class="string">"src/logs/$$&#123;date:yyyy-MM&#125;/untitled-%d&#123;yyyy-MM-dd-HH&#125;-%i.log.zip"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--日志文档超过多大时执行翻转（即：将旧文件压缩，并用新日志文件记录）--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxSize"</span> <span class="attr">value</span>=<span class="string">"250 MB"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--记录的日志文件超过多少时，旧文件会被删除--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxFile"</span> <span class="attr">value</span>=<span class="string">"50"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--打印日志的时候是否标注日志在项目的位置信息--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useLocation"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--日志输出格式--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"layoutPattern"</span> <span class="attr">value</span>=<span class="string">"%date %p %c&#123;1.&#125; [%thread] %location %message %exception%n"</span>/&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;layoutPattern&#125;"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--		--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">RollingRandomAccessFile</span> <span class="attr">name</span>=<span class="string">"File"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;filePath&#125;"</span> <span class="attr">filePattern</span>=<span class="string">"$&#123;filePattern&#125;"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;layoutPattern&#125;"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!--基于时间的归档，一般不使用--&gt;</span></span><br><span class="line">				<span class="comment">&lt;!--这个6基于filePattern归档文件的时间，本文件归档的filePattern最后的HH表示小时，因此此文件每6个小时进行一次归档--&gt;</span></span><br><span class="line">				<span class="comment">&lt;!-- &lt;TimeBasedTriggeringPolicy interval="6" modulate="true"/&gt;--&gt;</span></span><br><span class="line">				<span class="comment">&lt;!--基于文件大小的归档--&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"$&#123;maxSize&#125;"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"$&#123;maxFile&#125;"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">RollingRandomAccessFile</span>&gt;</span></span><br><span class="line">		</span><br><span class="line">		<span class="tag">&lt;<span class="name">RollingRandomAccessFile</span> <span class="attr">name</span>=<span class="string">"OneFile"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;filePath_onlyOne&#125;"</span> <span class="attr">filePattern</span>=<span class="string">"$&#123;filePattern&#125;"</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;layoutPattern&#125;"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">				<span class="comment">&lt;!--基于文件大小的归档--&gt;</span></span><br><span class="line">				<span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"$&#123;maxSize&#125;"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"$&#123;maxFile&#125;"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">RollingRandomAccessFile</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!--这个只能自行配置了--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--异步日志Root（与同步Root之间只能存在一个）--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--		&lt;AsyncRoot level="DEBUG" includeLocation="$&#123;useLocation&#125;"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--			&lt;AppenderRef ref="Console"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--			&lt;AppenderRef ref="File"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--		&lt;/AsyncRoot&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--		        同步Root--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"INFO"</span> &gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"File"</span>/&gt;</span></span><br><span class="line">			<span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line">		<span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--异步日志(与同步日志可同时存在)--&gt;</span></span><br><span class="line">		<span class="comment">&lt;!--name属性值请自定义--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--		&lt;AsyncLogger name="AsyncLogger" level="DEBUG" includeLocation="$&#123;useLocation&#125;" additivity="false"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--			&lt;AppenderRef ref="File"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--		&lt;/AsyncLogger&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--		同步日志--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--		&lt;Logger name="com.memoforward.dao" level="DEBUG" includeLocation="$&#123;useLocation&#125;" additivity="false"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--			&lt;AppenderRef ref="Console"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--		&lt;/Logger&gt;--&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="配置的简单说明："><a href="#配置的简单说明：" class="headerlink" title="配置的简单说明："></a>配置的简单说明：</h2><h3 id="RollingRandomAccessFile标签"><a href="#RollingRandomAccessFile标签" class="headerlink" title="RollingRandomAccessFile标签"></a>RollingRandomAccessFile标签</h3><ul>
<li><p>RollingRandomAccessFile的三个属性的含义：</p>
<ol>
<li>name：这个Appender的引用名</li>
<li>fileName：日志文件的路径及名称（文件夹或文件不存在就自动创建）</li>
<li>filePattern：日志归档后的文件的保存路径和名称（如果加了.zip就自动压缩）</li>
</ol>
</li>
<li><p>RollingRandomAccessFile必须配置的两个字标签：</p>
<ol>
<li>TriggerPolicy：文件翻转触发机制。翻转的意思就是旧文件保存（归档），另起新文件进行记录。 <ul>
<li>在上述配置文件中，其触发机制是SizeBasedTriggeringPolicy，即：当文件大小超过一定阈值后，进行自动保存</li>
</ul>
</li>
<li>RolloverStrategy：文件翻转策略。<ul>
<li>在上述配置文件中，其策略是默认策略，当归档的文件数量达到一定数值后，就自动删除旧文件（如果不配置，则默认为7）</li>
</ul>
</li>
</ol>
</li>
</ul>
<ul>
<li><strong>测试代码如下</strong>：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4j2Test</span> </span>&#123;</span><br><span class="line"><span class="comment">//    private static final Logger logger = LoggerFactory.getLogger(Log4j2Test.class);</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="string">"AsyncLogger"</span>);</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++)&#123;</span><br><span class="line">            logger.error(Integer.toString(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>测试结果如下</strong><br>设置了保存的文件最大为1KB，最大保存文件数量为10，保存500条日志。每篇日志能保存9条语句。<br><img src="https://img-blog.csdnimg.cn/20190828194222737.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li>
</ul>
<ul>
<li><strong>untitled.log输出如下</strong>：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">2019-08-28 19:16:52,248 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 491 </span><br><span class="line">2019-08-28 19:16:52,248 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 492 </span><br><span class="line">2019-08-28 19:16:52,248 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 493 </span><br><span class="line">2019-08-28 19:16:52,248 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 494 </span><br><span class="line">2019-08-28 19:16:52,248 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 495 </span><br><span class="line">2019-08-28 19:16:52,248 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 496 </span><br><span class="line">2019-08-28 19:16:52,249 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 497 </span><br><span class="line">2019-08-28 19:16:52,250 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 498 </span><br><span class="line">2019-08-28 19:16:52,250 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 499</span><br></pre></td></tr></table></figure>
<p>·　　可见，如果不设置翻转的机制，要么会在一个日志文件内记录所有的数据，要么仅会保存7条归档的日志。一般情况下，希望能把所有的归档日志文件都保存下来，因此RolloverStragety的值要设置的大一点。</p>
<h3 id="Logger的配置"><a href="#Logger的配置" class="headerlink" title="Logger的配置"></a>Logger的配置</h3><p>·　　Logger分为同步和异步，只有一个RootLogger。异步的实现就是我们之前引入的那个<strong>com.lmax.disruptor</strong>包，当我们启用异步日志记录的时候，就会新建一个Disruptor对象，具体的日志记录流程建议参考这位大佬的文章:<a href="https://www.cnblogs.com/yeyang/p/7944906.html" target="_blank" rel="noopener">Log4j2中的同步日志与异步日志</a>。</p>
<ul>
<li><p>Logger中属性的含义：</p>
<ol>
<li>name：在代码getLogger的名字，root没有此属性。</li>
<li>level：日志的打印级别为”<strong>OFF&gt;FATAL&gt;ERROR&gt;WARN&gt;INFO&gt;DEBUG&gt;TRACE</strong>“。logger在记录日志的时候，只会记录level界别及以上的日志内容(OFF永远不会打印)。如设置了ERROR，只会打印FATAL和ERROR。</li>
<li>includeLoacation：日志打印的时候是否会输出位置（打印位置会降低性能）。</li>
<li>additivity：root没有，配置此属性值为true来避免重复打印（如果为false，root会重复打印一次相同级别的日志），至于为什么会重复打印，还是建议大家看一下官方文档，这里不赘述了。</li>
</ol>
</li>
<li><p>Logger的子标签<br>  1.&lt; AppenderRef ref=”xxx” &gt; 表示这个logger将用到何种Appender，ref内写Appender的name属性值。</p>
</li>
</ul>
<h3 id="PatternLayout解释"><a href="#PatternLayout解释" class="headerlink" title="PatternLayout解释"></a>PatternLayout解释</h3><p>·　　本配置文件默认的layoutPattern为：<strong>%date %p %c{1.} [%thread] %location %message %exception%n</strong><br>·　　官网有特别特别详细的说明文档，我这个都是对着官网写出来的，特别好理解，强烈建议大家对看文档。传送门：<a href="https://logging.apache.org/log4j/2.x/manual/layouts.html" target="_blank" rel="noopener">log4j2的LayoutPattern</a>；本博客就只介绍一下上面的这行配置。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>格式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>%date</td>
<td>输出日期和时间：yyyy-MM-dd HH:mm:ss,SSS（年-月-日 时：分：秒，毫秒）</td>
</tr>
<tr>
<td>%p</td>
<td>输出日志的打印级别</td>
</tr>
<tr>
<td>%c{1.}</td>
<td>输出该日志所处的缩略类路径</td>
</tr>
<tr>
<td>%[thread]</td>
<td>打印执行该日志记录的线程名</td>
</tr>
<tr>
<td>%location</td>
<td>打印日志语句在项目代码中的位置</td>
</tr>
<tr>
<td>%message</td>
<td>日志内容</td>
</tr>
<tr>
<td>%exception</td>
<td>如果出现了异常，则打印异常</td>
</tr>
<tr>
<td>%n</td>
<td>类似于/n，是换行符</td>
</tr>
</tbody>
</table>
</div>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　日志记录一直是一个很尴尬的点，感觉不难，但一直理解不是很深刻，其实我们最常用的就是把日志输出到控制台或者输出到文件，私以为只要把这两个方面搞明白了就行。以后做项目，尽量就用slf4j+log4j2来记录日志啦。</p>
<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote>
<p>请联系邮箱：chenxingyu@bupt.edu.cn</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java - 日志框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中XML文件的解析（Dom4j+Xpath）</title>
    <url>/2019/08/27/Java%E4%B8%ADXML%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%88Dom4j-Xpath%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本篇文章主要介绍了如何用Dom4j+Xpath解析XML文件<br>XML的解析在Java的框架源码中十分常用，因此学会解析XML文件是必要的</p>
</blockquote>
<a id="more"></a>
<h1 id="XML文件"><a href="#XML文件" class="headerlink" title="XML文件"></a>XML文件</h1><p>·　　XML文件是一种可扩展标记语言。做后台开发接触到的XML文件一般是以配置文件的身份登场，虽说现在几乎不用我们自行解析XML配置文件，但是技多不压身，万一哪天我们需要自己开发框架了，这门技能就成为了必须。</p>
<h2 id="XML文件格式"><a href="#XML文件格式" class="headerlink" title="XML文件格式"></a>XML文件格式</h2><p>·　　XML文件的格式非常简单，第一行是文件声明，后面就是我们自行添加的内容。书写XML文件有几点注意事项：</p>
<ul>
<li>必须有声明</li>
<li>标签区分大小写</li>
<li>只有一个根元素（根标签）</li>
<li>属性可以自定义，属性值必须添加引号</li>
<li>必须有结束标志(&lt;/&gt;)</li>
</ul>
<p>·示例如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> <span class="comment">&lt;!-- 声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span><span class="comment">&lt;!-- 自定义根元素，有且仅有一个 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentService"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.service.StudentService"</span>&gt;</span> <span class="comment">&lt;!-- 自定义子元素，自定义属性名和属性值--&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"studentDao"</span> <span class="attr">ref</span>=<span class="string">"studentDao"</span>/&gt;</span> <span class="comment">&lt;!-- 子元素下依然可以有子元素，xml可以无限层--&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="comment">&lt;!--结束标志--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentDao"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.dao.StudentDao"</span>/&gt;</span> <span class="comment">&lt;!-- 结束标志的另一种写法--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">beanTest</span> &gt;</span>beanTestValue<span class="tag">&lt;/<span class="name">beanTest</span>&gt;</span><span class="comment">&lt;!--一般情况下，xml标签是有标签值的--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>·　　由上面的格式可知，其实XML与HTML相差并不大，我们访问和操作HTML文档使用的工具是HTML DOM 树。异曲同工，Dom4j也参照了这种方法，其使用SAXReader对象将整个XML文档读取，构建出了document树对象。通过这个树对象，配合上XPath工具，我们就可以很轻松地访问到整个文件的所有节点的数据了，其中节点（元素）就是Element对象，节点中的属性就是Atrribute对象。<br>·　　所以，解析XML的步骤就是：<strong>创建SAXReader对象 — SAXReader获取XML文件的Document树对象 — document树获取Element元素对象 — Element元素对象获取其元素的属性Attribute对象</strong>。这一套流程下来，基本想读取什么值都可以。</p>
<h1 id="解析XML文件"><a href="#解析XML文件" class="headerlink" title="解析XML文件"></a>解析XML文件</h1><p>·　　本博客使用Dom4j+Xpath来解释XML文件。使用这种方式需要引入两个jar包，一个是dom4j包，另一个是Xpath通用引擎包jaxen。注：如果xml文件不大，推荐使用此种方式解析xml文件（因为使用简单方便）；如果XML巨大，可以使用JDK自带的SAX解析器去“边读边写”提高效率，但因为其操作比较复杂，需要定义自己的处理器，本博客就不描述此种方法了。<br>其Maven依赖如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/dom4j/dom4j --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- https://mvnrepository.com/artifact/jaxen/jaxen --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h2><p>·　　在正式开始解析之前，不得不介绍一下Xpath是为何物。<br>·　　XPath 是一门在 XML 文档中查找信息的语言，用于在 XML 文档中对元素和属性进行遍历。XPath 使用<strong>路径表达式</strong>来选取 XML 文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似。<br>·　　由上述概念可知，我们解析XML文件的核心就在于：<strong>使用XPath的路径表达式在document树对象中检索节点。</strong><br>·　　树对象的获取在1.2节已经介绍了，非常简单，因此难点就在于路径表达式的语法了。</p>
<h3 id="路径表达式语法"><a href="#路径表达式语法" class="headerlink" title="路径表达式语法"></a>路径表达式语法</h3><p>·　　Xpath是W3C的一个标准，因此W3School的在线教程网站上就有，传送门如下：<a href="https://www.w3school.com.cn/xpath/xpath_syntax.asp" target="_blank" rel="noopener">W3CXpath语法</a><br>·<strong>最有用的路径表达式如下</strong>：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>表达式</th>
<th>描述</th>
<th>使用(依据上图的示例)</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td>nodename</td>
<td>选取此节点下所有的子节点</td>
<td>beans</td>
<td>表示beans元素下所有的子节点</td>
</tr>
<tr>
<td>/</td>
<td>表示从根节点开始选取</td>
<td>/beans/bean</td>
<td>表示从根节点开始找到所有beans下所有名为bean的子节点</td>
</tr>
<tr>
<td>//</td>
<td>不管节点在什么位置，选取该节点</td>
<td>//property</td>
<td>表示选取property节点，不管它在什么位置</td>
</tr>
<tr>
<td>.</td>
<td>选取当前节点</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>..</td>
<td>选取当前节点的父节点</td>
<td>/</td>
<td>/</td>
</tr>
<tr>
<td>@</td>
<td>选取属性</td>
<td>一般用于谓语中</td>
<td>/</td>
</tr>
</tbody>
</table>
</div>
<p>·<strong>谓语</strong><br>·　　谓语用来查找某个特定的节点或者包含某个指定的值的节点。谓语被嵌在方括号中。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>路径表达式</th>
<th>结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>/beans/bean[1]</td>
<td>选取beans子元素下的第一个bean元素</td>
</tr>
<tr>
<td>/beans/bean[@id=”studentDao”]</td>
<td>选取beans子元素下的属性值为studentDao的bean元素</td>
</tr>
</tbody>
</table>
</div>
<h2 id="解析XML文件实例"><a href="#解析XML文件实例" class="headerlink" title="解析XML文件实例"></a>解析XML文件实例</h2><ul>
<li>首先获取SAXReader对象，此对象在dom4j包中：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br></pre></td></tr></table></figure>
<ul>
<li>再从这个对象获取XML文件的document树对象：使用<strong>saxReader.read(…)</strong>；此函数可以传入两个对象，如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Document document = saxReader.read(File io);</span><br><span class="line">Document document = saxReader.read(InputStream in);</span><br></pre></td></tr></table></figure>
<p>·　　这个两个入参具体使用哪一个看个人喜好，我本人比较喜欢传入InputStream，因为传入File对象需要给出文件相对项目的路径或者绝对路径，不太方便移植。而文件流可以直接从类加载器中获得，只需要保证项目在类路径下即可。</p>
<ul>
<li>获取文件流代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLTest</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> InputStream in;</span><br><span class="line">    	<span class="keyword">static</span>&#123;</span><br><span class="line">       		in = XMLTest.class.getClassLoader().getResourceAsStream("beans.xml");</span><br><span class="line">    	&#125;</span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">testDom4j</span><span class="params">()</span></span>&#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>解析需求如下：</li>
</ul>
<blockquote>
<ol>
<li>获取所有的Bean标签，并获得其下面所有class属性值</li>
<li>获取id=studentSerivce的bean元素，并获得property的ref属性</li>
<li>得到beanTest元素的值</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestDom4j</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        Document document = saxReader.read(in);</span><br><span class="line">        <span class="comment">//1.获得bean标签，并得到他们class的属性值</span></span><br><span class="line">        ArrayList&lt;String&gt; beans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//找到beans元素下的bean的节点</span></span><br><span class="line">        <span class="comment">//List里面的元素应该是Node，但是Element对象继承了Node，因此可以强制转换</span></span><br><span class="line">        List&lt;Element&gt; beanList = document.selectNodes(<span class="string">"/beans/bean"</span>);</span><br><span class="line">        <span class="keyword">for</span>(Element bean:beanList)&#123;</span><br><span class="line">            beans.add(bean.attributeValue(<span class="string">"class"</span>));</span><br><span class="line">            <span class="comment">//获取class属性值的第二种写法</span></span><br><span class="line"><span class="comment">//            Attribute attr = bean.attribute("class");</span></span><br><span class="line"><span class="comment">//            beans.add(attr.getStringValue());</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"bean中的class属性值为："</span> + beans);</span><br><span class="line">        <span class="comment">//2.获取id=studentService的bean元素,并获得其下元素property的属性name值为studentDao的属性ref的值</span></span><br><span class="line">        <span class="comment">//Node对象强制转化成Element</span></span><br><span class="line">        Element p01 = (Element)document.selectSingleNode(<span class="string">"/beans/bean[@id='studentService']/property[@name='studentDao']"</span>);</span><br><span class="line">        System.out.println(<span class="string">"property属性ref的值："</span> + p01.attributeValue(<span class="string">"ref"</span>));</span><br><span class="line">        <span class="comment">//3.得到beanTest元素的值</span></span><br><span class="line">        Element beanTest = (Element) document.selectSingleNode(<span class="string">"/beans/beanTest"</span>);</span><br><span class="line">        System.out.println(<span class="string">"beanTest的值"</span> + beanTest.getStringValue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试结果如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[TestNG] Running:</span><br><span class="line">  C:\Users\handsomestar\.IntelliJIdea2019.1\system\temp-testng-customsuite.xml</span><br><span class="line">bean中的class属性值为：[com.memoforward.service.StudentService, com.memoforward.dao.StudentDao]</span><br><span class="line">property属性ref的值：studentDao</span><br><span class="line">beanTest的值beanTestValue</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　解析XML文件还是相当简单的，其实就是一个树的读取，很快就能上手。</p>
<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote>
<p>请联系邮箱：chenxingyu@bupt.edu.cn</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java注解学习笔记和案例使用</title>
    <url>/2019/08/25/Java%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%92%8C%E6%A1%88%E4%BE%8B%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本篇文章主要讲解了Java中注解的使用<br>本文比较基础<br>写本文的目的是为了在使用注解开发的时候知己知彼</p>
</blockquote>
<a id="more"></a>
<h1 id="Java中的注解"><a href="#Java中的注解" class="headerlink" title="Java中的注解"></a>Java中的注解</h1><p>·　　现在使用框架的趋势是使用注解式开发，注解式开发简单高效。但是知己知彼方能百战不殆，了解和熟悉注解能够让我们更加深入地看懂框架以及记住框架的使用方法。本文章对注解进行了一些简单的总结并实现了一个利用注解进行方法自动化测试的小案例。<br>本节内容涉及一点反射相关的知识，可移步：<a href="https://blog.csdn.net/qq_34294121/article/details/100045782" target="_blank" rel="noopener">反射讲解及案例</a> 进行查看。</p>
<h2 id="一句话概括"><a href="#一句话概括" class="headerlink" title="一句话概括"></a>一句话概括</h2><p>·　　注解和注释有异曲同工之妙。注释告诉程序员：一个类、一个方法或者一个变量有何作用；而注解则告诉计算机：一个类、一个方法或者一个变量需要进行何种操作。举一个最简单不过的例子：大家耳熟能详的@Override注解则是告诉计算机，某个方法重写了该类父类的方法，若计算机无法找到其父类对应的方法，那么IDE在运行时就会报错。</p>
<h2 id="JDK内置注解"><a href="#JDK内置注解" class="headerlink" title="JDK内置注解"></a>JDK内置注解</h2><ul>
<li>@Override：检测被注解标注的方法是否继承至父类</li>
<li>@Deprecated：表明被该注解标注的内容已过时</li>
<li>@SuppressWarnings(“all”)：压制被该注解标注内容的所有警告（常见的警告有：使用的方法已过时，声明的方法未使用等）</li>
</ul>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><h3 id="注解的声明"><a href="#注解的声明" class="headerlink" title="注解的声明"></a>注解的声明</h3><p>·　　Java中是支持自定义注解的，声明方式如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> xxx&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>`　　这种声明方式的本质是：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">xxx</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>·　　说明注解的本质其实是一个接口。有接口就会有方法：规定在接口中定义的方法叫做属性。后面可以看到，这些接口的方法本质上是要传值的。我们用@SuppressWarnins(“all”)为例，可以看到，这个注解被人为传入了值，其源码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>·　　该注解上面的两个注解我们会在下文提到，现在只需要关注在SuppressWarnings注解里定义的属性，该方法返回一个String数组，如果我们在使用SuppressWarings时给该数组传入特定的值，则IDE在运行时就知道该压制何种类型的警告。不过针对@SuppressWarings，我们只需记住传入“all”来压制所有警告就行。注意，其实在@SuppressWarings（“all”）中，我们的书写方式有所省略，完整的书写格式应该如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@SuppressWarings</span>(value = &#123;<span class="string">"all"</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>·　　原则上，属性名（即方法名）需要在注解声明时写出，如果返回值是数组，需要将值用{}包裹。但是这里有特殊情况，即：属性有且仅有一个，且名为“value”，则属性名可忽略写；如果需要传入数组的值只有一个，则{}也可以省略。</p>
<h3 id="注解属性的返回值"><a href="#注解属性的返回值" class="headerlink" title="注解属性的返回值"></a>注解属性的返回值</h3><p> ·　　注解属性的返回值类型只可以是以下几种：</p>
<blockquote>
<ul>
<li>基本数据类型</li>
<li>String</li>
<li>枚举</li>
<li>注解</li>
<li>以上类型的数组</li>
</ul>
</blockquote>
<p> ·　　只有以上的几种类型可以作为注解属性存在，我们自定义注解一般只会使用String，或者干脆不写属性。</p>
<h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>·　　元注解是描述注解的注解，用于注解之上，刚才我们查看的@SuppressWarings注解的源码就可以看到：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>·　　此时可以看到在SuppressWarnings上有两个注解，这就是元注解。<br>·　　元注解一般使用四个，分别是：</p>
<ul>
<li><strong>@Target</strong>：用于描述注解可以作用的位置，其属性值是一个枚举类型Element的数组。一般使用该枚举类型的值有三个：<br>  　　- ElementType.TYPE：该注解只能作用在类上<br>  　　- ElementType.METHOD：该注解只能作用在方法上<br>  　　- ElementType.FIELD：该注解只能作用在成员变量上</li>
<li><strong>@Retention</strong>：用于描述注解被保留的阶段（Source阶段，Class阶段，Runtime阶段，这三个阶段在我之前讲反射的文章中有提及，可以去<a href="https://blog.csdn.net/qq_34294121/article/details/100045782" target="_blank" rel="noopener">反射讲解</a>中学习），这个注解的属性值是一个枚举类型RetentionPolicy的数组。其枚举类型的值只有三个，分别是：<br>  　　- RetentionPolicy.SOURCE<br>  　　- RetentionPolicy.CLASS<br>  　　- <strong>RetentionPolicy.RUNTIME</strong> （我们自定义注解，一般只是用RUNTIME）</li>
<li><strong>@Document</strong>：用于描述该注解是否会会被文档给记录。（使用文档注释后，在命令行使用javadoc命令就可以生成代码文档，但是注解默认是不保留在文档里的，如果想要被文档记录，则应加上该注解）</li>
<li><strong>@Inherited</strong>：描述该注解是否会自动被子类继承</li>
</ul>
<h2 id="为何要用方法传递值？"><a href="#为何要用方法传递值？" class="headerlink" title="为何要用方法传递值？"></a>为何要用方法传递值？</h2><p>·　　在接口中，可以声明值，也可以声明方法，声明代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">xxx</span></span>&#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String = <span class="string">"常量"</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getChangeableValue</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>·　　可见，在接口中只能声明常量，如果要传入不同的属性值来降低代码的重复率，只能采用调用方法的形式。因此注解的声明中不允许声明常量。</p>
<h2 id="注解的解析"><a href="#注解的解析" class="headerlink" title="注解的解析"></a>注解的解析</h2><p>·　　之前我们提到，注解是给计算机“看”的，那么计算机是如何识别注解的呢？该节运用到了一些反射的知识，可以去<a href="https://blog.csdn.net/qq_34294121/article/details/100045782" target="_blank" rel="noopener">反射讲解</a>学习反射。<br>·　　一般情况下，我们书写的注解都在RUNTIMME的阶段被解析，而在这个阶段，系统已经得到所有类的字节码Class对象，Class对象能直接从字节码中获得作用在它上面的注解对象，而在Class对象中，有Field，Method和Construct三个封装对象，这个三个对象也都可以在字节码文件中找到作用在它们上方的注解对象。而获取注解的属性值则是通过自动构建该注解的子类对象，并重写注解方法得到的。文字比较晦涩，还是代码看的清楚，下面将给出一个关于注解解析的小案例（通过注解方式构建某个类的对象）：</p>
<ul>
<li>首先构建需要操作的类对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.domain;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"江锦平"</span>;</span><br><span class="line">        <span class="keyword">this</span>.gender = <span class="string">"男"</span>;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String gender, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"长生不老+1+1+1...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">(String num)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"寿命延长："</span>+num+<span class="string">"s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>构造注解</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD) <span class="comment">//表明该注解只能作用在方法上</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">//表明该注解的作用时间是在RUNTIME阶段</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Prop &#123;</span><br><span class="line">    <span class="function">String <span class="title">beanClass</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>写测试代码</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Prop</span>( beanClass = <span class="string">"com.memoforward.domain.Student"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnotationProp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//目的：获取到注解的值，并利用该值得到实例对象</span></span><br><span class="line">    <span class="comment">//第一步：获取该测试类的字节码对象</span></span><br><span class="line">    Class&lt;AnnotationTest&gt; clazz = AnnotationTest<span class="class">.<span class="keyword">class</span></span>; <span class="comment">//测试类的名称为Annotation</span></span><br><span class="line">    <span class="comment">//第二步：从字节码对象中获取到该方法</span></span><br><span class="line">    Method md = clazz.getMethod(<span class="string">"testAnnotationProp"</span>);</span><br><span class="line">    <span class="comment">//第三步，从此方法中获取到压在方法上的注解</span></span><br><span class="line">    <span class="comment">//此步骤会自动生成该注解的实现类，并重写注解的方法</span></span><br><span class="line">    Prop annotation = md.getAnnotation(Prop<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//得到类名</span></span><br><span class="line">    String beanClass = annotation.beanClass();</span><br><span class="line">    <span class="comment">//创建实例</span></span><br><span class="line">    Student stu = (Student) Class.forName(beanClass).newInstance();</span><br><span class="line">    System.out.println(stu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试代码输出，可以看到Student对象已被成功创建，实际上，代码只需稍作修改后，该注解便可以创建任何类的对象，读者有兴趣可以自行操作。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[TestNG] Running:</span><br><span class="line">  C:\Users\handsomestar\.IntelliJIdea2019.1\system\temp-testng-customsuite.xml</span><br><span class="line">Student&#123;name&#x3D;&#39;江锦平&#39;, gender&#x3D;&#39;男&#39;, age&#x3D;999&#125;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<h2 id="注解的小案例"><a href="#注解的小案例" class="headerlink" title="注解的小案例"></a>注解的小案例</h2><p>·　　此案例旨在利用注解实现一个自动化测试的程序，目标是如果某个类的方法加上了@Check注解，那么这个程序就可以自动化实现对这个类的测试，并将测试的异常记录在log日志中。本案例使用的日志框架是slf4j+log4j2。</p>
<ul>
<li>@Check注解如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>需要测试的类如下：</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.operate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.memoforward.annotation.Check;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedToCheck</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">100</span> + <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">"100 + 100 = "</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(str.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">div</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">100</span> / <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">"100 - 100 = "</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(a[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"没有错误..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>·　　上述的类共有5个方法，需要被Check的有4个方法，很显然这4个方法中共会出现三个异常：1. print()方法的空指针异常； 2. div()方法的除0异常；3. useArray()方法的数组越界异常</p>
<ul>
<li>自动化测试代码如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnoatationCheck</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="comment">//创建需要被测试的类的实例</span></span><br><span class="line">    NeedToCheck ntc = <span class="keyword">new</span> NeedToCheck();</span><br><span class="line">    Class clazz = ntc.getClass();</span><br><span class="line">    <span class="comment">//得到该类的所有方法</span></span><br><span class="line">    Method[] mds = clazz.getMethods();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(Method md : mds)&#123;</span><br><span class="line">    	<span class="comment">//检查该方法是否有@Check注解</span></span><br><span class="line">        <span class="keyword">if</span>(md.isAnnotationPresent(Check<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">            	<span class="comment">//如果标注了@Check注解，则检查该方法</span></span><br><span class="line">                md.invoke(ntc);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            	<span class="comment">//若出现异常则打印异常</span></span><br><span class="line">                logger.error(md.getName() + <span class="string">"出现了异常"</span>);</span><br><span class="line">                logger.debug(<span class="string">"异常名称为："</span>+ e.getCause().getClass().getSimpleName());</span><br><span class="line">                logger.debug(<span class="string">"异常原因为："</span> + e.getCause().getMessage());</span><br><span class="line">                logger.debug(<span class="string">"-------------------------"</span>);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.debug(<span class="string">"本次测试出现了"</span>+count+<span class="string">"次异常"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>·　　如果各位不想用日志框架就直接用System.out.println()打印异常也可以，证明这个测试时可用的就行。</p>
<ul>
<li>控制台输出结果如下，可以看到没有被@Check标注的success没有执行。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[TestNG] Running:</span><br><span class="line">  C:\Users\handsomestar\.IntelliJIdea2019.1\system\temp-testng-customsuite.xml</span><br><span class="line">100 + 100 &#x3D; 200</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<ul>
<li>日志文件输出如下，所有异常均被捕获。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.696</span> ERROR AnnotationTest <span class="number">46</span> testAnnoatationCheck - print出现了异常</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.703</span> DEBUG AnnotationTest <span class="number">47</span> testAnnoatationCheck - 异常名称为：NullPointerException</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.703</span> DEBUG AnnotationTest <span class="number">48</span> testAnnoatationCheck - 异常原因为：<span class="keyword">null</span></span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.704</span> DEBUG AnnotationTest <span class="number">49</span> testAnnoatationCheck - -------------------------</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.704</span> ERROR AnnotationTest <span class="number">46</span> testAnnoatationCheck - useArray出现了异常</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.705</span> DEBUG AnnotationTest <span class="number">47</span> testAnnoatationCheck - 异常名称为：ArrayIndexOutOfBoundsException</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.705</span> DEBUG AnnotationTest <span class="number">48</span> testAnnoatationCheck - 异常原因为：<span class="number">2</span></span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.705</span> DEBUG AnnotationTest <span class="number">49</span> testAnnoatationCheck - -------------------------</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.705</span> ERROR AnnotationTest <span class="number">46</span> testAnnoatationCheck - div出现了异常</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.705</span> DEBUG AnnotationTest <span class="number">47</span> testAnnoatationCheck - 异常名称为：ArithmeticException</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.705</span> DEBUG AnnotationTest <span class="number">48</span> testAnnoatationCheck - 异常原因为：/ by zero</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.706</span> DEBUG AnnotationTest <span class="number">49</span> testAnnoatationCheck - -------------------------</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.706</span> DEBUG AnnotationTest <span class="number">54</span> testAnnoatationCheck - 本次测试出现了<span class="number">3</span>次异常</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>·　　注解算是Java基础的一个增强，非常简单，但是如果没有理解的话，看源码还是有些许的头疼，不过一旦学会，应该不容易遗忘，希望今后在运用框架的时候能快速熟练掌握注解式开发这一技能。</p>
<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote>
<p>请联系邮箱：chenxingyu@bupt.edu.cn</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射讲解与案例实战</title>
    <url>/2019/08/24/Java%E5%8F%8D%E5%B0%84%E8%AE%B2%E8%A7%A3%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>本文章旨在讲解一下java的反射机制和概念，以及利用反射原理制造一个简单的框架<br>框架内容：能够用一个getBean(String id)方法，创建任何的Bean对象）。</p>
</blockquote>
<a id="more"></a>
<p>github源码传送门：<a href="https://github.com/MemoForward/ReflectDemo01" target="_blank" rel="noopener">github反射案例</a>
　　</p>
<h2 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h2><p>·　反射是框架设计的灵魂，反射的机制是将一个类的<strong>各个组成部分</strong>封装成其他的对象保存在Class类对象中。<br>·　Java的类在计算机中会经历三个阶段：</p>
<ul>
<li><strong>源代码阶段</strong>：我们编写的某个类经过javac指令编译后生成了.class字节码文件，这些文件存储在硬盘上</li>
<li><strong>类对象阶段</strong>：类加载器ClassLoader将字节码文件加载进内存中，由一个Class类对象保存这个类<strong>各个组成部分</strong>的所有信息：<ul>
<li>该类的成员变量封装成 Field[] 对象</li>
<li>该类的构造方法封装成 Constructor[] 对象</li>
<li>该类的成员方法封装成 Method[] 对象</li>
</ul>
</li>
<li><strong>Runtime运行时阶段</strong>：通过类对象创建该类的实例并使用</li>
</ul>
<p>·　反射的优势：可以给代码解耦，提高程序的可扩展性。</p>
<h2 id="获取字节码Class对象"><a href="#获取字节码Class对象" class="headerlink" title="获取字节码Class对象"></a>获取字节码Class对象</h2><p>·　　由上一节可知，在运行阶段创建类的实例是需要通过Class对象的，要利用反射机制必然要使用这个对象，而获取这个对象有三种方式：</p>
<ul>
<li>使用 Class.forName(“全类名”)</li>
<li>使用 类名.class</li>
<li>使用 实例.getClass()<br>·　　一个 .class 字节码文件被ClassLoader加载进内存之后，类的所有信息（Class对象）都存在<strong>方法区</strong>中，一个类的信息只有会一块内存存储，<strong>因此，无论利用哪种方法获取到某个类的Class对象，该对象都只指向一块内存</strong>。注：方法区是不同于堆的一块内存空间，一般不会被垃圾回收器回收。<br>·　　以下是利用三种方法获取到class对象的代码，并判断了它们是否指向同一块内存。</li>
<li>类定义如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//该区域为所定义的类：所在的包为com.memoforward</span></span><br><span class="line"><span class="keyword">package</span> com.memforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"江锦平"</span>;</span><br><span class="line">        <span class="keyword">this</span>.gender = <span class="string">"男"</span>;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String gender, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"长生不老+1+1+1...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">(String num)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"寿命延长："</span>+num+<span class="string">"s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//toString</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>测试代码如下</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用了testNG进行了测试</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getClassTest</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//方法一</span></span><br><span class="line">        Class clazz1 = Class.forName(<span class="string">"com.memforward.Student"</span>);</span><br><span class="line">        System.out.println(<span class="string">"clazz1:"</span> + clazz1);</span><br><span class="line">        <span class="comment">//方法二</span></span><br><span class="line">        Class clazz2 = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(<span class="string">"clazz2:"</span> + clazz2);</span><br><span class="line">        <span class="comment">//方法三</span></span><br><span class="line">        Class clazz3 = <span class="keyword">new</span> Student().getClass();</span><br><span class="line">        System.out.println(<span class="string">"clazz3:"</span> + clazz3);</span><br><span class="line">        <span class="comment">//判断是否指向同一个对象 ，都返回true</span></span><br><span class="line">        System.out.println(clazz1 == clazz2);</span><br><span class="line">        System.out.println(clazz2 == clazz3);</span><br><span class="line">        System.out.println(clazz1 == clazz3);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>其输出为：</strong><br>　　<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[TestNG] Running:</span><br><span class="line">  C:\Users\handsomestar\.IntelliJIdea2019.1\system\temp-testng-customsuite.xml</span><br><span class="line">clazz1:class com.memforward.Student</span><br><span class="line">clazz2:class com.memforward.Student</span><br><span class="line">clazz3:class com.memforward.Student</span><br><span class="line">true  </span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure></p>
<h2 id="使用Class对象"><a href="#使用Class对象" class="headerlink" title="使用Class对象"></a>使用Class对象</h2><p>·　　Class对象中封装了一个类的<strong>成员变量、构造方法和成员方法</strong>。一般情况下，我们需要获得和使用的就是这三个部分的值，诚然一个Class对象中有很多的方法，但是我们最常用的只有以下几种：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//获取成员变量</span></span><br><span class="line"> Field[] getFields() </span><br><span class="line"> Field[] getDeclaredFields() </span><br><span class="line"> <span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span>  </span></span><br><span class="line"><span class="function"> Field <span class="title">getDeclaredField</span><span class="params">(String name)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//获取构造方法</span></span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getConstructors</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getDeclaredConstructors</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取成员方法</span></span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//获取类名</span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//获取类加载器</span></span></span><br><span class="line"><span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>
<p>·　看上面的方法可知，Class对象既可以得到该类的对应的<em>组成部分</em>的数组，也可以定向找到某项属性。声明了Declared的方法则可以得到该类的私有声明的信息。<br>·　该类的组成部分被封装在了Field、Constructor和Method对象，很显然这些对象有各自的用途：Field可以用来获取和设置某个实例成员变量的值；Constructor可以用来创建该类的实例对象；Method方法可以用来调用该类实例的方法。<br>以下为这三个对象的测试：</p>
<h3 id="Field对象的测试"><a href="#Field对象的测试" class="headerlink" title="Field对象的测试"></a>Field对象的测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Field对象的测试</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testField</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(<span class="string">"-----------getFields------------"</span>);</span><br><span class="line">        Field[] fields01 = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field: fields01) System.out.println(field);</span><br><span class="line">        System.out.println(<span class="string">"-----------getDeclaredFileds----"</span>);</span><br><span class="line">        Field[] fields02 = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field:fields02) System.out.println(field);</span><br><span class="line">        System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">        Field nameField = clazz.getField(<span class="string">"name"</span>);</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"原来的stu："</span> + stu);</span><br><span class="line">        <span class="comment">//通过Filed获得实例的值</span></span><br><span class="line">        String sname = (String)nameField.get(stu);</span><br><span class="line">        <span class="comment">//通过Field设置实例的值</span></span><br><span class="line">        nameField.set(stu, <span class="string">"胡近民"</span>);</span><br><span class="line">        <span class="comment">//如果要获取私有的值</span></span><br><span class="line">        Field ageField = clazz.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">        <span class="comment">//操作私有的值必须要开启权限，暴力反射</span></span><br><span class="line">        ageField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        ageField.set(stu,<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"修改后的stu："</span> + stu);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>Field测试的输出：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[TestNG] Running:</span><br><span class="line">  C:\Users\handsomestar\.IntelliJIdea2019.1\system\temp-testng-customsuite.xml</span><br><span class="line">-----------getFields------------</span><br><span class="line">public java.lang.String com.memforward.Student.name</span><br><span class="line">public java.lang.String com.memforward.Student.gender</span><br><span class="line">-----------getDeclaredFileds----  &#x2F;&#x2F;这里可以看到private属性的age也被获取到了</span><br><span class="line">public java.lang.String com.memforward.Student.name</span><br><span class="line">public java.lang.String com.memforward.Student.gender</span><br><span class="line">private java.lang.Integer com.memforward.Student.age</span><br><span class="line">--------------------------------</span><br><span class="line">原来的stu：Student&#123;name&#x3D;&#39;江锦平&#39;, gender&#x3D;&#39;男&#39;, age&#x3D;999&#125;</span><br><span class="line">修改后的stu：Student&#123;name&#x3D;&#39;胡近民&#39;, gender&#x3D;&#39;男&#39;, age&#x3D;1000&#125;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<h3 id="Constructor对象的测试"><a href="#Constructor对象的测试" class="headerlink" title="Constructor对象的测试"></a>Constructor对象的测试</h3><p>小贴士：如果该类的构造是私有的，也是可以利用反射得到其构造器创建实例对象的，方法如Field，此测试就不写了。<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Constructor对象的测试</span></span><br><span class="line">	<span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class clazz = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">//获取Constructor对象</span></span><br><span class="line">        <span class="comment">//1.1返回了无参构造</span></span><br><span class="line">        Constructor constructor01 = clazz.getConstructor();</span><br><span class="line">        Student stu01 = (Student) constructor01.newInstance();</span><br><span class="line">        System.out.println(<span class="string">"获得了无参构造器："</span> + stu01);</span><br><span class="line">        <span class="comment">//1.2 返回有参构造</span></span><br><span class="line">        Constructor constructor02 = clazz.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>,<span class="title">Integer</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        Student stu02 = (Student) constructor02.newInstance(<span class="string">"胡近民"</span>, <span class="string">"男"</span>, <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"获得了有参构造器:"</span> + stu02);</span><br><span class="line">        <span class="comment">//无参构造器生成实例可以直接由Class对象获得</span></span><br><span class="line">        Student stu03 = (Student) clazz.newInstance();</span><br><span class="line">        System.out.println(<span class="string">"Class对象直接生成的实例："</span> + stu03);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><strong>Constructor测试的输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[TestNG] Running:</span><br><span class="line">  C:\Users\handsomestar\.IntelliJIdea2019.1\system\temp-testng-customsuite.xml</span><br><span class="line">获得了无参构造器：Student&#123;name&#x3D;&#39;江锦平&#39;, gender&#x3D;&#39;男&#39;, age&#x3D;999&#125;</span><br><span class="line">获得了有参构造器:Student&#123;name&#x3D;&#39;胡近民&#39;, gender&#x3D;&#39;男&#39;, age&#x3D;1000&#125;</span><br><span class="line">Class对象直接生成的实例：Student&#123;name&#x3D;&#39;江锦平&#39;, gender&#x3D;&#39;男&#39;, age&#x3D;999&#125;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<h3 id="Method对象的测试"><a href="#Method对象的测试" class="headerlink" title="Method对象的测试"></a>Method对象的测试</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Method对象的测试</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class clazz = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">//获得方法</span></span><br><span class="line">        <span class="comment">//1.1获得无参方法</span></span><br><span class="line">        Method md01 = clazz.getMethod(<span class="string">"live"</span>);</span><br><span class="line">        <span class="comment">//调用方法（需要有实例才可以执行该方法）</span></span><br><span class="line">        md01.invoke(<span class="keyword">new</span> Student());</span><br><span class="line">        <span class="comment">//1.2获得有参的方法</span></span><br><span class="line">        Method md02 = clazz.getMethod(<span class="string">"live"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        md02.invoke(<span class="keyword">new</span> Student(),<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>Method测试的输出</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[TestNG] Running:</span><br><span class="line">  C:\Users\handsomestar\.IntelliJIdea2019.1\system\temp-testng-customsuite.xml</span><br><span class="line">长生不老+1+1+1....</span><br><span class="line">寿命延长：1s</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<h2 id="反射的案例"><a href="#反射的案例" class="headerlink" title="反射的案例"></a>反射的案例</h2><p>·　　需求：实现一个“框架类”，该类可以创建任意类的对象，并能使用该类对象。<br>·　　解决方案：此“框架类”通过加载配置文件，得到某个具体类的全类名，通过反射创建该类的实例即可。<br><strong>以下是配置文件：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">//beansConfig.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.memforward.Student"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.memforward.Person"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>下面是新添加的Person类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"习"</span>;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"：修身治国齐家平天下...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saySomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"：TW必将光复，HK属于CN！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>以下是框架ReflectDemo，利用Dom4j读取XML文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Document document = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadProperties</span><span class="params">(String config)</span> </span>&#123;</span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Document document = reader.read(<span class="keyword">new</span> File(<span class="string">"src/main/resources/beansConfig.xml"</span>));</span><br><span class="line">            ReflectDemo.document = document;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        Element bean = <span class="keyword">null</span>;</span><br><span class="line">        String className = <span class="keyword">null</span>;</span><br><span class="line">        Element root = document.getRootElement();</span><br><span class="line">        List&lt;Element&gt; beans = root.elements(<span class="string">"bean"</span>);</span><br><span class="line">        <span class="comment">//找到配置文件里的节点</span></span><br><span class="line">        <span class="keyword">for</span>(Element e : beans)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e.attribute(<span class="string">"id"</span>).getValue().equals(id))&#123;</span><br><span class="line">                bean = e;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bean == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没有你指定的类："</span> + id);</span><br><span class="line">        className = bean.attribute(<span class="string">"class"</span>).getValue();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(className);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>下面是测试代码：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReflectDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ReflectDemo.loadProperties(<span class="string">"beansConfig.xml"</span>);</span><br><span class="line">    ReflectDemo rd = <span class="keyword">new</span> ReflectDemo();</span><br><span class="line">    Student stu = (Student) rd.getBean(<span class="string">"student"</span>);</span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    stu.live();</span><br><span class="line">    Person person = (Person) rd.getBean(<span class="string">"person"</span>);</span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    person.doSomething();</span><br><span class="line">    person.saySomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>下面是测试代码的输出，可见这个框架再加载了配置文件后，可以很方便的创建你所配置的任意类的对象，并使用该对象的方法：</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[TestNG] Running:</span><br><span class="line">  C:\Users\handsomestar\.IntelliJIdea2019.1\system\temp-testng-customsuite.xml</span><br><span class="line">长生不老+1+1+1....</span><br><span class="line">习：修身治国齐家平天下....</span><br><span class="line">习：TW必将光复，HK属于CN！</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>·　　以上就是整个反射的概念以及最常用的几个方法，可见反射其实也不是难，但是其思想着实是一大飞跃。几乎所有的代码我都贴在了博客上，如果有小伙伴不想复制粘贴，可以去我的github上下载源码(所用的IDE是Intellj idea)：<a href="https://github.com/MemoForward/ReflectDemo01" target="_blank" rel="noopener">github反射案例</a></p>
<h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><blockquote>
<p>请联系邮箱：chenxingyu@bupt.edu.cn</p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>学生管理系统（JSP+Servlet+MySQL）</title>
    <url>/2019/08/13/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F(JSP-Servlet-MySQL)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote>
<p>&#160; &#160; &#160; &#160;用了小半年的时间摸索了一下Java后端，最近在学框架的时候觉得之前学习的内容有所遗忘，因此想自己做一个特别简单但是功能还算齐全的学生管理系统，给自己加深一下对servlet的理解。本人平时用Eclipse比较多，为了熟悉一下其他的IDE，这次的项目就用IDEA开发了。笔者也是一个初学者，理解不到位的地方还请各位朋友指出。本项目不使用web.xml手动添加servlet和filter，均采用注解的方式添加，需要创建web3.0及以上的工程。</p>
</blockquote>
<a id="more"></a>
<p><strong>github传送门</strong>  ：<a href="https://github.com/MemoForward/StudentManagement" target="_blank" rel="noopener">https://github.com/MemoForward/StudentManagement</a> </p>
<h1 id="项目功能"><a href="#项目功能" class="headerlink" title="项目功能"></a>项目功能</h1><ul>
<li>实现对学生列表的增删改查</li>
</ul>
<h1 id="运用知识"><a href="#运用知识" class="headerlink" title="运用知识"></a>运用知识</h1><ul>
<li>mysql数据库增删改查语句（单表）</li>
<li>c3p0数据库连接池(c3p0-config.xml)</li>
<li>使用dbutils简化操作（QueryRunner）</li>
<li>使用BeanUtils封装数据(BeanUtils.populate(…))</li>
<li>MVC设计模式</li>
<li>servlet的使用</li>
<li>过滤器的使用(涉及一点点)</li>
<li>反射</li>
</ul>
<h1 id="前期准备工作"><a href="#前期准备工作" class="headerlink" title="前期准备工作"></a>前期准备工作</h1><p>&#160; &#160; &#160; &#160;工欲善其事，必先利其器。每个人都要以一名项目经理的角度要求自己，做项目之前先把框架搭好了：导入必要的环境配置以及构建好项目的架构。</p>
<h2 id="导入jar包"><a href="#导入jar包" class="headerlink" title="导入jar包"></a>导入jar包</h2><p>&#160; &#160; &#160; &#160;寻找jar包一直是最令人头疼的事情，所有还是推荐大家能尽快学习Maven，这次因为是最基础的Web工程，因此我就手动导入了，这里给出Maven的中心仓库，所有的jar包都可以在里面下载：<a href="http://mvnrepository.com" target="_blank" rel="noopener">http://mvnrepository.com</a>（千万别去CSDN上用积分下载，大部分在CSDN上用钱买的资源都是免费的），笔者用的jar都比较老旧，读者可以自行下载新版。所有的包都应放在项目web文件夹下的 WEB-INF/lib 中。</p>
<blockquote>
<p>c3p0-0.9.2-pre5.jar<br>commons-beanutils-1.8.3.jar<br>mysql-connector-java-5.1.39-bin.jar<br>commons-dbutils-1.4.jar<br>mchange-commons-java-0.2.3.jar // c3p0在0.9.2版本后会多出来一个辅助包<br>jstl.jar<br>standard.jar  // 使用jstl标签需要用到的包<br>commons-logging-1.1.1.jar </p>
</blockquote>
<h2 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h2><p>&#160; &#160; &#160; &#160;MVC：Model，View，Controller 分别代表Web工程中的三层结构。Model相当于持久层，主要用于与数据库交互，处理一些业务逻辑；View相当于展现层（WEB层），用于展现数据；Controller相当于控制层，用于处理Web层的数据并提供给持久层。<br>&#160; &#160; &#160; &#160;基于MVC架构，我们的项目也应该分成一个个的小的组件，而Web层都是jsp界面，因此在这里我们应该针对持久层和控制层建相应的包（src目录下）：</p>
<h3 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h3><pre><code>- dao（实现与数据库的交互 Data Access Object）
- service（实现业务逻辑）
- domain（存放Bean的包）
</code></pre><h3 id="控制层（统一放在web包下）"><a href="#控制层（统一放在web包下）" class="headerlink" title="控制层（统一放在web包下）"></a>控制层（统一放在web包下）</h3><pre><code>- servlet
- base（本项目使用了反射原理强化了普通servlet）
- filter （过滤器）
</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code>- utils（工具包）
</code></pre><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><p>&#160; &#160; &#160; &#160;主要需要两个配置文件：log4j.properties 和 c3p0-config.xml。分别是使用log4j和c3p0的依赖。这两个配置文件都应该放置在类路径下（src/）</p>
<h3 id="log4j-properties"><a href="#log4j-properties" class="headerlink" title="log4j.properties"></a>log4j.properties</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#参考资料：http:&#x2F;&#x2F;www.blogjava.net&#x2F;zJun&#x2F;archive&#x2F;2006&#x2F;06&#x2F;28&#x2F;55511.html</span><br><span class="line">log4j.rootLogger&#x3D;debug,stdout,D</span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.Target&#x3D;System.out</span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class="line">#log4j.appender.D&#x3D;org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">##log4j.appender.D.File&#x3D;填写</span><br><span class="line">#log4j.appender.D.Append&#x3D;true</span><br><span class="line">#log4j.appender.D.Threshold&#x3D;DEBUG</span><br><span class="line">#log4j.appender.D.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">#log4j.appender.D.layout.ConversionPattern&#x3D;%d&#123;[yyyy&#x2F;MM&#x2F;dd HH:mm:ss,SSS]&#125; [%5p] [%c:%L] - %m%n</span><br><span class="line">#log4j.appender.D&#x3D;org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">##log4j.appender.D.File&#x3D;填写</span><br><span class="line">#log4j.appender.D.Append&#x3D;true</span><br><span class="line">#log4j.appender.D.Threshold&#x3D;ERROR</span><br><span class="line">#log4j.appender.D.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">#log4j.appender.D.layout.ConversionPattern&#x3D;%d&#123;[yyyy&#x2F;MM&#x2F;dd HH:mm:ss,SSS]&#125; [%5p] [%c:%L] - %m%n</span><br></pre></td></tr></table></figure>
<h3 id="c3p0-config-xml-最好不要修改名字"><a href="#c3p0-config-xml-最好不要修改名字" class="headerlink" title="c3p0-config.xml(最好不要修改名字)"></a>c3p0-config.xml(最好不要修改名字)</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='UTF-8'?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span>&gt;</span>jdbc:mysql://localhost:3306/数据库名<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        连接池用完后等待，超时则抛异常--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"checkoutTimeout"</span>&gt;</span>30000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        每30秒检测连接池中的空闲连接--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idleConnectionTestPeriod"</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        初始化连接个数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        最大空闲时间，大于30秒则释放连接--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdleTime"</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        预缓存语句总计不超过200条--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span>&gt;</span>200<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destroy-method"</span>&gt;</span>close<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><p>&#160; &#160; &#160; &#160; 本项目只用到了一个表，所以非常的简单，学生表的字段只有6个，分别是：id（主键），学号，姓名，性别，年龄，生日。这里给出创建表的sql语句。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#96;stu&#96;DROP DATABASE IF EXISTS student_00;</span><br><span class="line">CREATE DATABASE student_00 DEFAULT CHARACTER SET utf8;</span><br><span class="line"></span><br><span class="line">USE student_00;</span><br><span class="line"></span><br><span class="line">CREATE&#96;stu&#96; TABLE stu(</span><br><span class="line">	sid VARCHAR(255) NOT NULL PRIMARY KEY,</span><br><span class="line">	snum INT(10),</span><br><span class="line">	sname VARCHAR(255),</span><br><span class="line">	sage INT(10),</span><br><span class="line">	sgender VARCHAR(20),</span><br><span class="line">	birthday DATE DEFAULT NULL</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h1 id="美工"><a href="#美工" class="headerlink" title="美工"></a>美工</h1><p>&#160; &#160; &#160; &#160;  在写代码之前，笔者比较喜欢先把界面做出一个雏形，这样调试起来比较直观。但是笔者的前端技术非常之差，接触代码也不过一年的时间，所以没有时间学，这次的界面做的比较糟糕，各种bootstrap的组件乱贴，代码估计也会有很多的冗余，这里只给出图片，具体的内容各位如果有兴趣可以去git上下载源码。各位朋友如果实在看不下去，笔者也十分渴望和各位多多交流。所有的资源都应放在项目的web文件夹下。（忽略年龄和出生日期不匹配的问题…）</p>
<h2 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h2><p><img src="https://img-blog.csdnimg.cn/20190812193517122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="展示主界面"></p>
<h2 id="编辑学生和添加学生界面"><a href="#编辑学生和添加学生界面" class="headerlink" title="编辑学生和添加学生界面"></a>编辑学生和添加学生界面</h2><p><img src="https://img-blog.csdnimg.cn/20190812193648730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="编辑学生"></p>
<h1 id="书写代码"><a href="#书写代码" class="headerlink" title="书写代码"></a>书写代码</h1><p>&#160; &#160; &#160; &#160;  这一部分的代码量还是挺多的，各位如果有兴趣可以去git上下载源码。这里主要介绍一下（JSP+Servlet+MySQL）的流程，其实网上优秀的教程还是很多的，各位不嫌弃的话在这里稍微看一下也无妨。除了基本的概念外，笔者还将介绍一下如何增强Servlet和实现过滤的操作，以及自己编写的工具类的介绍。</p>
<h2 id="Jsp-Servlet-MySQL"><a href="#Jsp-Servlet-MySQL" class="headerlink" title="Jsp+Servlet+MySQL"></a>Jsp+Servlet+MySQL</h2><p>&#160; &#160; &#160; &#160;  最典型的MVC设计模式莫过于Jsp+Servlet+JavaBean：Jsp负责传递用户的输入以及显示用户需要的数据；Servlet用来处理从Jsp界面中传递过来的请求（获取到用户输入的数据），将数据进行业务逻辑处理后，将需要展示的数据封装到域对象（一般是request，session）中；而Servlet处理数据的操作主要是通过JavaBean来与数据库进行对话。因此，可以很清晰的看到，Servlet在数据的交互的过程中，起到了一个中间层的控制作用。如下图所示，一般情况下，每一个不一样的Jsp的请求我们就需要去创建一个Servlet类去处理（这里注意一下本项目中Servlet是<strong>单例多线程</strong>的，因此会有线程安全的问题），所以我们需要去创建很多的Servlet类去实现功能。<br><img src="https://img-blog.csdnimg.cn/20190812201226637.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="JSP+Servlet+MySQL流程"><br>&#160; &#160; &#160; &#160;  这里必须说明一下Service和DAO的区别。Serive和DAO里面的内容都是业务逻辑，比如：查找某个学生，修改某个学生信息等。但是DAO层我们往往只关心单层逻辑，而在Service层中我们可以实现多层逻辑。这里举个比较直观的例子：<strong>在本项目中实现了分页的功能，我们抽取的页面Bean（PageBean：可以理解为一个页面往往不会只包含了学生的个人信息，因此需要将页面的模型抽取出来）中包含两个变量:一个是数据库中总的学生数量，一个是本页（可见上图的主界面）中包含的学生信息。我们在Servlet中希望得到的数据是一个包含这两个变量数据的PageBean，而获取PageBean中两个变量的操作对应了两条sql语句：</strong><code>select count(*) from stu</code><strong>和</strong><code>select * from stu limit ?,?</code><strong>这两条语句其实就是两个业务逻辑，对应两个DAO层的方法，而Service的作用就是组装这两个逻辑，实现多层的逻辑，即获取到整个页面的数据。</strong> 因为本项目过于简单，所以这两层其实也没有必要细分，不过以后一定会遇到更为复杂的项目的，所以还是建议各位养成良好的习惯。<br>&#160; &#160; &#160; &#160;  这里笔者还是稍加笔墨用一个简单的示例展现一下这个流程在本项目中的应用，如果用户想要<strong>删除学生</strong>:<br><img src="https://img-blog.csdnimg.cn/20190812205400910.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="删除学生流程"></p>
<h2 id="增强Servlet"><a href="#增强Servlet" class="headerlink" title="增强Servlet"></a>增强Servlet</h2><p>&#160; &#160; &#160; &#160; 上一小节我们介绍了一下Jsp+Servlet+MySQL的流程，这种流程还是非常简单易懂的，但是有一个特别不方便的地方在于，每一个来自页面的请求，我们往往都需要一个Servlet类去满足这个请求，这其实是不符合我们的生活习惯的，试想一下：如果存钱和取钱对应不同的ATM机，估计我们会被搞疯掉。我们更希望面对的情况是：一台ATM机会处理来自所有关于存款的操作。也就是说，我们希望用一个关于学生的StudentServlet去满足所有针对情况的请求，不同的请求对应不同的方法。而<strong>servlet的生命周期</strong>是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- init() &#x2F;&#x2F;第一次创建 Servlet 时被调用,后续的请求不再调用</span><br><span class="line">- service(ServletRequest request, ServletResponse response) &#x2F;&#x2F;Servlet处理客户端请求所调用的方法</span><br><span class="line">		- 在Service下有我们常见的doGet和doPost方法</span><br><span class="line"> - destory() &#x2F;&#x2F;只会被调用一次，在 Servlet 生命周期结束时被调用</span><br><span class="line"> - 被垃圾回收</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160; 可以看到，servlet最核心的部分就是service()方法，我们自己创建的Servlet都是要继承HttpServlet类，如果有阅读源码习惯的小伙伴可以看一下这个类中实现d的service()方法，这个方法会分析界面的请求类型，自动调用doGet和doPost方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String method = req.getMethod(); <span class="comment">//在这里取界面出传递过来的方法，一般就是GET或者POST</span></span><br><span class="line">        <span class="keyword">long</span> lastModified;</span><br><span class="line">        <span class="keyword">if</span> (method.equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">            lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.doGet(req, resp); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> ifModifiedSince;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ifModifiedSince = req.getDateHeader(<span class="string">"If-Modified-Since"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">                    ifModifiedSince = -<span class="number">1L</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; lastModified / <span class="number">1000L</span> * <span class="number">1000L</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(<span class="number">304</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">            lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">            <span class="keyword">this</span>.doHead(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"PUT"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doPut(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"DELETE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doDelete(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"OPTIONS"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doOptions(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"TRACE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doTrace(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> Object[]&#123;method&#125;;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">            resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;而我们去实现自己的子类Servlet的时候，就是在重写doGet方法，笔者在这里因为篇幅原因不加赘述。但是如果要实现我们的目标应该怎么做呢？<strong>由HttpServlet类中的service()方法得到启发：我们应该直接从界面传递要执行的Servlet请求方法，在service()方法中得到请求的方法名，从而直接利用反射调用子类的方法。因此我们需要重写service()方法，所以笔者建立了Base包来创造一个BaseServlet来重新实现service()方法</strong>。话不多说，上代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String method = req.getParameter(<span class="string">"method"</span>); <span class="comment">//客户端的请求应包含mehod的键来传递方法名</span></span><br><span class="line">        <span class="comment">//如果没有method键，则调用默认方法</span></span><br><span class="line">        <span class="keyword">if</span>(method == <span class="keyword">null</span> || method.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            method = <span class="string">"excute"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果子类继承了这个类，则会创建子类的servlet，使用this会得到子类的类字节码</span></span><br><span class="line">        Class clazz = <span class="keyword">this</span>.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method md = clazz.getMethod(method,HttpServletRequest<span class="class">.<span class="keyword">class</span>, <span class="title">HttpServletResponse</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(md != <span class="keyword">null</span>)&#123;</span><br><span class="line">            	<span class="comment">//子类必须要返回一个供父类转发的页面路径，如果子类想重定向，则return null;</span></span><br><span class="line">                String jspPath = (String)md.invoke(<span class="keyword">this</span>, req, resp);</span><br><span class="line">                <span class="keyword">if</span>(jspPath != <span class="keyword">null</span>)&#123;</span><br><span class="line">                	<span class="comment">//子类的所有方法，统一由父类转发</span></span><br><span class="line">                    req.getRequestDispatcher(jspPath).forward(req,resp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">excute</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&#160; &#160; &#160; &#160;至此，我们只需要在一个Servlet类中编写所有的请求方法就可以了，如果页面想发送请求，则需要编写如下个格式的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!--需要给出method参数，如果不给出则执行exctue默认方法--&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;studentServlet.do?method&#x3D;addStudent&quot; &gt;添加学生&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>
<p>在StudentServlet中则对应如下的方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStudent</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">//将从页面获取的数据通过工具类封装到Bean里</span></span><br><span class="line">        MyBeanUtils.populate(student,req.getParameterMap());</span><br><span class="line">        StudentService stuService = <span class="keyword">new</span> StudentServiceImpl();</span><br><span class="line">        student.setSid(UUIDUtils.getId());</span><br><span class="line"><span class="comment">//        System.out.println(student);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stuService.addStudent(student);</span><br><span class="line">            resp.sendRedirect(<span class="string">"index.jsp"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h2 id="过滤器的操作"><a href="#过滤器的操作" class="headerlink" title="过滤器的操作"></a>过滤器的操作</h2><p>&#160; &#160; &#160; &#160;众所周知，从客户端传递过来的数据，或有中文的编码问题，post和get方法对应的解决方法也不同，主要原因在于传递数据的途径不一样，post将所有的数据都封装在http请求头的消息体（entity-body）中，用户可以自定义编码的类型；而Get的数据则通过URL进行传递，由浏览器进行编码（大部分都是iso8859-1）传递给Servlet。因此，对于POST请求，我们需要自己设置编码类型，而对于GET请求，我们需要用iso8859-1进行解码，再编码成UTF-8进行使用。如果对每一个Servlet方法都进行编码设置的话，会有大量的重复代码，因此，我们需要通过一个过滤器去拦截所有的请求，统一这些请求的编码格式再传递给后端。过滤器的作用如下：<br><img src="https://img-blog.csdnimg.cn/20190812215823201.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="过滤器"><br>&#160; &#160; &#160; &#160;过滤器的代码如下（过滤器也是需要注解配置的或者在web.xml中配置）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.web.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">// /*表示拦截所有请求</span></span><br><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"EncodingFilter"</span>, urlPatterns = <span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest)req;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse)resp;</span><br><span class="line">        <span class="comment">//这个方法是过滤器放行的方法，我们通过在通过增强request来保证Servlet中使用的request能够</span></span><br><span class="line">        <span class="comment">//自动处理编码问题</span></span><br><span class="line">        chain.doFilter(<span class="keyword">new</span> EnhancedRequest(request), response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//web容器在使用HttpServletRequest接口时会自动创建HttpServletRequestWrapper实例（这里应该是通过依赖注入实现的 ，也不知道我理解的对不对）</span></span><br><span class="line">	<span class="comment">//继承一下这个类提醒一下这个知识点，毕竟原来是从接口直接调用的方法</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EnhancedRequest</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EnhancedRequest</span><span class="params">(HttpServletRequest req)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(req);</span><br><span class="line">            <span class="keyword">this</span>.request = req;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(name==<span class="keyword">null</span> || name.trim().length()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] values = getParameterValues(name);</span><br><span class="line">            <span class="keyword">if</span>(values==<span class="keyword">null</span> || values.length==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> values[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * hobby=[eat,drink]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name==<span class="keyword">null</span> || name.trim().length()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, String[]&gt; map = getParameterMap();</span><br><span class="line">            <span class="keyword">if</span>(map==<span class="keyword">null</span> || map.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> map.get(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * map&#123; username=[tom],password=[123],hobby=[eat,drink]&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> Map&lt;String,String[]&gt; getParameterMap() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 首先判断请求方式</span></span><br><span class="line"><span class="comment">             * 若为post  request.setchar...(utf-8)</span></span><br><span class="line"><span class="comment">             * 若为get 将map中的值遍历编码就可以了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"post"</span>.equalsIgnoreCase(method))&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">                    <span class="keyword">return</span> request.getParameterMap();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"get"</span>.equalsIgnoreCase(method))&#123;</span><br><span class="line">                Map&lt;String,String[]&gt; map = request.getParameterMap();</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (String key:map.keySet()) &#123;</span><br><span class="line">                        String[] arr = map.get(key);</span><br><span class="line">                        <span class="comment">//继续遍历数组</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">                            <span class="comment">//编码</span></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                arr[i]=<span class="keyword">new</span> String(arr[i].getBytes(<span class="string">"iso-8859-1"</span>),<span class="string">"utf-8"</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    flag=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//需要遍历map 修改value的每一个数据的编码</span></span><br><span class="line">                <span class="keyword">return</span> map;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getParameterMap();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="工具类的说明"><a href="#工具类的说明" class="headerlink" title="工具类的说明"></a>工具类的说明</h2><p>&#160; &#160; &#160; &#160;其实用不用工具类都行，这些东西其实和项目的关系都不是很大了，自己编写工具类的好处就是用起来爽，有什么需要添加的功能直接在类里面写，真正在Servlet或者其他地方调用的时候显得简洁和清晰。笔者这里使用了三个工具类，具体代码还请给位看官移步github。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- 关于c3p0操作的C3O0Utils类，使用最多的就是获取连接操作。</span><br><span class="line">- 关于Bean封装的MyBeanutils类，增强了beanutils包，主要实现了对日期格式的转换</span><br><span class="line">- 关于学生唯一id生成的UUIDUtils类，增强了 UUID包，主要是因为UUID获得数据是UUID格式的，比较让人不爽</span><br></pre></td></tr></table></figure>
<h2 id="编写此项目的流程"><a href="#编写此项目的流程" class="headerlink" title="编写此项目的流程"></a>编写此项目的流程</h2><p>&#160; &#160; &#160; &#160; 在美工和数据库以及系统架构和环佩配置好了以后，就可以开始编写代码了，笔者比较喜欢的编码顺序是这样的：先把所有数据库中的实体Bean创建完毕（比如此项目中的Student），随后从美工界面出发一个个去将请求的Servlet方法编写完毕，servlet中调用的Service类就先定义出其接口。先把大逻辑搭建出来，等这个Servlet大逻辑编写完毕后再去实现低层的Service和Dao方法。当 “请求—servlet—service—dao” 的流程都都编写完成后，再去调试这个请求逻辑能不能跑通。当所有的请求都编写完后，这个项目就做完了。因为笔者比较菜，这个简单的项目用了一整天的时间才做完，期间也遇到了些许问题，如果有机会，希望能和各位多交流交流，各位如果有问题也可以在评论区问我。</p>
<h1 id="本项目出现过的问题"><a href="#本项目出现过的问题" class="headerlink" title="本项目出现过的问题"></a>本项目出现过的问题</h1><p>&#160; &#160; &#160; &#160; 在项目中遇到了两个比较非常棘手的问题： </p>
<ul>
<li><strong>关闭或重启服务器会提示有线程释放不掉，导致内存泄漏</strong>。其实这是tomcat的一个误报，因为c3p0的线程需要时间去关闭，具体答案请参考StarkOverlFlow：<a href="https://stackoverflow.com/questions/39988634/c3p0-connection-pool-memory-leak-redeploy-tomcat" target="_blank" rel="noopener">c3p0 Connection pool memory leak redeploy tomcat</a></li>
<li><strong>热部署的时候总是会提示 Illegal access: this web application instance has been stopped already.</strong> 这个问题似乎是因为tomcat缓存了该项目的旧版本，所以相当于一个tomcat启动了两个相同的项目所以报了异常。不影响项目的使用和调试，不过笔者水平有限，并没有解决这个问题，各位如果在运行本项目的时候遇到了这个问题，可以移步：<a href="https://stackoverflow.com/questions/4945153/illegal-access-this-web-application-instance-has-been-stopped-already" target="_blank" rel="noopener">Illegal access: this web application instance has been stopped already</a></li>
</ul>
<h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote>
<p>请联系邮箱：chenxingyu@bupt.edu.cn</p>
</blockquote>
]]></content>
      <categories>
        <category>项目</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Project</tag>
      </tags>
  </entry>
</search>
