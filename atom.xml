<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MemoForward&#39;s Blog</title>
  
  <subtitle>阿星的学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-11-14T13:45:41.825Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>MemoForward</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Nacos基础</title>
    <link href="http://yoursite.com/2022/11/14/Nacos%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2022/11/14/Nacos%E5%9F%BA%E7%A1%80/</id>
    <published>2022-11-14T13:39:56.000Z</published>
    <updated>2022-11-14T13:45:41.825Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><ol><li>介绍Nacos作为注册中心的基本使用</li><li>介绍Nacos作为配置中心的基本使用</li><li>介绍Feign的微服务远程调用（非常实用）<ol><li>服务两端统一接口实现</li><li>服务接口统一抽取</li></ol></li><li>介绍SpringCloudGateway网关的基本使用<ol><li>路由断言</li><li>请求过滤器</li></ol></li></ol></blockquote><a id="more"></a><h1 id="认识Nacos"><a href="#认识Nacos" class="headerlink" title="认识Nacos"></a>认识Nacos</h1><p>微服务注册中心，比Eureka功能更加丰富。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>必须配置JAVA_HOME</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> JAVA_HOME=/usr/<span class="built_in">local</span>/java</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:<span class="variable">$JAVA_HOME</span>/bin</span><br></pre></td></tr></table></figure><ul><li>application.properties里面可以修改端口</li><li>单机启动： <code>sh startup.sh -m standalone</code></li><li>访问：<code>http://ip:8848/nacos/index.html</code><ul><li>用户名密码：nacos</li></ul></li></ul><h1 id="Nacos服务注册"><a href="#Nacos服务注册" class="headerlink" title="Nacos服务注册"></a>Nacos服务注册</h1><ul><li>依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 父工程中添加spring-cloud-alibaba管理依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 子工程添加Nacos客户端依赖--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>客户端配置Nacos地址</li></ul><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring.cloud.nacos.server-asddr:</span> <span class="string">&#123;ip&#125;:8848</span> <span class="comment"># nacos 服务端地址</span></span><br></pre></td></tr></table></figure><h2 id="Nacos服务分级存储模型"><a href="#Nacos服务分级存储模型" class="headerlink" title="Nacos服务分级存储模型"></a>Nacos服务分级存储模型</h2><ul><li>服务跨集群调用问题：尽可能访问本地集群，本地集群不可用再访问外地集群</li><li>配置服务提供端集群属性</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">cloud:</span></span><br><span class="line">   <span class="attr">nacos:</span></span><br><span class="line">     <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">     <span class="attr">discovery:</span></span><br><span class="line">       <span class="attr">cluster-name:</span> <span class="string">HZ</span> <span class="comment"># 航侦集群（手动配置）</span></span><br></pre></td></tr></table></figure><ul><li>修改负载均衡规则</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">userservice:</span></span><br><span class="line">  <span class="attr">ribbon:</span></span><br><span class="line">    <span class="attr">NFLoadBalancerRuleClassName:</span> <span class="string">com.alibaba.cloud.nacos.ribbon.NacosRule</span> <span class="comment"># 优先选择本地集群，然后在本地集群中用随机</span></span><br></pre></td></tr></table></figure><ul><li><p>分配权重</p><p>  在Nacos控制台可以配置实例的权重</p></li></ul><h2 id="Namesapce环境隔离"><a href="#Namesapce环境隔离" class="headerlink" title="Namesapce环境隔离"></a>Namesapce环境隔离</h2><pre><code>Nacos中服务存储和数据存储的最外层都是一个名为namespace的东西，用来做最外层的隔离。命名空间下的服务是独立的。（可以用来隔离测试环境啥的）</code></pre><ul><li>在nacos控制台创建命名空间</li><li><p>代码中配置命名空间: <code>spring.cloud.nacos.discovery.namespace: ${namespaceId}</code></p></li><li><p>总结</p><ul><li>namespace做环境隔离</li><li>每个namespace都有唯一id</li><li>不同namespace下的服务不可见</li></ul></li></ul><h2 id="Nacos和Eureka的区别"><a href="#Nacos和Eureka的区别" class="headerlink" title="Nacos和Eureka的区别"></a>Nacos和Eureka的区别</h2><ul><li>相同点：<ul><li>服务提供者注册服务信息</li><li>服务消费者定时拉取服务信息</li><li>支持服务提供者心跳方式做健康监测</li></ul></li><li>不同点：<ul><li>Nacos会将服务提供者划分为临时实例和非临时实例<ul><li><strong>临时实例</strong>采用心跳检测，心跳停止直接删除服务</li><li><strong>非临时实例</strong>，nacos主动询问实例，不会删除服务</li></ul></li><li>消费者定时服务拉取，当消息变更，nacos注册中心会主动像消费者进行服务列表同步<ul><li>Eureka只做服务拉取，不做同步</li></ul></li><li>Nacos集群默认采用AP方式，当集群中存在非临时实例时，采用CP模式；Eureka采用AP方式</li></ul></li><li>配置非临时实例</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.cloud.nacos.discovery.ephemeral</span>=<span class="string">false</span></span><br></pre></td></tr></table></figure><h1 id="Nacos配置管理"><a href="#Nacos配置管理" class="headerlink" title="Nacos配置管理"></a>Nacos配置管理</h1><h2 id="统一配置管理"><a href="#统一配置管理" class="headerlink" title="统一配置管理"></a>统一配置管理</h2><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><ul><li>配置更改热更新，保证配置变化不用重启服务</li><li>配置步骤<ul><li>登录nacos管理页面</li><li>新建配置管理<ul><li>DataId对为配置名称：<code>userservice-dev.yaml</code></li><li>编写配置：一般用来做一些开关，或者ABTest等</li></ul></li></ul></li><li>启动流程<ul><li>项目启动 —- 读取nacos配置文件 —- 读取本地配置文件application.yml —- 创建spring容器 —- 加载bean</li><li>但是如果nacsos地址在application里面，那么这个流程就不成立了<ul><li>建立一个bootstrap.yml，供项目启动时读取nacos地址等（bootstrap是引导文件，会在启动后立刻加载）</li></ul></li></ul></li></ul><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--客户端配置 nacos 配置中心 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># bootstrap.yml</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">userservice</span> <span class="comment"># 服务名称</span></span><br><span class="line">  <span class="attr">profiles:</span></span><br><span class="line">    <span class="attr">active:</span> <span class="string">dev</span> <span class="comment"># 注意是开发环境, 在nacos管理页面中的配置文件为 userservice-dev.yaml</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">      <span class="attr">config:</span></span><br><span class="line">        <span class="attr">file-extension:</span> <span class="string">yaml</span> <span class="comment"># 配置在nacos管理页面中的配置格式</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的路径就是在nacos中配置的内容（可以理解为，nacos中是在远程的配置文件）</span></span><br><span class="line"><span class="meta">@Value</span>(<span class="string">"$&#123;pattern.dateformat&#125;"</span>)</span><br><span class="line"><span class="keyword">private</span> String dateformat;</span><br></pre></td></tr></table></figure><h3 id="nacos中设置配置总结"><a href="#nacos中设置配置总结" class="headerlink" title="nacos中设置配置总结"></a>nacos中设置配置总结</h3><ol><li>在Nacos管理页面中添加配置文件</li><li>在微服务中引入nacos的config依赖</li><li>在微服务中添加bootstrap.yml，配置nacos地址、当前环境、服务名称、文件后缀名。（这些决定了程序启动时去读取nacos中哪个配置文件）</li></ol><h2 id="配置热更新"><a href="#配置热更新" class="headerlink" title="配置热更新"></a>配置热更新</h2><h3 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h3><p>两种方式实现配置自动更新：</p><ol><li>在用到配置的类上加<code>@RefreshScope</code>注解</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/user"</span>)</span><br><span class="line"><span class="meta">@RefreshScope</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;pattern.dateformat&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/now"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">now</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> LocalDateTime.now().format(DateTimeFormatter.ofPattern(dateformat));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>使用<code>@ConfigurationProperties</code>：不需要RefreshScope也可以自动刷新</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义配置类</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"pattern"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PatternProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String dateformat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其他类中使用上述配置Bean</span></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line">PatternProperties properties;</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ol><li><p>编写代码遇到问题，客户端不停地去请求配置中心，并打印日志，1秒估计得有几十次。</p><p> 答：查阅了资料，好像是因为服务端MD5和客户端MD5不一致，但是我不同意，因为功能都能实现。我猜是nacos1.4.1版本在macos上导致的日志打印问题。更新了nacos1.4.3版本后问题解决。</p></li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>通过@Value和@RefreshScope实现热更新</li><li>通过@ConfigurationProperties注入</li><li>不是所有配置都适合放在配置中心，维护起来很麻烦</li></ol><h2 id="配置共享"><a href="#配置共享" class="headerlink" title="配置共享"></a>配置共享</h2><p>一个服务集群可能会共享一些配置。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>微服务启动时会从nacos读物多个配置文件：</p><ul><li>[spring.application.name]-[spring.profiles.active].yaml，例如：userservice-dev.yaml</li><li>[spring.application.name].yaml，例如：userservice.yaml</li></ul><p>无论profile如何变化，[spring.application.name].yaml这个文件一定会加载，因此在这个配置项中配置共享。</p><h3 id="注意【多服务共享配置】"><a href="#注意【多服务共享配置】" class="headerlink" title="注意【多服务共享配置】"></a>注意【多服务共享配置】</h3><ul><li>线上配置 &gt; 本地配置</li><li>线上当前环境配置 &gt; 线上共享配置</li></ul><h2 id="搭建Nacos集群"><a href="#搭建Nacos集群" class="headerlink" title="搭建Nacos集群"></a>搭建Nacos集群</h2><ol><li>搭建数据库集群</li><li>不同机器nacos配置集群和数据库集群的地址，username和pwd</li><li>ngnix反向代理</li></ol><h1 id="Feign远程调用"><a href="#Feign远程调用" class="headerlink" title="Feign远程调用"></a>Feign远程调用</h1><h2 id="RestTemplate的问题"><a href="#RestTemplate的问题" class="headerlink" title="RestTemplate的问题"></a>RestTemplate的问题</h2><ol><li>代码可读性差，编程体验感差</li><li>参数复杂，URL难以维护</li></ol><p>很不优雅。</p><h2 id="Feign使用"><a href="#Feign使用" class="headerlink" title="Feign使用"></a>Feign使用</h2><p>Feign是一个声明式的http客户端，其作用就是帮助我们优雅的实现http请求的发送。</p><h3 id="依赖-1"><a href="#依赖-1" class="headerlink" title="依赖"></a>依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Feign --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 启动类加注解</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(OrderApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 编写远程接口Client类</span></span><br><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"userservice"</span>) <span class="comment">// 远程调用的服务名称</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 使用的时候注入就行</span></span><br><span class="line"><span class="meta">@Autowired</span> <span class="keyword">private</span> UserClient userClient;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>Feign中已经集成了Ribbon，实现了负载均衡，非常的优雅。</p><h2 id="自定义Feign配置"><a href="#自定义Feign配置" class="headerlink" title="自定义Feign配置"></a>自定义Feign配置</h2><p>Feign运行自定义配置来覆盖默认配置，可以修改的配置大致如下：</p><div class="table-container"><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:left">作用</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:left">feign.Logger.Level</td><td style="text-align:left">修改日志级别</td><td>NONE, BASIC（请求基本信息）, HEADERS, FULL</td></tr><tr><td style="text-align:left">feign.codec.Decoder</td><td style="text-align:left">响应结果的解析器</td><td>http远程调用的结果做解析，例如解析json字符串为java对象</td></tr><tr><td style="text-align:left">feign.codec.Encoder</td><td style="text-align:left">请求参数编码</td><td>指定请求参数的编码格式</td></tr><tr><td style="text-align:left">feign.Contract</td><td style="text-align:left">支持的注解格式</td><td>默认SpringMVC</td></tr><tr><td style="text-align:left">feign.Retryer</td><td style="text-align:left">失败的重试机制</td><td>请求失败的重试机制，默认没有，可以使用Ribbon的重试</td></tr></tbody></table></div><p>一般配置日志就行。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><ul><li>配置文件修改</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局</span></span><br><span class="line"><span class="meta">feign.client.config.default.loggerLevel</span>=<span class="string">FULL</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 局部 userservice instead of default</span></span><br><span class="line"><span class="meta">feign.client.config.userservice.loggerLevel</span>=<span class="string">FULL</span></span><br></pre></td></tr></table></figure><ul><li>代码配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 声明配置文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignClientConfiguration</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Logger.<span class="function">Level <span class="title">feignLogLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.BASIC;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 全局配置，放在启动类的注解中</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span>(defaultConfiguration = FeignClientConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// 3. 局部配置，放在@<span class="title">FeignClient</span>注解中</span></span><br><span class="line"><span class="class">@<span class="title">FeignClient</span>(<span class="title">value</span> </span>= <span class="string">"userservice"</span>, configuration = FeignClientConfiguration<span class="class">.<span class="keyword">class</span>)</span></span><br></pre></td></tr></table></figure><p>注意：局部配置覆盖全局。</p><h2 id="Feign性能优化"><a href="#Feign性能优化" class="headerlink" title="Feign性能优化"></a>Feign性能优化</h2><h3 id="底层的客户端实现"><a href="#底层的客户端实现" class="headerlink" title="底层的客户端实现"></a>底层的客户端实现</h3><ul><li>URLConnection：默认实现，不支持连接池</li><li>Apache HttpClient：支持连接池</li><li>OKHttp：支持连接池</li></ul><p>性能优化：使用有连接池的实现，以及日志级别为basic和none</p><h3 id="实践-1"><a href="#实践-1" class="headerlink" title="实践"></a>实践</h3><ul><li>依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- httpclient --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.github.openfeign<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-httpclient<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置连接池</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">config:</span></span><br><span class="line">      <span class="attr">default:</span></span><br><span class="line">        <span class="attr">loggerLevel:</span> <span class="string">BASIC</span></span><br><span class="line">  <span class="attr">httpclient:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">true</span> <span class="comment"># 使用httpclient</span></span><br><span class="line">    <span class="attr">max-connections:</span> <span class="number">200</span> <span class="comment"># 最大连接数</span></span><br><span class="line">    <span class="attr">max-connections-per-route:</span> <span class="number">50</span> <span class="comment"># 每个路径的最大连接数</span></span><br></pre></td></tr></table></figure><h2 id="Feign的最佳实践"><a href="#Feign的最佳实践" class="headerlink" title="Feign的最佳实践"></a>Feign的最佳实践</h2><h3 id="方式一：继承"><a href="#方式一：继承" class="headerlink" title="方式一：继承"></a>方式一：继承</h3><p>给消费者的FeignClient和提供者的controller定义统一的父接口作为标准。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserAPI</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">findById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消费者</span></span><br><span class="line"><span class="meta">@FeignClass</span>(value = <span class="string">"userservice"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> <span class="keyword">extends</span> <span class="title">UserAPI</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供者</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">implements</span> <span class="title">UserAPI</span> </span>&#123;</span><br><span class="line">     <span class="function">User <span class="title">findById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">         <span class="comment">// ...实现业务</span></span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>缺点：</strong></p><ul><li>服务紧耦合</li><li>父接口参数列表中的映射不会被继承</li></ul><h3 id="方式二：抽取"><a href="#方式二：抽取" class="headerlink" title="方式二：抽取"></a>方式二：抽取</h3><p>将FeignClient抽取为独立模块，并且把接口相关的POJO、默认的Feign配置都放到这个模块中，提供给所有消费者使用。</p><p>提供者把接口抽取出来，变成jar依赖，给消费者引用。</p><p><strong>缺点：</strong></p><ul><li>消费者可能引入过多没有必要的依赖</li></ul><h3 id="方式二实践！非常重要！"><a href="#方式二实践！非常重要！" class="headerlink" title="方式二实践！非常重要！"></a>方式二实践！非常重要！</h3><ol><li>首先创建一个module，命名为feign-api，然后引入feign的starter依赖</li><li>将pojo，feignConfiguration（之前用来配置日志的），client复制到feign-api中</li><li>在order-service中引用feign-api的依赖</li><li>修改order-service中的import</li></ol><ul><li>引入依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>feign-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>问题</p><p>  当定义的FeignClients不在SpringBootApplication的扫描包范围时，这些FeignClient无法使用。有两种解决方案。</p><ul><li>指定FeignClient所在包<code>@EnableFeignClients(basePackages = &quot;cn.itcast.feign.clients&quot;)</code></li><li>定向指定字节码<code>@EnableFeignClients(clients = {UserClient.class})</code></li></ul></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h3><p><strong><font color="red">maven安装外部jar包！！</font></strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mvn install:install-file -Dfile=<span class="variable">$&#123;jar包绝对路径&#125;</span> -DgroupId=com.memoforward -DartifactId=xxx-sdk -Dversion=1.1 -Dpackaging=jar -DgeneratePom=<span class="literal">true</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">-Dfile的后面输入的为你下载的第三方jar包的本地文件路径。</span><br><span class="line">-DgroupId的后面输入的为你转maven jar包后groupId的标签内容&lt;groupId&gt;com.memoforward&lt;/groupId&gt;。</span><br><span class="line">-DartifactId的后面输入的为你转maven jar包后artifactId的标签内容&lt;artifactId&gt;xxx-sdk&lt;/artifactId&gt;。</span><br><span class="line">-Dversion的后面输入的为你转maven jar包后version的标签内容版本号&lt;version&gt;1.1&lt;/version&gt;。</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.memoforward<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>xxx-sdk<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="Gateway服务网关"><a href="#Gateway服务网关" class="headerlink" title="Gateway服务网关"></a>Gateway服务网关</h1><p>官网地址: <a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html" target="_blank" rel="noopener"></a></p><h2 id="为什么需要网关"><a href="#为什么需要网关" class="headerlink" title="为什么需要网关"></a>为什么需要网关</h2><p>痛点:不是所有微服务接口都是可以被访问的，需要对请求进行校验</p><p><strong>网关功能：</strong></p><ul><li>进行身份认证和权限校验</li><li>服务路由、负载均衡</li><li>请求限流</li></ul><p><strong>网关的技术实现</strong></p><p>SpringCloud中网关的实现包括两种：</p><ul><li>gateway</li><li>zuul</li></ul><p>Zuul基于Servlet的实现，属于阻塞式变成。而SpringCloudGateway则是基于Spring5中提供的WebFlux，属于响应式编程的实现，具备更好的性能。</p><h2 id="搭建网关的步骤"><a href="#搭建网关的步骤" class="headerlink" title="搭建网关的步骤"></a>搭建网关的步骤</h2><ul><li>依赖 </li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- nacos服务注册，网关自己就是一个服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 网关gateway服务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>基础配置</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10010</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">routes:</span> <span class="comment"># 网关路由配置</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">user-service</span> <span class="comment"># 唯一路由id，自定义，每个服务不一样</span></span><br><span class="line">          <span class="comment"># uri: http://127.0.0.1:8081</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://userservice</span> <span class="comment"># loadbalance://....</span></span><br><span class="line">          <span class="attr">predicates:</span> <span class="comment"># 路由断言，判断请求是否符合路由规则</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/user/**</span> <span class="comment"># 路径匹配，以/user/开头的都会路由到userservice</span></span><br><span class="line">        <span class="bullet">-</span> <span class="attr">id:</span> <span class="string">order-service</span></span><br><span class="line">          <span class="attr">uri:</span> <span class="string">lb://orderservice</span></span><br><span class="line">          <span class="attr">predicates:</span></span><br><span class="line">            <span class="bullet">-</span> <span class="string">Path=/order/**</span></span><br></pre></td></tr></table></figure><h3 id="路由断言工厂（配置）"><a href="#路由断言工厂（配置）" class="headerlink" title="路由断言工厂（配置）"></a>路由断言工厂（配置）</h3><ul><li>我们在配置文件中写的断言规则只是字符串，这些字符串会被断言工厂读取并处理，转变为路由判断的条件</li><li>例如<code>Path=/user/**</code>是按照路径匹配，这个规则是由<code>PathRoutePredicateFactory</code>类来处理的</li><li>像上述的断言工厂Spring中还有11个</li></ul><p>Spring的官网中有各种断言示例：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gateway-request-predicates-factories" target="_blank" rel="noopener">SpringGateway断言</a>。</p><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><h4 id="路由过滤器"><a href="#路由过滤器" class="headerlink" title="路由过滤器"></a>路由过滤器</h4><p>GateWayFilter是网关中提供一种过滤器，可以对进入网关的请求和微服务返回的响应做处理。</p><p>可以形成过滤器链，用来对请求进行操作，比如添加请求头、限制请求流量。</p><ul><li>配置过滤器：Spring中官网各种过滤器的示例：<a href="https://docs.spring.io/spring-cloud-gateway/docs/current/reference/html/#gatewayfilter-factories" target="_blank" rel="noopener">SpringGateway过滤器</a></li></ul><h4 id="全局过滤器"><a href="#全局过滤器" class="headerlink" title="全局过滤器"></a>全局过滤器</h4><ul><li>自定义全局过滤器：实现<code>GlobalFilter</code>接口</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GlobalFilter</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@author</span> memoforward</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> exchange 请求上下文，里面可以获取request, response，用来写过滤逻辑</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> chain 用来把请求委托给下一个过滤器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &#123;<span class="doctag">@code</span> Mono&lt;void&gt; 返回标示当前过滤器业务结束&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@date</span> 2022/11/14 下午8:15</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Order</span>(-<span class="number">1</span>) <span class="comment">// 过滤优先级，越小越高；也可以实现Springframework的ordered接口，都一样</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyGlobalFilter</span> <span class="keyword">implements</span> <span class="title">GlobalFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Mono&lt;Void&gt; <span class="title">filter</span><span class="params">(ServerWebExchange exchange, GatewayFilterChain chain)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 获取请求参数</span></span><br><span class="line">        ServerHttpRequest request = exchange.getRequest();</span><br><span class="line">        MultiValueMap&lt;String, String&gt; queryParams = request.getQueryParams();</span><br><span class="line">        <span class="comment">// 2. 获取参数中的参数</span></span><br><span class="line">        String authorization = queryParams.getFirst(<span class="string">"authorization"</span>);</span><br><span class="line">        <span class="comment">// 3. 判断参数是否等于admin</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"admin"</span>.equals(authorization)) &#123;</span><br><span class="line">            <span class="comment">// 4. 是，放行</span></span><br><span class="line">            <span class="keyword">return</span> chain.filter(exchange);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5. 否，拦截</span></span><br><span class="line">        <span class="comment">// 5.1 设置状态码</span></span><br><span class="line">        exchange.getResponse().setStatusCode(HttpStatus.UNAUTHORIZED);</span><br><span class="line">        <span class="comment">// 5.2 拦截</span></span><br><span class="line">        <span class="keyword">return</span> exchange.getResponse().setComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="过滤器执行顺序"><a href="#过滤器执行顺序" class="headerlink" title="过滤器执行顺序"></a>过滤器执行顺序</h4><p>三类过滤器：路由过滤器、DefaultFilter、GlobalFilter</p><p>请求路由后，会将当前的这个三种过滤器合并到一个链中，依次执行每个过滤器。</p><p><strong>顺序：</strong></p><ul><li>路由过滤器和defaultFilter的order由Spring指定，默认从1开始递增</li><li>当order一样，会按照defaultFilter &gt; 路由过滤器 &gt; GlobalFilter的顺序执行</li></ul><h4 id="跨域问题处理"><a href="#跨域问题处理" class="headerlink" title="跨域问题处理"></a>跨域问题处理</h4><p>跨域问题：浏览器禁止请求的发起者与服务端发生跨域的ajax请求，请求被浏览器拦截</p><p>解决方案：CORS</p><ul><li>Gateway配置跨域</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">gateway</span></span><br><span class="line">  <span class="attr">cloud:</span></span><br><span class="line">    <span class="attr">nacos:</span></span><br><span class="line">      <span class="attr">server-addr:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span><span class="string">:8848</span></span><br><span class="line">    <span class="attr">gateway:</span></span><br><span class="line">      <span class="attr">globalcors:</span></span><br><span class="line">        <span class="attr">add-to-simple-url-handler-mapping:</span> <span class="literal">true</span> <span class="comment"># 解决options请求被拦截</span></span><br><span class="line">        <span class="attr">cors-configurations:</span> </span><br><span class="line">          <span class="string">'[/**]'</span><span class="string">:</span> <span class="comment"># 拦截一切请求</span></span><br><span class="line">            <span class="attr">allowedOrigins:</span> <span class="comment"># 允许哪些网站的跨域请求</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">"http://localhost:8090"</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">"http://www.baidu.com"</span></span><br><span class="line">            <span class="attr">allowedMethods:</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">"GET"</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">"POST"</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">"DELETE"</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">"PUT"</span></span><br><span class="line">              <span class="bullet">-</span> <span class="string">"OPTIONS"</span></span><br><span class="line">            <span class="attr">allowedHeaders:</span> <span class="string">"*"</span> <span class="comment"># 允许携带的请求头信息</span></span><br><span class="line">            <span class="attr">allowCredentials:</span> <span class="literal">true</span> <span class="comment"># 是否允许携带cookie</span></span><br><span class="line">            <span class="attr">maxAge:</span> <span class="number">360000</span> <span class="comment"># 一次跨域请求的有效期</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;介绍Nacos作为注册中心的基本使用&lt;/li&gt;
&lt;li&gt;介绍Nacos作为配置中心的基本使用&lt;/li&gt;
&lt;li&gt;介绍Feign的微服务远程调用（非常实用）&lt;ol&gt;
&lt;li&gt;服务两端统一接口实现&lt;/li&gt;
&lt;li&gt;服务接口统一抽取&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;介绍SpringCloudGateway网关的基本使用&lt;ol&gt;
&lt;li&gt;路由断言&lt;/li&gt;
&lt;li&gt;请求过滤器&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/SpringCloud/"/>
    
      <category term="SpringCloudAlibaba" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/SpringCloud/SpringCloudAlibaba/"/>
    
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="SpringCloudAlibaba" scheme="http://yoursite.com/tags/SpringCloudAlibaba/"/>
    
      <category term="Nacos" scheme="http://yoursite.com/tags/Nacos/"/>
    
  </entry>
  
  <entry>
    <title>Ribbon负载均衡基础</title>
    <link href="http://yoursite.com/2022/11/14/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2022/11/14/Ribbon%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%9F%BA%E7%A1%80/</id>
    <published>2022-11-14T13:35:29.000Z</published>
    <updated>2022-11-14T13:37:38.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>介绍Ribbon负载均衡的一些简单流程和基础知识</p></blockquote><a id="more"></a><h1 id="负载均衡流程"><a href="#负载均衡流程" class="headerlink" title="负载均衡流程"></a>负载均衡流程</h1><ul><li>消费者通过服务名称的url发起请求</li><li>Ribbon对请求进行拦截，然后去找真实地址</li><li>Ribbon通过Eureka拉取到了n个服务列表</li><li>Ribbon对服务进行负载均衡的选取</li><li>请求真实的服务</li></ul><p>PS：<code>@LoadBalanced</code>表示这个Bean的请求要被Ribbon拦截了</p><h2 id="负载均衡策略"><a href="#负载均衡策略" class="headerlink" title="负载均衡策略"></a>负载均衡策略</h2><p>Ribbon中的负载均衡策略类接口：IRule。</p><div class="table-container"><table><thead><tr><th>内置负载均衡规则类</th><th>描述</th></tr></thead><tbody><tr><td>RoundRobinRule</td><td>简单轮询服务列表选择服务器。它是Ribbon默认的负载均衡规则。</td></tr><tr><td>AvailabilityFileteringRule</td><td>- 对服务器3次请求失败，会标记为短路<br>- 忽略并发数过高的服务器，并发数上限可以配置</td></tr><tr><td>WeightedResponseTimeRule</td><td>为服务器赋予权重值。服务器相应时间越长，权重越小。</td></tr><tr><td>ZoneAvoidanceRule</td><td>以区域可用的服务器为基础进行服务器的选择。</td></tr><tr><td>BestAvailabledRule</td><td>忽略短路的服务器，并选择并发低的服务器</td></tr><tr><td>RandomRule</td><td>随机</td></tr><tr><td>RetryRule</td><td>重试</td></tr></tbody></table></div><ul><li>调整规则</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局配置：在Application里面修改负载均衡规则</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IRule <span class="title">randomRule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RandomRule();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部配置：在application.yml里面配置,如在orderservice里面配置userservice服务的负载均衡策略</span></span><br><span class="line">userservice.ribbon.NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</span><br></pre></td></tr></table></figure><h2 id="Ribbon饥饿加载"><a href="#Ribbon饥饿加载" class="headerlink" title="Ribbon饥饿加载"></a>Ribbon饥饿加载</h2><p>默认采用懒加载，第一次访问才会创建拦截客户端，会进行服务拉取，耗时长。</p><ul><li>开启饿加载</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">ribbon:</span></span><br><span class="line"><span class="attr">eager-load:</span></span><br><span class="line"><span class="attr">enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="comment">#clients: userservice # 指定对某个服务饿加载</span></span><br><span class="line"><span class="attr">clients:</span> <span class="comment"># 对多个服务饿加载</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">service1</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">service2</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul><li>负载均衡规则<ul><li>规则接口是IRule</li><li>默认实现是ZoneAvoidanceRule，根据zone选择服务列表，然后轮询</li></ul></li><li>负载均衡自定义方式<ul><li>代码方式：配置灵活，但修改时需要重新打包发布</li><li>配置方式：无需重新打包，无法做全局配置</li></ul></li><li>饥饿加载<ul><li>开启饿加载</li><li>指定饿加载的服务名称</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;介绍Ribbon负载均衡的一些简单流程和基础知识&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/SpringCloud/"/>
    
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="Ribbon" scheme="http://yoursite.com/tags/Ribbon/"/>
    
  </entry>
  
  <entry>
    <title>Erueka基础</title>
    <link href="http://yoursite.com/2022/11/14/Erueka%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2022/11/14/Erueka%E5%9F%BA%E7%A1%80/</id>
    <published>2022-11-14T13:30:00.000Z</published>
    <updated>2022-11-14T13:39:23.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>简单介绍了Erueka作为服务注册中心的基本使用</p></blockquote><a id="more"></a><h1 id="服务调用出现的问题"><a href="#服务调用出现的问题" class="headerlink" title="服务调用出现的问题"></a>服务调用出现的问题</h1><ul><li>URL需要硬编码在代码中，无法动态分配，也无法做负载均衡</li><li>服务消费者该如何获取服务提供者的地址信息？</li><li>如果有多个提供者，消费者如何选择</li><li>消费者如何得知服务的健康状态</li></ul><h1 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h1><p>注册中心。</p><ol><li>服务提供者需要向Eureka注册服务信息</li><li>消费者从Eureka拉取服务</li><li>消费者负载均衡，从列表里挑选一个</li><li>消费者远程调用</li><li>服务提供者会向Eureka提供心跳，Erueka更新服务的异常状态</li></ol><h2 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h2><ul><li>依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- eureka 服务端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- eureka 客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>服务端使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication<span class="class">.<span class="keyword">class</span>, <span class="title">args</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line">  <span class="attr">port:</span> <span class="number">10001</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 服务注册</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">eurekaserver</span> <span class="comment"># 服务名称</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># eureka 的地址信息，eureka会把自己也注册到eureka注册上</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10001/eureka</span></span><br><span class="line">    <span class="attr">fetch-registry:</span> <span class="literal">false</span> <span class="comment"># 启动时不同步集群（因为是单点）</span></span><br></pre></td></tr></table></figure><ul><li>客户端使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用服务名代替ip和端口号</span></span><br><span class="line">String url = “http:<span class="comment">//userservice/user/” + id；</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在RestTemplate上添加负载均衡的注解（Application上）</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 服务注册</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">application:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">orderservice</span> <span class="comment"># 服务名称</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line">  <span class="attr">client:</span></span><br><span class="line">    <span class="attr">service-url:</span> <span class="comment"># eureka 的地址信息，eureka会把自己也注册到eureka注册上</span></span><br><span class="line">      <span class="attr">defaultZone:</span> <span class="string">http://127.0.0.1:10001/eureka</span></span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>搭建EurekaServer<ul><li>引入eureka-server依赖</li><li>添加@EnableEurekaServer注解</li><li>在applcation中配置eureka地址</li></ul></li><li>服务注册<ul><li>引入eureka-client依赖</li><li>在application.yml中配置eureka地址</li></ul></li><li>服务发现<ul><li>引入eureka-client依赖</li><li>在application.yml中配置eureka地址</li><li>给RestTemplate添加@LoadBalanced注解</li><li>用服务提供者的服务名称远程调用</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;简单介绍了Erueka作为服务注册中心的基本使用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="微服务" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/SpringCloud/"/>
    
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
      <category term="Eureka" scheme="http://yoursite.com/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>Swagger-ui</title>
    <link href="http://yoursite.com/2022/11/14/Swagger-ui/"/>
    <id>http://yoursite.com/2022/11/14/Swagger-ui/</id>
    <published>2022-11-14T13:10:19.000Z</published>
    <updated>2022-11-14T13:39:03.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>简单介绍Swagger-ui2.7.0的基本使用</p></blockquote><a id="more"></a><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--swagger--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger2<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.springfox<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.7.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意：不同版本的swagger注解配置有点不一样</p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><ul><li>先要在Java里面配置Config，并加上<code>@EnableSwagger2</code>和<code>Configuration</code>已保证应用启动时可以扫描到配置</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableSwagger</span>2</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SwaggerConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ApiInfo <span class="title">webApiInfo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ApiInfoBuilder()</span><br><span class="line">                .title(<span class="string">"测试"</span>)</span><br><span class="line">                .description(<span class="string">"接口定义"</span>)</span><br><span class="line">                .version(<span class="string">"1.0"</span>)</span><br><span class="line">                .contact(<span class="keyword">new</span> Contact(<span class="string">"memo"</span>, <span class="string">"http://www.memo.com"</span>, <span class="string">"11@qq.com"</span>))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Docket <span class="title">webApiConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Docket(DocumentationType.SWAGGER_2)</span><br><span class="line">                .groupName(<span class="string">"cetc"</span>)</span><br><span class="line">                .apiInfo(webApiInfo())</span><br><span class="line">                .select()</span><br><span class="line">                .paths(Predicates.not(PathSelectors.regex(<span class="string">"/admin/*"</span>)))</span><br><span class="line">                .paths(Predicates.not(PathSelectors.regex(<span class="string">"/error/*"</span>)))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>类上或者方法上加注解（<code>@Api</code>和<code>@ApiOperation</code>）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Api</span>(tags = &#123;<span class="string">"学生管理"</span>&#125;)</span><br><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/student"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentService studentService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiOperation</span>(<span class="string">"查看学生列表"</span>)</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/list"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">getStudentList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;Student&gt; students = studentService.list();</span><br><span class="line">        <span class="keyword">if</span> (students != <span class="keyword">null</span> &amp;&amp; students.size() != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> R.ok().data(<span class="string">"students"</span>, students);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> R.error();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 属性也可以写</span></span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">R</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"是否成功"</span>)</span><br><span class="line">    <span class="keyword">private</span> Boolean success;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"返回状态码"</span>)</span><br><span class="line">    <span class="keyword">private</span> Integer code;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"返回消息"</span>)</span><br><span class="line">    <span class="keyword">private</span> String message;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ApiModelProperty</span>(value = <span class="string">"返回数据"</span>)</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Object&gt; data = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">R</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> R <span class="title">ok</span><span class="params">()</span></span>&#123;</span><br><span class="line">        R r = <span class="keyword">new</span> R();</span><br><span class="line">        r.setSuccess(<span class="keyword">true</span>);</span><br><span class="line">        r.setCode(ResultCode.SUCCESS);</span><br><span class="line">        r.setMessage(<span class="string">"成功"</span>);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> R <span class="title">error</span><span class="params">()</span></span>&#123;</span><br><span class="line">        R r = <span class="keyword">new</span> R();</span><br><span class="line">        r.setSuccess(<span class="keyword">false</span>);</span><br><span class="line">        r.setCode(ResultCode.ERROR);</span><br><span class="line">        r.setMessage(<span class="string">"失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">success</span><span class="params">(Boolean success)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setSuccess(success);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">code</span><span class="params">(Integer code)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setCode(code);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">message</span><span class="params">(String message)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setMessage(message);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">data</span><span class="params">(String key, Object value)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data.put(key, value);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> R <span class="title">data</span><span class="params">(Map&lt;String, Object&gt; map)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.setData(map);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输入网址：<code>localhost:xxxx/swagger-ui.html</code></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;简单介绍Swagger-ui2.7.0的基本使用&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Netty进阶</title>
    <link href="http://yoursite.com/2022/07/21/Netty%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2022/07/21/Netty%E8%BF%9B%E9%98%B6/</id>
    <published>2022-07-21T06:05:21.000Z</published>
    <updated>2022-07-21T06:07:42.592Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Netty进阶"><a href="#Netty进阶" class="headerlink" title="Netty进阶"></a>Netty进阶</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Netty进阶&quot;&gt;&lt;a href=&quot;#Netty进阶&quot; class=&quot;headerlink&quot; title=&quot;Netty进阶&quot;&gt;&lt;/a&gt;Netty进阶&lt;/h1&gt;
      
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Netty基础</title>
    <link href="http://yoursite.com/2022/07/15/Netty%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2022/07/15/Netty%E5%9F%BA%E7%A1%80/</id>
    <published>2022-07-15T09:06:22.000Z</published>
    <updated>2022-07-17T12:02:52.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>介绍Netty的概述和基础用法。</p><blockquote><ol><li>组件</li><li>简单实现</li></ol></blockquote><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>Netty是一个异步的、基于事件驱动的网络应用框架，用于快速开发可维护、高性能的网络服务端和客户端。这里的异步并没有使用AIO，只是使用了多线程。Netty在网络应用框架中的地位，相当于Spring框架在javaEE开发中的地位。</p><p><strong>Netty的优势：</strong></p><ul><li><p>Netty vs NIO: 工作量大，bug多</p><blockquote><ol><li>需要自己构建协议</li><li>解决TCP传输的问题，如黏包、半包</li><li>epoll空轮询导致CPU 100%</li><li>对API进行增强，使之更加易用，如<code>FastThreadLocal =&gt; ThreadLocal, ByteBuf =&gt; ByteBuffer</code></li></ol></blockquote></li><li><p>Netty vs 其他网络框架：Netty地位是龙头的，文档也优秀</p></li></ul><h1 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h1><ul><li>依赖</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.netty<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>netty-all<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.1.50.Final<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>服务端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 服务器端的启动器，负责组装Netty组件并启动</span></span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">            <span class="comment">// 2. Boss + Worker(thread, worker) ==&gt; 加入一个组，自动监听accept read</span></span><br><span class="line">            .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">            <span class="comment">// 3. 选择服务器的实现（可以是NIO,OIO,BIO等），</span></span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            // 4. <span class="title">boss</span>负责连接，<span class="title">child</span>（即<span class="title">worker</span>）负责读写，这里添加<span class="title">worker</span>事件触发的具体处理（<span class="title">handler</span>）</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(</span></span><br><span class="line"><span class="class">            // 5. 和客户端连接<span class="title">Channel</span>的初始化器，负责增强这个<span class="title">channel</span></span></span><br><span class="line"><span class="class">            <span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">NioSocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">// 6. 添加解码器 ByteBuf -&gt; String</span></span><br><span class="line">                    nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> StringDecoder());</span><br><span class="line">                    <span class="comment">// 7.添加自定义channel，读事件发生后转换上一步转换的字符串</span></span><br><span class="line">                    nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            System.out.println(msg);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            <span class="comment">// 8. 绑定监听端口</span></span><br><span class="line">            .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Bootstrap()</span><br><span class="line">            .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">            .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">NioSocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="comment">// 连接建立后</span></span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">// 客户端发送的数据进行编码</span></span><br><span class="line">                    nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .connect(<span class="string">"localhost"</span>, <span class="number">8080</span>)</span><br><span class="line">            .sync()</span><br><span class="line">            .channel()</span><br><span class="line">            .writeAndFlush(<span class="string">"hello world"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h2><ul><li>Channel理解成数据的传输通道</li><li>把Msg理解成channel中流动的数据,最开始是ByteBuf，通过pipeline流水线进行加工，最终变成其他的样子，最后又通过ByteBuf输出</li><li>把handler理解成数据处理的工序，处理工序合在一起就是pipeline(ChannelPipeline)，这个流水线可以在channel的各种事件的前后切点处织入方法（方法可以自定义）<ul><li>handler分为Inbound和outbound（数据入栈和出栈）</li></ul></li><li>eventLoop理解成工人（selector + 单线程线程池）<ul><li>工人管理多个channel的io操作，并且会和这些channel绑定（selector绑定， IO绑定）</li><li>工人既可以执行io操作，也可以进行数据逻辑处理（数据的处理和selector就没关系了），每个工人有任务队列（阻塞），任务可以分为定时任务和普通任务</li><li>工人根据pipeline的顺序，去处理数据，每道工序都可以指派给不同的工人（离谱），但最后还是由这个工人来执行最后的IO。<ul><li>换句话讲，就是第一个handle负责绑定EventLoop，尾部handle负责IO，尾部必须使用首部绑定的EventLoop</li></ul></li></ul></li></ul><h1 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h1><h2 id="Eventloop"><a href="#Eventloop" class="headerlink" title="Eventloop"></a>Eventloop</h2><p>事件循环对象。</p><p>Eventloop本质是一个单线程执行器（同时维护了一个selector），里面有run方法执行源源不断的IO事件。</p><p><strong>继承关系（复杂）</strong></p><ul><li><code>SchelduledExecutorService</code>:包含了线程池中所有方法</li><li>自己的<code>OrderedEventExecutor</code><ul><li><code>boolean inEventloop(Thread thread)</code>：判断线程是否属于这个loop</li><li><code>parent()</code>查看自己属于哪个Group</li></ul></li></ul><h2 id="EventloopGroup"><a href="#EventloopGroup" class="headerlink" title="EventloopGroup"></a>EventloopGroup</h2><p>事件循环组。</p><p>一组Eventloop，channel会调用group中的register方法绑定其中的一个Eventloop，后续的IO操作都有这个Eventloop处理。</p><p><img src="/2022/07/15/Netty%E5%9F%BA%E7%A1%80/eventloopGroup.png" alt></p><p><strong>基本操作样例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEventLoop</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 创建事件循环组， 默认线程数是cpu核心数的两倍</span></span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>); <span class="comment">// 可以绑定 io事件，普通任务，定时任务</span></span><br><span class="line">        <span class="comment">// DefaultEventLoopGroup group1 = new DefaultEventLoopGroup(); // 普通任务，定时任务</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 获取下一个事件循环对象</span></span><br><span class="line">        EventLoop loop = group.next(); <span class="comment">// 可以循环重复获取，数组取模</span></span><br><span class="line">        <span class="comment">// 3. 执行普通任务</span></span><br><span class="line">        loop.submit(() -&gt; System.out.println(<span class="number">1111</span>));</span><br><span class="line">        <span class="comment">// 4. 定时任务</span></span><br><span class="line">        group.next().scheduleAtFixedRate(() -&gt; System.out.println(<span class="number">2222</span>), <span class="number">0L</span>, <span class="number">1L</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>channel绑定案例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 服务端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">            <span class="comment">// 第一个eventgroup只处理accept，另一个是worker，处理read等</span></span><br><span class="line">            .group(<span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>), <span class="keyword">new</span> NioEventLoopGroup(<span class="number">4</span>))</span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">NioSocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    nioSocketChannel.pipeline().addLast(<span class="keyword">new</span> ChannelInboundHandlerAdapter()&#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                            System.out.println(buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Channel channel = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">            .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">            .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">NioSocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    ch.pipeline().addLast(<span class="keyword">new</span> StringEncoder());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8080</span>))</span><br><span class="line">            .sync()</span><br><span class="line">            .channel();</span><br><span class="line">        System.out.println(channel);</span><br><span class="line">        System.out.println(<span class="string">""</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题：如果一个EventLoop绑定了很多channel，处理某一个channel的handle时间过长，则会阻塞其他channel的事件，这怎么办？</strong></p><p><strong>答：做一次细分，创建一个独立的EventLoop来处理handle的任务，将IO和数据逻辑处理分离。</strong></p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Sl</span>4fj</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        DefaultEventLoopGroup taskGroup = <span class="keyword">new</span> DefaultEventLoopGroup();</span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">            <span class="comment">// 第一个eventgroup只处理accept，另一个是worker，处理read等</span></span><br><span class="line">            .group(<span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>), <span class="keyword">new</span> NioEventLoopGroup(<span class="number">4</span>))</span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">NioSocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel nioSocketChannel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    nioSocketChannel.pipeline().addLast(<span class="string">"handler1"</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                            log.info(buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                            ctx.fireChannelRead(msg); <span class="comment">// 将消息传递给下一个handler（自定义handler需要加)</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).addLast(taskGroup, <span class="string">"handler2"</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123; <span class="comment">// 指定这个数据处理用另一个线程</span></span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                            log.info(buf.toString(StandardCharsets.UTF_8));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .bind(<span class="number">8080</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="handle切换线程原理"><a href="#handle切换线程原理" class="headerlink" title="handle切换线程原理"></a>handle切换线程原理</h3><p><strong>关键代码：</strong><code>io.netty.channel.AbstractChannelHandlerContext</code></p><p><strong>每个handler都要判断下一个handler是否绑定了当前的EventLoop。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// next表示下一个事件处理器（handler），当前handler会在这个函数判断下一个handler的状态</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>), next);</span><br><span class="line">    EventExecutor executor = next.executor(); <span class="comment">// 下一个handler的线程</span></span><br><span class="line">    <span class="keyword">if</span> (executor.inEventLoop()) &#123; <span class="comment">// 如果下一个handler的线程也在这个eventloop里面（共用一个线程）</span></span><br><span class="line">        next.invokeChannelRead(m); <span class="comment">// 直接在当前线程处理事件</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123; <span class="comment">// 用下 一个线程触发事件</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                next.invokeChannelRead(m);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p>方法：</p><ul><li><code>close()</code>：用来关闭channel（异步关闭，返回一个ChannelFutrue）</li><li><code>closeFuture()</code>：用来处理close的关闭<ul><li><code>sync()</code>：同步等待channel关闭</li><li><code>addListener()</code>：异步等待关闭</li></ul></li><li><code>pipeline()</code>：添加处理器</li><li><code>write()</code>：数据写入，可能会先进入缓冲</li><li><code>wtiteAndFlush()</code>：数据写入并刷出 </li></ul><h2 id="ChannelFuture"><a href="#ChannelFuture" class="headerlink" title="ChannelFuture"></a>ChannelFuture</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChannelFutureClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ChannelFuture channelFuture = <span class="keyword">new</span> Bootstrap()</span><br><span class="line">            .group(<span class="keyword">new</span> NioEventLoopGroup())</span><br><span class="line">            .channel(NioSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">NioSocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel nc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    <span class="comment">//...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .connect(<span class="string">"localhost"</span>, <span class="number">8080</span>);</span><br><span class="line">        Channel channel = channelFuture.channel(); </span><br><span class="line">        channel.writeAndFlush(<span class="string">"1111"</span>); <span class="comment">// 服务端无法接受数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题：为什么无法发送数据呢？</strong></p><p><strong>答：</strong></p><ul><li><code>connect</code>方法是<strong>异步非阻塞</strong>的，主线程调用connect，但是由另一个NIO线程去建立连接。<ul><li>一般连接都比较慢，需要1s去连接</li></ul></li><li>主线程去如果不执行<code>sync</code>，连接还未建立，write自然就不生效了。</li></ul><h3 id="发送数据"><a href="#发送数据" class="headerlink" title="发送数据"></a>发送数据</h3><p><strong><font color="brown">一般带有Future和Promise的类就是为了用来异步处理结果的。</font></strong></p><p>获取异步处理结果，让Channel能发送数据的方法如下：</p><ol><li><code>sync</code>：阻塞主线程直到NIO成功建立连接</li><li><code>addListener</code>：异步等待channel连接的结果（给一个回调对象）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法1</span></span><br><span class="line">channelFuture.sync();</span><br><span class="line">Channel channel = channelFuture.channel();</span><br><span class="line">channel.writeAndFlush(<span class="string">"1111"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法2</span></span><br><span class="line">channelFuture.addListener((ChannelFutureListener) future -&gt; &#123;</span><br><span class="line">    Channel channel1 = future.channel();</span><br><span class="line">    channel.writeAndFlush(<span class="string">"qqqqqqqq"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Channel channel = channelFuture.sync().channel();</span><br><span class="line"><span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">    Scanner in = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        String next = in.next();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"q"</span>.equals(next)) &#123;</span><br><span class="line">            channel.close(); <span class="comment">// 异步关闭</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        channel.writeAndFlush(next);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="string">"input"</span>).start();</span><br></pre></td></tr></table></figure><p>因为<code>channel.close</code>异步，那如何在channel关闭后，处理业务逻辑？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ChannelFuture future = channel.closeFuture();</span><br><span class="line"><span class="comment">// 方法1</span></span><br><span class="line">future.sync();</span><br><span class="line"><span class="comment">// + 业务逻辑...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步处理</span></span><br><span class="line">future.addListener((f) -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure><p><strong>还有问题：channel关闭后，主线程并没有退出，占用资源，如果优雅退出？</strong></p><ul><li>把EventLoopGroup关闭掉：<code>group.shutdownGracefully()</code></li></ul><h2 id="Future-amp-amp-Promise"><a href="#Future-amp-amp-Promise" class="headerlink" title="Future &amp;&amp; Promise"></a>Future &amp;&amp; Promise</h2><ul><li>Netty中的Future继承自JDK中的Future接口</li><li>Netty中的Promise继承自Netty的Future接口</li></ul><p>功能：</p><ul><li>JDK的Future只能同步等待任务结束才能得到结果</li><li>Netty的Futrue可以通过<strong>异步方式获取结果</strong>（addListener）</li><li>Netty的Promise可以脱离任务存在，只作为两个线程间传递数据的容器</li></ul><p>Promise样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNettyPromise</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">        NioEventLoopGroup loopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoop loop = loopGroup.next();</span><br><span class="line">        DefaultPromise&lt;Object&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(loop);</span><br><span class="line">        <span class="comment">// 填充计算结果</span></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            log.info(<span class="string">"...开始计算"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>); <span class="comment">// 计算</span></span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            promise.setSuccess(<span class="number">800</span>);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        log.info(<span class="string">"等待结果..."</span>);</span><br><span class="line">        log.info(<span class="string">"结果：&#123;&#125;"</span>, promise.get()); <span class="comment">// 阻塞直到有结果</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Handler-amp-amp-pipeline"><a href="#Handler-amp-amp-pipeline" class="headerlink" title="Handler &amp;&amp; pipeline"></a>Handler &amp;&amp; pipeline</h2><p>ChannelHandler用来处理Channel上的各种事件，分为入站和出站handler（读入和写出），所有的ChannelHandler组成一串，就是pipeline。</p><ul><li>入站处理器通常继承<code>ChannelInboundHandlerAdapter</code>类，主要用来读取客户端数据，返回结果</li><li><p>出站处理器通常继承<code>ChannelOutboundHandlerAdapter</code>类，主要对写回结果进行加工</p></li><li><p>入站执行按找pipeline顺序<strong>(head —&gt; tail)</strong>，出站按照pipeline反序<strong>(tail —-&gt; head)</strong></p><ul><li>要有写事件，才会触发出站</li><li>注意代码里的write注释，如果用ctx，则会从ctx所在handler向前找出站处理器，如果用nc，则是从tail开始找。</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNettyHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> ServerBootstrap()</span><br><span class="line">            .group(<span class="keyword">new</span> NioEventLoopGroup(), <span class="keyword">new</span> NioEventLoopGroup(<span class="number">2</span>))</span><br><span class="line">            .channel(NioServerSocketChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            // <span class="title">head</span> -- <span class="title">h1</span> -- <span class="title">h2</span> -- <span class="title">h3</span> -- <span class="title">h4</span> -- <span class="title">h5</span> -- <span class="title">h6</span> -- <span class="title">tail</span> (双向)</span></span><br><span class="line"><span class="class">            .<span class="title">childHandler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">NioSocketChannel</span>&gt;() </span>&#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel nc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                    nc.pipeline().addLast(<span class="string">"h1"</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.info(<span class="string">"1"</span>);</span><br><span class="line">                            <span class="keyword">super</span>.channelRead(ctx, msg); <span class="comment">// 必须调用，找到下一个处理器，不然链就断了</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).addLast(<span class="string">"h2"</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.info(<span class="string">"2"</span>);</span><br><span class="line">                            <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).addLast(<span class="string">"h3"</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.info(<span class="string">"3"</span>);</span><br><span class="line">                            nc.writeAndFlush(<span class="string">"111"</span>); <span class="comment">// 如果调用ctx.write, 则只会从h3向前找出站处理器，导致啥也不打印</span></span><br><span class="line">                            <span class="keyword">super</span>.channelRead(ctx, msg);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).addLast(<span class="string">"h4"</span>, <span class="keyword">new</span> ChannelOutboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.info(<span class="string">"4"</span>);</span><br><span class="line">                            <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).addLast(<span class="string">"h5"</span>, <span class="keyword">new</span> ChannelOutboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.info(<span class="string">"5"</span>);</span><br><span class="line">                            <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).addLast(<span class="string">"h6"</span>, <span class="keyword">new</span> ChannelOutboundHandlerAdapter() &#123;</span><br><span class="line">                        <span class="meta">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                            log.info(<span class="string">"6"</span>);</span><br><span class="line">                            <span class="keyword">super</span>.write(ctx, msg, promise);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .bind(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">###### 客户端发送数据后 #####</span><br><span class="line">    服务端：</span><br><span class="line"><span class="number">15</span>:<span class="number">28</span>:<span class="number">06.481</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] INFO  c.e.demo.netty.c3.TestNettyHandler - <span class="number">1</span></span><br><span class="line"><span class="number">15</span>:<span class="number">28</span>:<span class="number">06.484</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] INFO  c.e.demo.netty.c3.TestNettyHandler - <span class="number">2</span></span><br><span class="line"><span class="number">15</span>:<span class="number">28</span>:<span class="number">06.484</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] INFO  c.e.demo.netty.c3.TestNettyHandler - <span class="number">3</span></span><br><span class="line"><span class="number">15</span>:<span class="number">28</span>:<span class="number">06.484</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] INFO  c.e.demo.netty.c3.TestNettyHandler - <span class="number">6</span></span><br><span class="line"><span class="number">15</span>:<span class="number">28</span>:<span class="number">06.484</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] INFO  c.e.demo.netty.c3.TestNettyHandler - <span class="number">5</span></span><br><span class="line"><span class="number">15</span>:<span class="number">28</span>:<span class="number">06.484</span> [nioEventLoopGroup-<span class="number">3</span>-<span class="number">1</span>] INFO  c.e.demo.netty.c3.TestNettyHandler - <span class="number">4</span></span><br></pre></td></tr></table></figure><p>为什么要写Handler？ —&gt; 业务处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;...&#125;.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel nc)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        nc.pipeline().addLast(<span class="string">"h1"</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                ByteBuf buf = (ByteBuf) msg;</span><br><span class="line">                String jsonString = buf.toString(StandardCharsets.UTF_8);</span><br><span class="line">                <span class="keyword">super</span>.channelRead(ctx, jsonString); <span class="comment">// 找下一个handler</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).addLast(<span class="string">"h2"</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object jsonString)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                String s = (String) jsonString;</span><br><span class="line">                <span class="keyword">char</span>[] chars = s.toCharArray();</span><br><span class="line">                <span class="keyword">super</span>.channelRead(ctx, chars);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).addLast(<span class="string">"h3"</span>, <span class="keyword">new</span> ChannelInboundHandlerAdapter() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                nc.writeAndFlush(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).&#123;.....&#125;</span><br></pre></td></tr></table></figure><h3 id="EmbeddedChannel"><a href="#EmbeddedChannel" class="headerlink" title="EmbeddedChannel"></a>EmbeddedChannel</h3><p>用来测试的内部Channel，里面可以绑定多个channel，这样就不用模拟一个服务端和客户端了。</p><ul><li>构造器里面按顺序传handler</li><li><code>wirteInbound</code>: 模拟入站</li><li><code>writeOutbound</code>:模拟出站</li></ul><h2 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h2><h3 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(); <span class="comment">// 默认256，自动扩容</span></span><br></pre></td></tr></table></figure><ul><li>创建一个默认的ByteBuf（池化基于<strong>直接内存</strong>的ByteBuf），初始容量为256（默认，也可以自己指定）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 打印工具</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(ByteBuf buf)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = buf.readableBytes();</span><br><span class="line">    <span class="keyword">int</span> rows = length / <span class="number">16</span> + (length % <span class="number">15</span> == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>) + <span class="number">4</span>;</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder(rows * <span class="number">80</span> * <span class="number">2</span>)</span><br><span class="line">        .append(<span class="string">"readIdx: "</span>).append(buf.readerIndex())</span><br><span class="line">        .append(<span class="string">" writeIdx: "</span>).append(buf.writerIndex())</span><br><span class="line">        .append(<span class="string">" capacity: "</span>).append(buf.capacity())</span><br><span class="line">        .append(NEWLINE);</span><br><span class="line">    appendPrettyHexDump(sb, buf);</span><br><span class="line">    System.out.println(sb.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="直接内存和堆内存"><a href="#直接内存和堆内存" class="headerlink" title="直接内存和堆内存"></a>直接内存和堆内存</h3><blockquote><ol><li><p>直接内存分配慢，但读取快，要手动释放或归还，默认直接内存</p></li><li><p>堆内存分配快，读取慢，容易受垃圾回收影响</p></li></ol></blockquote><ul><li><p>初始化堆内存</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.heapBuffer();</span><br></pre></td></tr></table></figure></li><li><p>初始化直接内存</p>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ByteBuf buf = ByteBufAllocator.DEFAULT.directBuffer();</span><br></pre></td></tr></table></figure></li></ul><h3 id="池化和非池化"><a href="#池化和非池化" class="headerlink" title="池化和非池化"></a>池化和非池化</h3><p>池化的最大意义在ByteBuf可以重用，优点是：</p><ul><li>没有池化，每次都要创建新的ByteBuf实例，这个操作对直接内存代价昂贵，就算是堆内存，也会加重GC负担</li><li>有池化，重用池中的ByteBuf实例，采用了与jemalloc类似的内存分配算法提高分配效率</li><li>高并发时，池化功能更加节约内存，减少内存溢出的可能性</li></ul><p>池化功能是否开启，可以 通过下面的系统环境变量来设置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Dio.netty.allocator.type=&#123;unpooled|pooled&#125;</span><br></pre></td></tr></table></figure><ul><li>4.1 以后池化是默认开启</li><li>直接内存和堆内存都有池化功能</li></ul><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><img src="/2022/07/15/Netty%E5%9F%BA%E7%A1%80/bytebuf.png" alt></p><ul><li>灰色是已读部分</li><li>绿箭头是<strong>读指针</strong>，绿色是未读已写</li><li><p>蓝箭头是<strong>写指针</strong>，蓝色是可写部分</p></li><li><p>橙色区域是可扩容容量。容量按需扩容。</p></li></ul><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><ul><li>writeBoolean(boolean bool)：写入一个字节（0：false；1：true）</li><li>writeByte(int val)</li><li>writeInt(int value)：小端写入（先写低位字节）</li><li>writeIntE(int value):：大端写入（先写高位字节），网络编程一般采用大端</li><li>….</li><li>writeBytes(byte[] bytes)</li><li>writeBytes(ByteBuf buf)</li><li>int writeCharSequence(CharSequence chars, Charset charset)：写入字符串</li></ul><p>注意：</p><blockquote><ol><li>除了最后一个，其余方法都是返回ByteBuf</li><li>网络编程一般都是大端写入</li></ol></blockquote><h3 id="扩容"><a href="#扩容" class="headerlink" title="扩容"></a>扩容</h3><blockquote><ol><li>写入的数据大小未超过512字节，按照16的整数倍扩容（写入33，扩容成16 * 3 = 48）</li><li>写入的数据大小超过512字节，按照2的n次方扩容（写入513，扩容成2的10次方=1024）</li></ol></blockquote><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><ul><li>readByte() ：每次读取一个字节，读过的就废弃了，不能再读了</li><li>markReadIndex()：标记</li><li>reset()：读指针重置到标记</li></ul><h3 id="retain-amp-amp-release"><a href="#retain-amp-amp-release" class="headerlink" title="retain &amp;&amp; release"></a>retain &amp;&amp; release</h3><p>Netty中有堆外内存的的ByteBuf实现，堆外内存最好手动释放，而不是等GC回收。</p><ul><li>UnpooledHeapByteBuf使用JVM内存，等GC回收内存就好</li><li>UnpooledDirectByteBuf使用的就是直接内存，可以等GC间接回收，但不建议，需要特殊方法来回收内存</li><li>PooledByteBuf和它的子类使用了池化机制，需要更负责的机制来回收内存</li></ul><blockquote><p>回收内存的源码实现，下列方法的不同实现</p><p><code>abstract void deallocate()</code></p></blockquote><p>Netty使用了引用计数法来控制回收内存，每个ByteBuf都实现了ReferenceCounted接口</p><ul><li>每个ByteBuf对象初始计数为1</li><li>调用release方法，计数减1，计数为0则回收ByteBuf</li><li>调用retain方法，计数加1，免得其他handler调用release影响到我正在使用的buf</li><li>当计数为0，底层内存内回收，即使ByteBuf对象还在，也不能使用了</li></ul><p><strong>谁来负责release？</strong></p><p>谁最后负责ByteBuf，谁负责ByteBuf的释放。</p><ul><li>如果ByteBuf传递到header和tail，它们会处理</li><li>如果ByteBuf没到最后（可能是已经转成了字符串），那么就不会处理</li></ul><h3 id="Slice"><a href="#Slice" class="headerlink" title="Slice"></a>Slice</h3><p>【零拷贝】的体现之一。对原始的ByteBuf进行切片，切片后的ByteBuf没有进行内存复制，还是沿用原始的ByteBuf内存，切片后的ByteBuf维护独立的read，write指针。</p><p><img src="/2022/07/15/Netty%E5%9F%BA%E7%A1%80/bytebuf-slice.png" alt></p><ul><li><code>slice(int idx, int len)</code>:切片过程中没有发生数据复制（<strong>非常牛逼！！！</strong>）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteBufSlice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">        buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'a'</span>&#125;);</span><br><span class="line">        <span class="comment">// log(buf);</span></span><br><span class="line">        ByteBuf buf1 = buf.slice(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        ByteBuf buf2 = buf.slice(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">        log(buf1);</span><br><span class="line">        buf2.setByte(<span class="number">2</span>, <span class="string">'x'</span>); <span class="comment">// 修改buf2</span></span><br><span class="line">        log(buf2);</span><br><span class="line">        log(buf); <span class="comment">// 可以看到原始的buf也被修改了，也就是说内存没比那</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>问题：切片后要是想加额外的字节，岂不是乱套了？</strong></p><p><strong>答：不允许添加， 要加限制，原始内存不能释放。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteBufSlice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">10</span>);</span><br><span class="line">        buf.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>,<span class="string">'7'</span>,<span class="string">'8'</span>,<span class="string">'9'</span>,<span class="string">'a'</span>&#125;);</span><br><span class="line">        <span class="comment">// log(buf);</span></span><br><span class="line">        ByteBuf buf1 = buf.slice(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        buf1.retain(); <span class="comment">// 计数 + 1</span></span><br><span class="line">        ByteBuf buf2 = buf.slice(<span class="number">4</span>, <span class="number">6</span>);</span><br><span class="line">        buf.retain();</span><br><span class="line">        log(buf1);</span><br><span class="line">        buf1.release(); <span class="comment">// 使用完，计数 - 1</span></span><br><span class="line">        buf2.setByte(<span class="number">2</span>, <span class="string">'x'</span>);</span><br><span class="line">        log(buf2);</span><br><span class="line">        buf2.release(); <span class="comment">// 使用完，计数 - 1</span></span><br><span class="line">        log(buf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="duplicate-amp-amp-copy"><a href="#duplicate-amp-amp-copy" class="headerlink" title="duplicate &amp;&amp; copy"></a>duplicate &amp;&amp; copy</h3><ul><li><p>Duplicate: 也是零拷贝。可以理解成引用全部，但读写指针独立。</p></li><li><p>Copy：深拷贝。</p></li></ul><h3 id="composite"><a href="#composite" class="headerlink" title="composite"></a>composite</h3><p>零拷贝，把ByteBuf整合。和<code>writeBytes</code>深拷贝对应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestByteComposite</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuf buf1 = ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        buf1.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;);</span><br><span class="line">        buf1.retain();</span><br><span class="line">        ByteBuf buf2 = ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        buf2.retain();</span><br><span class="line">        buf2.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>&#125;);</span><br><span class="line">        ByteBuf buf3 = ByteBufAllocator.DEFAULT.buffer();</span><br><span class="line">        buf3.retain();</span><br><span class="line">        buf3.writeBytes(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>&#125;);</span><br><span class="line"></span><br><span class="line">        CompositeByteBuf compositeByteBuf = ByteBufAllocator.DEFAULT.compositeBuffer();</span><br><span class="line">        compositeByteBuf.addComponents(<span class="keyword">true</span>, buf1, buf2); <span class="comment">// 加true自动移动写指针</span></span><br><span class="line">        buf1.release();buf2.release();</span><br><span class="line">        compositeByteBuf.addComponent(buf3); <span class="comment">// 不加true，不会变写指针，只会改变capacity, writeIdx: 10 ,cap: 15</span></span><br><span class="line">        <span class="comment">// 可见如果维护写指针，会找上一个写指针的位置往后写，并不是单纯的内存拼接</span></span><br><span class="line">        compositeByteBuf.addComponent(<span class="keyword">true</span>, buf3); <span class="comment">// writeIdx：15， cap: 20</span></span><br><span class="line">        buf3.release();</span><br><span class="line">        log(compositeByteBuf);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p>使用零拷贝，最好都要retain和release。</p><h3 id="UDP的简单实现（纯原创，欢迎交流）"><a href="#UDP的简单实现（纯原创，欢迎交流）" class="headerlink" title="UDP的简单实现（纯原创，欢迎交流）"></a>UDP的简单实现（纯原创，欢迎交流）</h3><p>上面都是TCP，咱们参照github，写一段UDP的链接，<a href="https://github.com/netty/netty" target="_blank" rel="noopener">Netty-github官网</a>。</p><ul><li>服务端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioEventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Bootstrap b = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">            b.group(eventLoopGroup)</span><br><span class="line">                .channel(NioDatagramChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">handler</span>(<span class="title">new</span> <span class="title">UDPServerHandler</span>())</span>;</span><br><span class="line">            Channel udpChannel = b.bind(<span class="number">8888</span>).sync().channel();</span><br><span class="line">            log.info(<span class="string">"开启线程...."</span>);</span><br><span class="line">            udpChannel.closeFuture().await(); <span class="comment">// 阻塞直到连接关闭</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            log.error(<span class="string">"完蛋了，服务端挂了....."</span>);</span><br><span class="line">            eventLoopGroup.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPServerHandler</span> <span class="keyword">extends</span> <span class="title">SimpleChannelInboundHandler</span>&lt;<span class="title">DatagramPacket</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext ctx, DatagramPacket udpPack)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        log.info(udpPack.toString());</span><br><span class="line">        ByteBuf content = udpPack.content();</span><br><span class="line">        ByteBuf xxlx_buf = content.slice(<span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">        xxlx_buf.retain();</span><br><span class="line">        <span class="keyword">int</span> xxlx = xxlx_buf.readInt();</span><br><span class="line">        log.info(String.valueOf(xxlx));</span><br><span class="line">        xxlx_buf.release();</span><br><span class="line">        ByteBuf msg_buf = content.slice(<span class="number">4</span>, content.writerIndex());</span><br><span class="line">        msg_buf.retain();</span><br><span class="line">        log.info(msg_buf.toString(CharsetUtil.UTF_8));</span><br><span class="line">        msg_buf.release();</span><br><span class="line">        <span class="comment">// 回执</span></span><br><span class="line">        ctx.write(</span><br><span class="line">            <span class="keyword">new</span> DatagramPacket(</span><br><span class="line">                Unpooled.wrappedBuffer(<span class="string">"success"</span>.getBytes(CharsetUtil.UTF_8))</span><br><span class="line">                , udpPack.sender()</span><br><span class="line">            )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ctx.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UDPClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String ip, <span class="keyword">int</span> port, T obj)</span> </span>&#123;</span><br><span class="line">        send(ip, port, obj, (data) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 模拟押包</span></span><br><span class="line">            ByteBuf buf = ByteBufAllocator.DEFAULT.buffer(<span class="number">128</span>);</span><br><span class="line">            buf.writeInt(<span class="number">5514</span>);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count++ &lt; <span class="number">124</span>) &#123;</span><br><span class="line">                buf.writeByte(<span class="string">'x'</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> buf;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String ip, <span class="keyword">int</span> port, T obj, PackageFunc&lt;T&gt; func)</span> </span>&#123;</span><br><span class="line">        InetSocketAddress address = <span class="keyword">new</span> InetSocketAddress(ip, port);</span><br><span class="line">        Bootstrap client = <span class="keyword">new</span> Bootstrap();</span><br><span class="line">        NioEventLoopGroup group = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">        EventLoop watcher = group.next();</span><br><span class="line">        DefaultPromise&lt;Object&gt; promise = <span class="keyword">new</span> DefaultPromise&lt;&gt;(watcher);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client.group(group)</span><br><span class="line">                .channel(NioDatagramChannel<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">option</span>(<span class="title">ChannelOption</span>.<span class="title">SO_BROADCAST</span>, <span class="title">false</span>)</span></span><br><span class="line"><span class="class">                .<span class="title">handler</span>(<span class="title">new</span> <span class="title">ChannelInitializer</span>&lt;<span class="title">NioDatagramChannel</span>&gt;() </span>&#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioDatagramChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="comment">// 用另一个线程去监听回执</span></span><br><span class="line">                        ch.pipeline().addLast(<span class="string">"watcher"</span>, <span class="keyword">new</span> SimpleChannelInboundHandler&lt;DatagramPacket&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">channelRead0</span><span class="params">(ChannelHandlerContext cxt, DatagramPacket udpPack)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                                ByteBuf content = udpPack.content();</span><br><span class="line">                                String s = content.toString(CharsetUtil.UTF_8);</span><br><span class="line">                                log.info(s);</span><br><span class="line">                                <span class="keyword">if</span> (<span class="string">"success"</span>.equals(s)) &#123;</span><br><span class="line">                                    promise.setSuccess(<span class="string">"success"</span>);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            Channel channel = client.bind(<span class="number">0</span>).sync().channel();</span><br><span class="line">            channel.writeAndFlush(<span class="keyword">new</span> DatagramPacket(func.doPack(obj), address)).sync();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 超时重传3次</span></span><br><span class="line">            AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">while</span> (count.getAndIncrement() &lt; <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">// 主线程等待7秒，检查回执是否过来</span></span><br><span class="line">                <span class="keyword">boolean</span> await = promise.await(<span class="number">7</span>, TimeUnit.SECONDS);</span><br><span class="line">                <span class="keyword">if</span> (await) &#123;</span><br><span class="line">                    log.info(<span class="string">"发送成功！"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.error(<span class="string">"第&#123;&#125;次发送失败，正在重试..."</span>, count.get());</span><br><span class="line">                    channel.writeAndFlush(<span class="keyword">new</span> DatagramPacket(func.doPack(obj), address)).sync();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count.get() &gt; <span class="number">3</span>) log.error(<span class="string">"草拟吗连不上啊！！"</span>);</span><br><span class="line">            channel.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            log.error(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            group.shutdownGracefully();</span><br><span class="line">            watcher.shutdownGracefully();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        send(<span class="string">"localhost"</span>, <span class="number">8888</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;介绍Netty的概述和基础用法。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;组件&lt;/li&gt;
&lt;li&gt;简单实现&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>NIO基础</title>
    <link href="http://yoursite.com/2022/07/15/NIO%E5%9F%BA%E7%A1%80/"/>
    <id>http://yoursite.com/2022/07/15/NIO%E5%9F%BA%E7%A1%80/</id>
    <published>2022-07-14T17:07:17.000Z</published>
    <updated>2022-07-15T07:53:11.577Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>目前互联网环境下，分布式系统十分重要，而分布式的根基在于网络编程。Netty是java领域网络编程的佼佼者。而要学好Netty，首先就必须要会NIO编程。本笔记旨在学习NIO的概念、使用及原理，并附带一些代码实现。</p><blockquote><ol><li>NIO三大组件</li><li>文件编程</li><li>阻塞和非阻塞的NIO网络编程</li><li>非阻塞多线程解决方案</li></ol></blockquote><a id="more"></a><h1 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h1><p>NIO：non-blocking io 非阻塞IO。NIO有三大组件：<strong>Channel，Bugger， Selector</strong>。</p><h1 id="三大组件"><a href="#三大组件" class="headerlink" title="三大组件"></a>三大组件</h1><h2 id="Channel-amp-amp-Buffer"><a href="#Channel-amp-amp-Buffer" class="headerlink" title="Channel &amp;&amp; Buffer"></a>Channel &amp;&amp; Buffer</h2><p>Channel相当与一个stream，它就是读写数据的<strong>双向通道</strong>，channel可以把数据写入buffer，也可以把数据从buffer读出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">channel--&gt;buffer</span><br><span class="line">buffer--&gt;channel</span><br></pre></td></tr></table></figure><p>常见的channel和buffer</p><blockquote><ul><li><p>FileChannel</p></li><li><p>DatagramChannel</p></li><li><p>SocketChannel</p></li><li><p>ServerSocketChannel</p></li></ul></blockquote><p>常见的buffer：</p><blockquote><ul><li>ByteBuffer（最常用）<ul><li>MappedByteBuffer</li><li>DirectByteBuffer</li><li>HeapByteBuffer</li></ul></li><li>ShortBuffer</li><li>……</li><li>CharBuffer</li></ul></blockquote><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><p>以下是常用的几种多线程实现：</p><h3 id="多线程版"><a href="#多线程版" class="headerlink" title="多线程版"></a>多线程版</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph 多线程版</span><br><span class="line">thread1--&gt;socket1</span><br><span class="line">thread2--&gt;socket2</span><br><span class="line">thread3--&gt;socket3</span><br><span class="line">end</span><br></pre></td></tr></table></figure><font color="red">**缺点：**</font><ul><li>内存占用高</li><li>线程上下文切换成本高（因为CPU并发线程并没有那么多）</li><li>只适合连接数较小的情况</li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph 线程池版</span><br><span class="line">thread1--&gt;socket1</span><br><span class="line">thread1-.-&gt;socket3</span><br><span class="line">thread2--&gt;socket2</span><br><span class="line">thread2-.-&gt;socket4</span><br><span class="line">end</span><br></pre></td></tr></table></figure><font color="red">**缺点：**</font><ul><li>阻塞模式下，线程仅能处理一个socket连接</li><li>仅适用于短连接的场景</li></ul><h3 id="Selector-1"><a href="#Selector-1" class="headerlink" title="Selector"></a>Selector</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">subgraph Selector版</span><br><span class="line">thread--&gt;selector</span><br><span class="line">selector--&gt;channel1</span><br><span class="line">selector--&gt;channel2</span><br><span class="line">selector--&gt;channel3</span><br><span class="line">end</span><br></pre></td></tr></table></figure><p>Selector的作用就是配合<strong>一个</strong>线程来管理多个channel，获取这些channel上发生的事件，这些channel工作在非阻塞模下，线程不会吊死在一个channel上。适合连接数多，但是流量低的场景（low traffic）。</p><p>调用selector的select()会阻塞，直到channel发生了读写就绪事件，一但这些事件发生，select方法就会赶回这些事件交给thread处理。</p><h1 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h1><p>ByteBuffer可以理解成一个byte数组，然后封装了一些参数和API。</p><h2 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h2><ul><li>position：指针，通过指针位置来进行读写，因此同一个ByteBuffer读写模式下，position位置会不一样。</li><li>limit：可读或可写的最大索引位置。</li><li>capacity：ByteBuffer中数组的容量。</li></ul><h2 id="基本API"><a href="#基本API" class="headerlink" title="基本API"></a>基本API</h2><h3 id="分配"><a href="#分配" class="headerlink" title="分配"></a>分配</h3><ul><li><code>ByteBuffer buff = ByteBuffer.allocate(int capacity)</code>：获取一个<code>ByteBuffer ==&gt; HeapByteBuffer</code>，使用java堆内存<ul><li>读写效率较低</li><li>受垃圾回收影响，会改变内存位置</li></ul></li><li><code>ByteBuffer buff = ByteBuffer.allocateDirect(int capacity)</code><ul><li>直接内存，操作系统内存</li><li>分配效率差</li><li>操作不当容易内存泄漏</li></ul></li></ul><h3 id="读取"><a href="#读取" class="headerlink" title="读取"></a>读取</h3><ul><li><code>byte b = buff.get()</code>：获取缓存中一个字节（pos后移）</li><li><code>buff.get(int idx)</code>：获取指定位置的字节（pos不变）</li><li><code>int writeBytes = channel.write(buff)</code>：从buff中读数据，通过channel写入其他<ul><li>返回读入的字节数（channel一次可能读不完）</li></ul></li></ul><h3 id="写入"><a href="#写入" class="headerlink" title="写入"></a>写入</h3><ul><li><code>buff.put(byte b) || buff.put(byte[] bs)</code>：存入字节或字节数组（pos变化）</li><li><code>int readBytes = channel.read(buff)</code>：把channel中的数据写入buff<ul><li>返回写入的字节数，会受到buff容量的限制</li><li>返回-1表示没有东西可以写了</li></ul></li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><code>buff.flip()</code>：切换读模式（pos变0）</li><li><code>buff.rewind()</code>：读模式下，pos置0，即从头开始读</li><li><code>buff.clear()</code>：切换写模式（pos归零）</li><li><code>buff.compact()</code>：切换写模式（未读内容左移到0，pos变成空白buff的起始位置）</li><li><code>buff.mark()</code>：标记当前pos的位置</li><li><code>buff.reset()</code>：pos回到mark的位置，还是读模式</li><li><code>buff.hasRemaining</code>：buff是否读完</li></ul><h2 id="图解"><a href="#图解" class="headerlink" title="图解"></a>图解</h2><ul><li><code>ByteBuffer buff = ByteBuffer.allocate(int capacity)</code></li></ul><div class="table-container"><table><thead><tr><th>pos</th><th></th><th></th><th></th><th></th><th></th><th>capacity + limit</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><ul><li><code>buff.put(...)</code></li></ul><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th>pos</th><th></th><th></th><th>capacity + limit</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>c</td><td></td><td></td><td></td></tr></tbody></table></div><ul><li><code>buff.flip()</code></li></ul><div class="table-container"><table><thead><tr><th>pos</th><th></th><th></th><th>limit</th><th></th><th></th><th>capacity</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>c</td><td></td><td></td><td></td></tr></tbody></table></div><ul><li><code>buffer.get() * 2</code>：pos改变</li></ul><div class="table-container"><table><thead><tr><th></th><th></th><th>pos</th><th>limit</th><th></th><th></th><th>capacity</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>c</td><td></td><td></td><td></td></tr></tbody></table></div><ul><li><p><code>buffer.get(2)</code>：pos不变</p></li><li><p><code>buffer.compact()</code>：已读部分删除，留下未读</p></li></ul><div class="table-container"><table><thead><tr><th></th><th>pos</th><th></th><th></th><th></th><th></th><th>capacity+limit</th></tr></thead><tbody><tr><td>c</td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><ul><li><code>buffer.clear()</code>：没读，但也清零</li></ul><div class="table-container"><table><thead><tr><th>pos</th><th></th><th></th><th></th><th></th><th></th><th>capacity + limit</th></tr></thead><tbody><tr><td></td><td></td><td></td><td></td><td></td><td></td></tr></tbody></table></div><ul><li><code>buffer.put(new byte[]{&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;})</code></li></ul><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th>pos</th><th></th><th>capacity + limit</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>c</td><td>d</td><td></td><td></td></tr></tbody></table></div><ul><li><code>buffer.flip()</code></li><li><code>buff.get() * 2</code></li><li><code>buff.mark()</code>：记录pos到c的位置</li></ul><div class="table-container"><table><thead><tr><th></th><th></th><th>pos</th><th></th><th>limit</th><th></th><th>capacity</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>c</td><td>d</td><td></td><td></td></tr></tbody></table></div><ul><li><code>buff.get() * 2</code></li></ul><div class="table-container"><table><thead><tr><th></th><th></th><th></th><th></th><th>pos+limit</th><th></th><th>capacity</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>c</td><td>d</td><td></td><td></td></tr></tbody></table></div><ul><li><code>buff.reset()</code>：重置到c，还是读模式</li></ul><div class="table-container"><table><thead><tr><th></th><th></th><th>pos</th><th></th><th>limit</th><th></th><th>capacity</th></tr></thead><tbody><tr><td>a</td><td>b</td><td>c</td><td>d</td><td></td><td></td></tr></tbody></table></div><h2 id="ByteBuffer和字符串互转"><a href="#ByteBuffer和字符串互转" class="headerlink" title="ByteBuffer和字符串互转"></a>ByteBuffer和字符串互转</h2><h3 id="字符串转ByteBuffer"><a href="#字符串转ByteBuffer" class="headerlink" title="字符串转ByteBuffer"></a>字符串转ByteBuffer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. put() ==&gt; 写模式</span></span><br><span class="line">ByteBuffer buff1 = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">buff.put(<span class="string">"hello"</span>.getBytes());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Charset ==&gt; 读模式</span></span><br><span class="line">ByteBuffer buff2 = StandardCharsets.UTF_8.encode(<span class="string">"hello"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. warp === Charset方法 ==&gt; 读模式</span></span><br><span class="line">ByteBuffer buff3 = ByteBuffer.warp(<span class="string">"hello"</span>.getBytes());</span><br></pre></td></tr></table></figure><h3 id="ByteBuffer转字符串"><a href="#ByteBuffer转字符串" class="headerlink" title="ByteBuffer转字符串"></a>ByteBuffer转字符串</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">buff.flip();</span><br><span class="line">StandardCharsets.UTF_8.decode(buff).toString();</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>Charset转字符串是根据pos位置来转的，因此<strong>必须要在读模式</strong>！</p><h2 id="分散读-amp-amp-集中写"><a href="#分散读-amp-amp-集中写" class="headerlink" title="分散读 &amp;&amp; 集中写"></a>分散读 &amp;&amp; 集中写</h2><h3 id="分散读"><a href="#分散读" class="headerlink" title="分散读"></a>分散读</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * data.txt</span></span><br><span class="line"><span class="comment"> * onetwothree</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">try</span>(RandAccessFile file = <span class="keyword">new</span> RandAccessFile(path, <span class="string">"rw"</span>)) &#123;</span><br><span class="line">    FileChannel channel = file.getChannel();</span><br><span class="line">    ByteBuffer b1 = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    ByteBuffer b2 = ByteBuffer.allocate(<span class="number">3</span>);</span><br><span class="line">    ByteBuffer b3 = ByteBuffer.allocate(<span class="number">5</span>);</span><br><span class="line">    channel.read(<span class="keyword">new</span> ByteBuffer[]&#123;b1, b2, b3&#125;);</span><br><span class="line">    b1.flip(); <span class="comment">// one</span></span><br><span class="line">    b2.flip(); <span class="comment">// two</span></span><br><span class="line">    b3.flip(); <span class="comment">// three</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集中写"><a href="#集中写" class="headerlink" title="集中写"></a>集中写</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer b1 = StandardCharsets.UTF_8.encode(<span class="string">"hello"</span>);</span><br><span class="line">ByteBuffer b2 = StandardCharsets.UTF_8.encode(<span class="string">"world"</span>);</span><br><span class="line">ByteBuffer b3 = StandardCharsets.UTF_8.encode(<span class="string">"你好！"</span>);</span><br><span class="line"><span class="keyword">try</span>(FileChannel channel = <span class="keyword">new</span> RandAccessFile(path, <span class="string">"rw"</span>).getChannel()) &#123;</span><br><span class="line">    channel.write(<span class="keyword">new</span> ByteBuffer[]&#123;b1, b2, b3&#125;);</span><br><span class="line">&#125;<span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ByteBuffer小练习"><a href="#ByteBuffer小练习" class="headerlink" title="ByteBuffer小练习"></a>ByteBuffer小练习</h2><h3 id="需求描述（粘包半包）"><a href="#需求描述（粘包半包）" class="headerlink" title="需求描述（粘包半包）"></a>需求描述（粘包半包）</h3><p>多条数据，组合成一条消息发送给服务端，通过<strong>字符c</strong>来进行分割每条数据，服务端可能会接收到多个包（ByteBuffer[]），写一段代码，将每条数据进行打印。</p><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">parseMessage</span><span class="params">(ByteBuffer[] buffers, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> capacity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (ByteBuffer byteBuffer : buffers) capacity += byteBuffer.capacity();</span><br><span class="line">    ByteBuffer source = ByteBuffer.allocate(capacity); <span class="comment">// 用一个source来接受所有的包</span></span><br><span class="line">    <span class="keyword">for</span> (ByteBuffer byteBuffer : buffers) &#123;</span><br><span class="line">        source.put(byteBuffer);</span><br><span class="line">        source.flip();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; source.limit(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="keyword">char</span>) source.get(j) == c) &#123;</span><br><span class="line">                <span class="keyword">int</span> length = j - source.position();</span><br><span class="line">                ByteBuffer targetData = ByteBuffer.allocate(length);</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; length; k++) &#123;</span><br><span class="line">                    targetData.put(source.get()); <span class="comment">// source读，并pos移动位置</span></span><br><span class="line">                &#125;</span><br><span class="line">                source.get(); <span class="comment">// pos跳过分割字符</span></span><br><span class="line">                targetData.flip(); <span class="comment">// 必须切换成读模式</span></span><br><span class="line">                res.add(StandardCharsets.UTF_8.decode(targetData).toString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        source.compact();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="文件编程"><a href="#文件编程" class="headerlink" title="文件编程"></a>文件编程</h1><h2 id="FileChannel"><a href="#FileChannel" class="headerlink" title="FileChannel"></a>FileChannel</h2><p><strong><font color="red">注意：只能工作在阻塞模式下</font></strong></p><h3 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h3><p>不能直接打开FileChannel，必须通过<code>FileInputStream, FileOutputStream</code>或者<code>RandomAccessFile</code>来获取，通过<code>getChannel()</code>方法</p><blockquote><p>FileInputStream获取的Channel只读</p><p>FileOutputStream获取的Channel只写</p><p>RandomAccessFile，可以控制读写权限</p></blockquote><h3 id="读取-1"><a href="#读取-1" class="headerlink" title="读取"></a>读取</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回读到的字节数，如果读到-1，则表示没有内容可读了</span></span><br><span class="line"><span class="keyword">int</span> readBytes = channel.read(byteBuffer);</span><br></pre></td></tr></table></figure><h3 id="写入-1"><a href="#写入-1" class="headerlink" title="写入"></a>写入</h3><p>正确姿势如下：（虽然FileChannel不存在这个问题，但是SocketChannel并不能一次性写入所有数据，存在写能力的上限 ===&gt; 必须用while来判断buffer里面是否还有数据）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer buffer = ...;</span><br><span class="line">buffer,put(...); <span class="comment">// 存输入</span></span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">    channel.write(buffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="关闭"><a href="#关闭" class="headerlink" title="关闭"></a>关闭</h3><p>channel必须关闭，不过调用了<code>FileInputStream, FileOutputStream或者RandomAccessFile</code>的close方法，会间接调用channel的close。<strong>推荐使用twr包裹，自动close。</strong></p><h3 id="位置"><a href="#位置" class="headerlink" title="位置"></a>位置</h3><ul><li>获取当前位置：<code>long pos = channel.potision()</code></li><li>设置当前位置：<code>channel.position(int newPos)</code><ul><li>如果新位置设置在文件末尾，读取会返回-1</li><li>写入会进行追加，如果position超过了文件末尾，再写入新的内容和原末尾之间会有空值（00）</li></ul></li></ul><h3 id="大小"><a href="#大小" class="headerlink" title="大小"></a>大小</h3><p>使用<code>size()</code>可以 获得文件的大小</p><h3 id="强制写入"><a href="#强制写入" class="headerlink" title="强制写入"></a>强制写入</h3><p>操作系统出于性能的考虑，会将数据缓存，不是立刻写入磁盘。可以调用<code>force(true)</code>方法将文件内容和原数据（文件的权限等）立刻写入磁盘。</p><h3 id="两个FileChannel之间传输数据"><a href="#两个FileChannel之间传输数据" class="headerlink" title="两个FileChannel之间传输数据"></a><font color="red">两个FileChannel之间传输数据</font></h3><ul><li><code>transferTo</code>:返回实际传输的字节数，一次最多只能传输2GB，但效率非常高</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (</span><br><span class="line">    FileChannel from = <span class="keyword">new</span> FileInputstream(path).getChannel();</span><br><span class="line">    FileChannel to = <span class="keyword">new</span> FileOutputStream(path).getChannel();</span><br><span class="line">) &#123;</span><br><span class="line">    <span class="comment">// 效率高，底层使用了操作系统的零拷贝进行了优化</span></span><br><span class="line">    <span class="keyword">long</span> size = from.size();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">long</span> left = size; left &gt; <span class="number">0</span>;) &#123;</span><br><span class="line">      left -= from.transferTo((size - left), left, to);  </span><br><span class="line">    &#125;</span><br><span class="line">    from.transferTo(<span class="number">0</span>, from.size(), to);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h2><p>JDK7引入的Path和Paths</p><ul><li>Path表示文件路径</li><li>Paths是工具类，用来获取Path实例</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Path source = Paths.get(<span class="string">"cxy.txt"</span>);</span><br><span class="line">Path source = Paths.get(<span class="string">"d:\\cxy.txt"</span>);</span><br><span class="line">Path source = Paths.get(<span class="string">"d:/cxy.txt"</span>);</span><br><span class="line">Path source = Paths.get(<span class="string">"d:\\data"</span>, <span class="string">"cxy.txt"</span>);</span><br></pre></td></tr></table></figure><ul><li>支持：<code>./</code>和<code>../</code>来表示文件层级</li><li><code>path.normaliaze()</code>可以把文件路径格式化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Path source = Paths.get(<span class="string">"d:/data/test/../cxy.txt"</span>);</span><br><span class="line">print(source); <span class="comment">// d:/data/test/../cxy.txt</span></span><br><span class="line">print(source.nomalize()) <span class="comment">// d:/data/cxy.txt</span></span><br></pre></td></tr></table></figure><h2 id="Files"><a href="#Files" class="headerlink" title="Files"></a>Files</h2><p>JDK7引入</p><h3 id="基础API"><a href="#基础API" class="headerlink" title="基础API"></a>基础API</h3><ul><li>检查文件是否存在：<code>Files.exists(Path path)</code></li><li>创建一级目录：<code>Files.createDirectory(Path path)</code><ul><li>如果目录已经存在，会抛异常</li><li>不能创建多级</li></ul></li><li>创建多级目录：<code>Files.createDirectories(Path path)</code></li><li><strong>拷贝文件</strong>：<code>Files.copy(Path source, Path target)</code><ul><li>如果文件已经存在，会报异常</li><li>如果要覆盖原文件: <code>Files.copy(source, target, StrandardCopyoption.REPLACE_EXISITING)</code></li><li>和<code>transforTo</code>性能差不多</li></ul></li><li>移动文件：<code>Files.move(Path source, Path target, StandardCopyOption.ATOMIC_MOVE)</code><ul><li>保证原子性</li></ul></li><li>删除文件：<code>Files.delete(Path target)</code><ul><li>文件不存在，会抛异常</li></ul></li><li>删除目录：<code>Files.delete(Path target)</code><ul><li>如果目录内有文件，会抛异常，无法删除</li><li>需要先删文件再删目录</li></ul></li></ul><h3 id="进阶API"><a href="#进阶API" class="headerlink" title="进阶API"></a>进阶API</h3><p><strong>遍历文件夹：<code>Files.walkFileTree(Path start, FileVisitor&lt;? super Path&gt; visitor)</code></strong></p><ul><li><code>FileVisitor</code>是一个接口，有4个方法，一般用<code>new SimpleFileVisitor&lt;Path&gt;</code>来写（可以不用全部实现，重写就行）<ul><li><code>preVisitDirectory</code>：进入文件夹前触发</li><li><code>postVisitDirectory</code>：离开文件夹前触发</li><li><code>visitFile</code>：访问文件时触发</li><li><code>visitFileFailed</code>：访问文件失败时触发</li></ul></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单用法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger fileCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger directorCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    Files.walkFileTree(Paths.get(<span class="string">"/Users/memoforward/Blog/MemoForward"</span>), <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">preVisitDirectory</span><span class="params">(Path dir, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            directorCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.preVisitDirectory(dir, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            fileCount.incrementAndGet();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(<span class="string">"files: "</span> + fileCount.get());</span><br><span class="line">    System.out.println(<span class="string">"directors: "</span> + directorCount.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="需求1：如何删除多级目录？"><a href="#需求1：如何删除多级目录？" class="headerlink" title="需求1：如何删除多级目录？"></a>需求1：如何删除多级目录？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Files.walkFileTree(Paths.get(<span class="string">"~"</span>), <span class="keyword">new</span> SimpleFileVisitor&lt;Path&gt;()&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">visitFile</span><span class="params">(Path file, BasicFileAttributes attrs)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Files.delete(file);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.visitFile(file, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> FileVisitResult <span class="title">postVisitDirectory</span><span class="params">(Path dir, IOException exc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            Files.delete(dir);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.postVisitDirectory(dir, exc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Walk"><a href="#Walk" class="headerlink" title="Walk"></a>Walk</h4><p>返回一个stream流。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Files.walk(Paths.get(<span class="string">"~"</span>)).forEach(path -&gt; &#123;</span><br><span class="line">    String targetName = path.toString().replace(source, target);</span><br><span class="line">    <span class="keyword">if</span> (Files.isDirectory()) &#123;</span><br><span class="line">        Files.createDirectories(Paths.get(tartetName));</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(Files.isRegularFile(path)) &#123;</span><br><span class="line">        Files.copy(path, Paths.get(targetName));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;...&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a><font color="red">网络编程</font></h1><h2 id="阻塞式（NIO实现）"><a href="#阻塞式（NIO实现）" class="headerlink" title="阻塞式（NIO实现）"></a>阻塞式（NIO实现）</h2><p>单线程处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//0. ByteBuffer</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 1. 创建了服务器</span></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8888</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. accept建立与客户端的连接，SocketChannel用来与客户端之间通信</span></span><br><span class="line">        SocketChannel sc = ssc.accept();</span><br><span class="line">        channels.add(sc);</span><br><span class="line">        <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">            channel.read(buffer);</span><br><span class="line">            buffer.flip();</span><br><span class="line">            <span class="comment">// 4. 逻辑处理</span></span><br><span class="line">            <span class="comment">// ....</span></span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>以上代码，<strong>有两处地方阻塞</strong>：<code>accept()和read()。</code></p><ul><li><code>accept()</code>：等待客户端连接而导致的阻塞（没有线程连接就阻塞）</li><li><code>read()</code>：等待客户端写入数据而导致的阻塞（没有数据写入就阻塞）</li></ul><p>这就导致了：单线程处理连接，如果同时有两个线程进行连接和写入，不同线程的<code>accpet()</code>和<code>read()</code>会相互阻塞，如果一个客户端连接后，一直不写，这个线程就永远无法与其他客户端连接。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p><strong>阻塞式单线程处理，无法进行处理多个连接的情况。</strong></p><h2 id="非阻塞式（NIO-Channel实现）"><a href="#非阻塞式（NIO-Channel实现）" class="headerlink" title="非阻塞式（NIO Channel实现）"></a>非阻塞式（NIO Channel实现）</h2><p><strong>单线程处理：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将服务端的channel设置成非阻塞模式</span></span><br><span class="line">ssc.configureBlocking(<span class="keyword">false</span>); </span><br><span class="line"><span class="comment">// 将与客户端通信的SocketChannel也设置成非阻塞</span></span><br><span class="line">ssc.configureBlocking(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p><strong>改进版本：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//0. ByteBuffer</span></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    <span class="comment">// 1. 创建了服务器</span></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 非阻塞模式</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 绑定监听端口</span></span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8889</span>));</span><br><span class="line"></span><br><span class="line">    List&lt;SocketChannel&gt; channels = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. accept建立与客户端的连接，SocketChannel用来与客户端之间通信</span></span><br><span class="line">        SocketChannel sc = ssc.accept();</span><br><span class="line">        <span class="keyword">if</span> (sc != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            channels.add(sc);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (SocketChannel channel : channels) &#123;</span><br><span class="line">            <span class="keyword">int</span> read = channel.read(buffer); <span class="comment">// 没有读到数据，返回0</span></span><br><span class="line">            <span class="keyword">if</span>(read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="comment">// 4. 逻辑处理</span></span><br><span class="line">                <span class="comment">// ....</span></span><br><span class="line">                buffer.clear();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="问题-1"><a href="#问题-1" class="headerlink" title="问题"></a>问题</h3><ul><li>非阻塞模式可以让线程不阻塞，<strong><font color="red">但很消耗资源</font></strong>，相当于线程一直空转</li></ul><h2 id="非阻塞式改进（Selector）"><a href="#非阻塞式改进（Selector）" class="headerlink" title="非阻塞式改进（Selector）"></a>非阻塞式改进（Selector）</h2><p>由<code>Selector</code>监听事件，没事件就阻塞，有事件就分配线程去运行。提高线程使用效率。</p><h3 id="Selector-2"><a href="#Selector-2" class="headerlink" title="Selector"></a>Selector</h3><ul><li>创建：<code>Selector sel = Selector.open()</code></li><li>channel注册：<code>Selectionkey selectorKey = channel.register(sel, int ops, Object attention)</code><ul><li><code>sel</code>：绑定的Selector</li><li><code>ops</code>：绑定的事件<code>(SelectionKey.XXXX)</code><ul><li>0：不关注任何事件</li><li>accept：服务端事件，有连接请求时产生的事件<code>(SelectionKey.OP_ACCEPT)</code></li><li>connect：客户端事件，连接建立后产生的事件<code>(SelectionKey.OP_CONNECT)</code></li><li>read：服务端事件，读事件<code>(SelectionKey.OP_READ)</code></li><li>write：客户端时间，写事件<code>(SelectionKey.OP_WRITE)</code></li><li>可以用两个事件的值相加来绑定多个事件<code>(SelectionKey.OP_ACCEPT + SelectionKey.OP_READ)</code></li></ul></li><li><code>SelectorKey</code>：channel和selector绑定的关系具象，可以通过key获得对应的channel和绑定的事件</li><li><code>attention</code>：绑定在SelectorKey上的对象，用来做拓展用</li></ul></li><li>也可以手动绑定事件：<code>selectionKey.interestOps(SelectionKey.OP_ACCEPT)</code></li><li>开启监听：<code>sel.select()</code> —&gt;没事件是阻塞的</li></ul><h3 id="SelectedKeys"><a href="#SelectedKeys" class="headerlink" title="SelectedKeys"></a>SelectedKeys</h3><blockquote><p>概念：Selector里的keys集合，用来实时处理事件</p></blockquote><p>如果有事件发生，Selector就会把事件放到SelectedKeys集合里面，我们可以通过key来获取事件，并针对事件做出相应的逻辑处理。</p><p>事件处理后，理论上需要把事件移出集合（不移除，每次SelectedKeys都会遍历到这个过期事件），但是Selector仅做了<strong>逻辑删除</strong>，所以我们最好要手动移除，而在遍历集合中要做到移除元素，<strong>需要用迭代器。</strong></p><h3 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a><strong>简单实现</strong></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Selector，管理多个channel</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将channel注册到selector</span></span><br><span class="line">    <span class="comment">// SelectionKey是事件发生后，可以知道对应channel发生的具体事件</span></span><br><span class="line">    SelectionKey selectionKey = ssc.register(selector, SelectionKey.OP_ACCEPT, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// selectionKey.interestOps(SelectionKey.OP_READ);</span></span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8787</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. select方法，没有事件发生，线程阻塞，有事件，线程才会恢复运行</span></span><br><span class="line">        selector.select();</span><br><span class="line">        <span class="comment">// 4. 处理事件, keys里面包含了所有的事件</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            SelectionKey key = iterator.next();</span><br><span class="line">            ServerSocketChannel channel = (ServerSocketChannel)key.channel();</span><br><span class="line">            SocketChannel sc = channel.accept();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>事件发生，必须要处理，如果不处理，集合内的事件甚至不会被逻辑删除，这就导致select永远不会阻塞，消耗cpu资源。</p><ul><li>调用<code>key.cancel()</code>方法，会把key<strong>逻辑删除，导致不监听任何方法（除非重新注册，可以理解成物理删除）</strong>，如果不处理，或发生异常来不及处理，就一定要<code>cancel</code>。</li></ul><p><strong><font color="red">问题:  </font> 好像也只是单线程处理一个事件，如何根据不同的channel执行不同的事件呢？</strong></p><ul><li>给accept获得的channel也注册到selector中</li><li><strong>SelectedKey可以识别自身发生的事件类型</strong><ul><li><code>key.isAcceptable()</code></li><li><code>key.isReadable()</code></li><li>…..</li></ul></li></ul><h3 id="改进版本一"><a href="#改进版本一" class="headerlink" title="改进版本一"></a>改进版本一</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 创建Selector，管理多个channel</span></span><br><span class="line">    Selector selector = Selector.open();</span><br><span class="line"></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">    ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将channel注册到selector</span></span><br><span class="line">    <span class="comment">// SelectionKey是事件发生后，可以知道对应channel发生的具体事件</span></span><br><span class="line">    SelectionKey selectionKey = ssc.register(selector, SelectionKey.OP_ACCEPT, <span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// selectionKey.interestOps(SelectionKey.OP_READ);</span></span><br><span class="line">    ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8787</span>));</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 3. select方法，没有事件发生，线程阻塞，有事件，线程才会恢复运行</span></span><br><span class="line">        selector.select();</span><br><span class="line">        <span class="comment">// 4. 处理事件, keys里面包含了所有的事件</span></span><br><span class="line">        Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">            SelectionKey key = iterator.next();</span><br><span class="line">            <span class="comment">// iterator.remove(); 从集合中移除key</span></span><br><span class="line">            <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                ServerSocketChannel channel = (ServerSocketChannel)key.channel();</span><br><span class="line">                SocketChannel sc = channel.accept();</span><br><span class="line">                sc.register(selector, SelectionKey.OP_READ, <span class="keyword">null</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">                SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                sc.read(buffer);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                <span class="comment">// ...业务逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red"><strong>问题：</strong></font><strong>这个代码有一个不明显的问题</strong>，就是上文提到的remove机制。</p><ul><li>==<strong>前提知识</strong>==：selector中会有两个集合，一个是注册的channel集合（包含了channel和监听的事件类型，这个集合就是用来阻塞监听的），另一个是selectedKeys集合。当有事件发生时，selector会从channel集合中把对应的元素拿出来放到selectedKeys集合中，供用户处理，也就是说，<strong>这两个集合放的元素都是一样，都是key，而且一个key包含了channel + 事件。</strong><ul><li><strong>Set\<SelectedKey> publicKeys:  </SelectedKey></strong>注册进来的key</li><li><strong>Set\<SelectionKey> publicSelectedKeys: </SelectionKey></strong>事件发生后，加入的key</li></ul></li><li>问题原因：事件处理后，selectedKeys里面仅做了逻辑删除（具体源码未知），这个删除不会让select()监测到。</li><li>问题复现：虽然逻辑删除的事件不会取消select()的阻塞，但是会在遍历集合的时候遍历到这个channel，而且<code>isAcceptable()</code>同样也会被触发，因此当其他事件触发时，ssc又会去accept一个channel，但这个channel是null，因此会导致空指针异常。</li><li>问题解决：将以上代码的注释放开就行，手动remove。</li><li>复盘：这个更像是NIO的一个bug。</li></ul><h3 id="改进版本二"><a href="#改进版本二" class="headerlink" title="改进版本二"></a>改进版本二</h3><p>上述代码有两个问题：</p><ul><li>客户端异常关闭，会导致一个read事件。</li><li>客户端正常关闭，也会导致一个read事件。</li><li>read事件不会得到处理（因为这个channel没法read了），会导致selectedKeys集合每次循环都会增加这个事件，因为<code>publicKeys</code>里面这个事件未被处理，(所以remove了也没用，因为remove是selectedKeys集合里面的内容）。</li></ul><p>解决：</p><ul><li>用catch捕获异常，并且在异常中cancel。</li><li>如果<code>channel.read() == -1, 则</code>cancel`。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">16</span>);</span><br><span class="line">        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">int</span> read = sc.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (read == -<span class="number">1</span>) key.cancel();</span><br><span class="line">        buffer.flip();</span><br><span class="line">        <span class="comment">// ...业务逻辑</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        key.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>复盘：这个也像是NIO的一个bug。</p><h2 id="消息边界问题"><a href="#消息边界问题" class="headerlink" title="消息边界问题"></a>消息边界问题</h2><p>NIO处理黏包半包问题。</p><p><img src="/2022/07/15/NIO%E5%9F%BA%E7%A1%80/NIO消息边界.png" alt></p><p><strong>解决思路：</strong></p><ol><li>约定Buffer容量，缺点是浪费资源</li><li>定义包间分割符号，利用符号进行包的提取，缺点是拆包效率低</li><li>约定一个报文头，表明后面的消息长度【[4byte][xxxx]】。TLV模式，Type + Length + Value。根据解析的结果分配Buffer，缺点是buffer需要提前分配，如果内容过大，影响server吞吐。<ul><li>HTTP1.1是TLV格式</li><li>HTTP2.0 是LTV格式 </li></ul></li></ol><p>第二种方法的实现就是前面的小练习的增强版。</p><ul><li>得用channel绑定的自己的ByteBuffer（不能共用ByteBuffer，不然会有线程安全问题）</li><li><p>ByteBuffer不够，需要有措施</p><ul><li>扩容。缺点是扩容时拷贝会浪费性能，优点是消息是连续处理的。</li><li>用数组绑定channel，不够就加新建一个ByteBuffer加进数组。缺点是消息存储不连续，解析 复杂。</li></ul><p>这里引入了channel注册的另一个参数：<code>attachment</code>，表示和channel绑定的一个对象，可以通过key获取。</p></li></ul><p><strong>实现（使用扩容）：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    sc.register(selector, SelectionKey.OP_READ, ByteBuffer.allocate(<span class="number">4</span>));</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ByteBuffer buffer = (ByteBuffer)key.attachment();</span><br><span class="line">        SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">int</span> read = sc.read(buffer);</span><br><span class="line">        <span class="keyword">if</span> (read == -<span class="number">1</span>) key.cancel();</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            split(buffer, <span class="string">'\n'</span>);</span><br><span class="line">            <span class="comment">// buffer满</span></span><br><span class="line">            <span class="keyword">if</span> (buffer.limit() == buffer.position())&#123;</span><br><span class="line">                <span class="comment">// 扩容</span></span><br><span class="line">                ByteBuffer newBuffer = ByteBuffer.allocate(buffer.capacity() * <span class="number">2</span>);</span><br><span class="line">                buffer.flip();</span><br><span class="line">                newBuffer.put(buffer); <span class="comment">// 注意此时newBuffer的pos在正确的位置</span></span><br><span class="line">                key.attach(newBuffer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">split</span><span class="params">(ByteBuffer source, <span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    source.flip();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; source.limit(); j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((<span class="keyword">char</span>) source.get(j) == c) &#123;</span><br><span class="line">            <span class="keyword">int</span> length = j - source.position();</span><br><span class="line">            ByteBuffer targetData = ByteBuffer.allocate(length);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; length; k++) &#123;</span><br><span class="line">                targetData.put(source.get()); <span class="comment">// source读，并pos移动位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            source.get(); <span class="comment">// pos跳过分割字符</span></span><br><span class="line">            targetData.flip(); <span class="comment">// 必须切换成读模式</span></span><br><span class="line">            <span class="comment">// 对target逻辑处理</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    source.compact();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="处理写事件"><a href="#处理写事件" class="headerlink" title="处理写事件"></a>处理写事件</h2><p>写事件的监听不太好理解，这里单独用一个样例表示。</p><ul><li>服务端：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 注意阻塞模式下，write会一次性写完所有数据</span></span><br><span class="line">                    <span class="comment">// 给客户端传递大量数据</span></span><br><span class="line">                    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; <span class="number">3000000</span>; i++) sb.append(<span class="string">"a"</span>);</span><br><span class="line">                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="keyword">while</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        <span class="keyword">int</span> write = sc.write(buffer); <span class="comment">// 返回每次写多少</span></span><br><span class="line">                        System.out.println(write);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console log:</span><br><span class="line"><span class="number">261676</span></span><br><span class="line"><span class="number">998124</span></span><br><span class="line"><span class="number">1521840</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">73728</span></span><br><span class="line"><span class="number">144632</span></span><br></pre></td></tr></table></figure><ul><li>客户端</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriteClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        SocketChannel sc = SocketChannel.open();</span><br><span class="line">        sc.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>, <span class="number">8080</span>));</span><br><span class="line">        <span class="comment">// 接受数据</span></span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            ByteBuffer buffer = ByteBuffer.allocate(<span class="number">1024</span> * <span class="number">1024</span>);</span><br><span class="line">            count += sc.read(buffer);</span><br><span class="line">            System.out.println(count);</span><br><span class="line">            buffer.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Console log:</span><br><span class="line"><span class="number">130656</span></span><br><span class="line"><span class="number">1161444</span></span><br><span class="line"><span class="number">2200476</span></span><br><span class="line"><span class="number">3000000</span></span><br></pre></td></tr></table></figure><ul><li>问题</li></ul><p>我们会发现，在非阻塞模式下， 一次写不完的数据会分多次写入，但是，在while循环里，如果buffer里的数据没有被完全传递（buffer满着），就会write一个0，这不合理，我们想把写0的时候，释放线程。</p><ul><li>改进服务端（触发写事件，buffer空了再去写）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WriterServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Selector selector = Selector.open();</span><br><span class="line">        ssc.register(selector, SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            selector.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                <span class="keyword">if</span> (key.isAcceptable()) &#123;</span><br><span class="line">                    SocketChannel sc = ssc.accept();</span><br><span class="line">                    sc.configureBlocking(<span class="keyword">false</span>); <span class="comment">// 注意阻塞模式下，write会一次性写完所有数据</span></span><br><span class="line">                    SelectionKey scKey = sc.register(selector, SelectionKey.OP_READ);</span><br><span class="line">                    <span class="comment">// 给客户端传递大量数据</span></span><br><span class="line">                    StringBuffer sb = <span class="keyword">new</span> StringBuffer();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3000000</span>; i++) sb.append(<span class="string">"a"</span>);</span><br><span class="line">                    ByteBuffer buffer = Charset.defaultCharset().encode(sb.toString());</span><br><span class="line">                    <span class="keyword">if</span> (buffer.hasRemaining()) &#123;</span><br><span class="line">                        scKey.interestOps(scKey.interestOps() | SelectionKey.OP_WRITE); <span class="comment">// 添加事件</span></span><br><span class="line">                        scKey.attach(buffer); <span class="comment">// 将buffer挂上</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (key.isWritable()) &#123;</span><br><span class="line">                    ByteBuffer buffer = (ByteBuffer) key.attachment();</span><br><span class="line">                    SocketChannel sc = (SocketChannel) key.channel();</span><br><span class="line">                    <span class="keyword">int</span> write = sc.write(buffer);</span><br><span class="line">                    System.out.println(write);</span><br><span class="line">                    <span class="keyword">if</span> (!buffer.hasRemaining()) &#123;</span><br><span class="line">                        key.attach(<span class="keyword">null</span>); <span class="comment">// 清理</span></span><br><span class="line">                        key.interestOps(key.interestOps() - SelectionKey.OP_WRITE); <span class="comment">// 取消关注</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>阻塞模式下，<code>accept</code>和<code>read</code>会阻塞线程，线程阻塞不会占用cpu资源，是闲置的</li><li>非阻塞模式下，使用Selector实现多路复用，一个线程处理多个事件<ul><li>selector无法绑定FileChannel</li></ul></li><li><p><code>select()</code>方法是一直阻塞的，返回可触发事件的次数</p><ul><li><code>int count = select(long time)</code>: 设置超时</li><li><code>int count = selectNow()</code>: 不阻塞，返回可触发事件的次数</li></ul></li><li><p><strong>select何时不阻塞？</strong></p><ul><li>事件发生<ul><li>客户端发起连接请求，触发accept事件</li><li>客户端发送数据、客户端异常关闭、客户端正常关闭，都会触发read事件，如果发送数据大于buffer缓冲区，会触发多次read</li><li>channel可写，会触发写事件（基本都可写，所以要监听的时候打开，写完了就移除）</li><li>linux下nio bug</li></ul></li><li>调用<code>selector.wakeup()</code></li><li>调用<code>selector.close()</code></li><li>selector所在线程interrupt</li></ul></li></ul><h1 id="多线程优化"><a href="#多线程优化" class="headerlink" title="多线程优化"></a>多线程优化</h1><p>一个线程处理多个channel，没法释放cpu所有的核心，也没有办法进行业务区分。</p><p>解决方法：分两组选择器。</p><ul><li>单线程配一个选择器（boss），专门处理accpet事件</li><li>创建cpu核数的selector，轮流处理read</li></ul><h2 id="单Worker"><a href="#单Worker" class="headerlink" title="单Worker"></a>单Worker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Thread.currentThread().setName(<span class="string">"boss"</span>);</span><br><span class="line">        ServerSocketChannel ssc = ServerSocketChannel.open();</span><br><span class="line">        ssc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">        Selector boss = Selector.open();</span><br><span class="line">        ssc.register(boss, SelectionKey.OP_ACCEPT);</span><br><span class="line">        ssc.bind(<span class="keyword">new</span> InetSocketAddress(<span class="number">8080</span>));</span><br><span class="line">        Worker worker = <span class="keyword">new</span> Worker(<span class="string">"worker-0"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">            boss.select();</span><br><span class="line">            Iterator&lt;SelectionKey&gt; iterator = boss.selectedKeys().iterator();</span><br><span class="line">            <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                SelectionKey key = iterator.next();</span><br><span class="line">                iterator.remove();</span><br><span class="line">                ServerSocketChannel channel = (ServerSocketChannel)key.channel();</span><br><span class="line">                SocketChannel sc = channel.accept();</span><br><span class="line">                sc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">                <span class="comment">// 关联selector</span></span><br><span class="line">                worker.register(sc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Thread thread;</span><br><span class="line">        <span class="keyword">private</span> Selector selector;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> start = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 保证线程执行顺序，非常巧妙</span></span><br><span class="line">        <span class="keyword">private</span> ConcurrentLinkedQueue&lt;Runnable&gt; queue = <span class="keyword">new</span> ConcurrentLinkedQueue&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Worker</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化任线程和selector</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(SocketChannel sc)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!start) &#123;</span><br><span class="line">                <span class="keyword">this</span>.thread = <span class="keyword">new</span> Thread(<span class="keyword">this</span>, name);</span><br><span class="line">                <span class="keyword">this</span>.selector = Selector.open();</span><br><span class="line">                thread.start();</span><br><span class="line">                start = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 注册需要selector是非阻塞状态</span></span><br><span class="line">            queue.add(() -&gt; &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    sc.register(selector, SelectionKey.OP_WRITE);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClosedChannelException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            selector.wakeup(); <span class="comment">// 不阻塞时也可以wakeup，下次循环时触发这次的wakeup</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    selector.select();</span><br><span class="line">                    Runnable task = queue.poll();</span><br><span class="line">                    <span class="keyword">if</span> (task != <span class="keyword">null</span>) task.run(); <span class="comment">// 让注册channel放入worker线程一起执行，一定等待阻塞，所以要手动唤醒</span></span><br><span class="line">                    Iterator&lt;SelectionKey&gt; iterator = selector.selectedKeys().iterator();</span><br><span class="line">                    <span class="keyword">while</span> (iterator.hasNext()) &#123;</span><br><span class="line">                        SelectionKey key = iterator.next();</span><br><span class="line">                        iterator.remove();</span><br><span class="line">                        <span class="keyword">if</span> (key.isReadable()) &#123;</span><br><span class="line">                            SocketChannel channel = (SocketChannel) key.channel();</span><br><span class="line">                            <span class="comment">// ....逻辑处理</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                 e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="多worker"><a href="#多worker" class="headerlink" title="多worker"></a>多worker</h2><p>轮询</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 申领Workers */</span></span><br><span class="line"><span class="comment">// 获取cpu核心线程数</span></span><br><span class="line"><span class="comment">// 如果程序运行在docker中，会获取到物理机上核心数量，jdk10才修复</span></span><br><span class="line"><span class="comment">// 所以尽量手动计算，参考阿姆达定律来设置，一般要大于CPU核心数</span></span><br><span class="line">Worker[] workers = <span class="keyword">new</span> Worker[Runtime.getRuntime().availableProcessors()];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; workers.length; i++) &#123;</span><br><span class="line">    workers[i] = <span class="keyword">new</span> Worker(<span class="string">"worker-"</span> + i);</span><br><span class="line">&#125;</span><br><span class="line">AtomicInteger workIdx = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册 */</span></span><br><span class="line">workers[workIdx.getAndIncrement() % workers.length].register(sc);</span><br></pre></td></tr></table></figure><h1 id="概念解析"><a href="#概念解析" class="headerlink" title="概念解析"></a>概念解析</h1><h2 id="NIO-vs-BIO"><a href="#NIO-vs-BIO" class="headerlink" title="NIO vs BIO"></a>NIO vs BIO</h2><h3 id="stream和channel"><a href="#stream和channel" class="headerlink" title="stream和channel"></a>stream和channel</h3><ul><li>stream不会自动缓冲数据，channel会利用系统提供的发送缓冲区，接受缓冲区（更为底层）</li><li>stream仅支持阻塞API，channel同时支持阻塞和非阻塞，网络channel可以通过Selector实现多路复用</li><li>二者都是全双工的，读写可以同时</li></ul><h2 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h2><p>同步阻塞，同步非阻塞，多路复用，异步阻塞（不存在），异步非阻塞。建议参考书籍《UNIX网络编程》。</p><p>当调用一次channel.read或stream.read中，会切换值操作系统内核态来完成真正的数据读取，而读取又分为两个阶段：</p><ul><li>等待数据</li><li>复制数据（从网卡读，复制到内存）</li></ul><p>然后在切换回用户态。</p><ul><li>阻塞IO：用户线程会等待操作系统操作，一直阻塞</li><li>非阻塞IO：用户线程在等待数据时不阻塞，等复制数据时才会阻塞</li><li>多路复用：用一个线程在等待数据时阻塞，<strong>等复制数据时</strong>来处理，乍一看和阻塞IO一样，但是这个线程可以处理多个channel，这些channel都在复制数据时才会处理，理论上不是纯串行的，更加高效</li></ul><h3 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h3><ul><li>同步：线程自己去获取结果（一个线程）</li><li>异步：线程自己不去获取结果，而是由其他线程送结果（至少两个线程）</li></ul><p>上述讲的三种IO模型分别是：同步阻塞，同步非阻塞，（同步）多路复用。</p><p>上面的例子worker就是异步的，但是一般异步需要指定回调方法来处理异步结果。</p><p>异步不可能阻塞，一定是非阻塞的。</p><h3 id="异步模式（AIO）"><a href="#异步模式（AIO）" class="headerlink" title="异步模式（AIO）"></a>异步模式（AIO）</h3><p>AIO用来解决数据复制阶段的阻塞问题。</p><p>异步模型需要操作系统提供支持。这里不举例啦。有空上网找找。</p><h2 id="零拷贝"><a href="#零拷贝" class="headerlink" title="零拷贝"></a>零拷贝</h2><h3 id="传统拷贝"><a href="#传统拷贝" class="headerlink" title="传统拷贝"></a>传统拷贝</h3><p>实现一个文件读，像socket写，内部流程如下：</p><p><img src="/2022/07/15/NIO%E5%9F%BA%E7%A1%80/文件复制.png" alt></p><ol><li><p>java本身不具备IO读写的能力，因此read调用后，会从<strong>用户态切换成内核态</strong>，去调用操作系统（kernel）的读能力，将数据读入<strong>内核缓冲区</strong>。这个期间，用户的线程是阻塞的，操作系统使用DMA（Direct Memory Access）进行文件读，期间不会使用cpu。</p><blockquote><p>DMA理解成硬件单元，用来解放cpu完成IO</p></blockquote></li><li><p>从<strong>内核态</strong>切换成<strong>用户态</strong>，将数据从<strong>内核缓冲区</strong>读入<strong>用户缓冲区（即byte[]）</strong>，这期间cpu会参与拷贝，无法利用DMA</p></li><li>调用write方法，这时候将数据从缓冲区（byte[]）写入socket缓冲区，cpu会参与拷贝</li><li>将<strong>socket缓冲区</strong>写入网卡，这意味着又要从<strong>用户态切换为内核态</strong>，使用DMA，cpu不参与。</li></ol><p>可以看到中间环节比较多，java的IO实际不是物理设备级别的读写，而是缓存的复制，底层的读写是操作系统完成的。</p><ul><li>用户态和内核态切换了3次，很重量级</li><li>参与了4次数据拷贝</li></ul><h3 id="NIO优化"><a href="#NIO优化" class="headerlink" title="NIO优化"></a>NIO优化</h3><p>使用<code>DirectByteBuffer</code>，将用户缓冲区和内核缓冲区合二为一。</p><p><img src="/2022/07/15/NIO%E5%9F%BA%E7%A1%80/NIO复制优化.png" alt></p><p>可以看到，避免了一次数据拷贝。</p><ul><li>3次用户态和内核态的切换</li><li>3次数据拷贝</li></ul><h3 id="零拷贝优化"><a href="#零拷贝优化" class="headerlink" title="零拷贝优化"></a>零拷贝优化</h3><p>通过<code>tansferTo</code>，进行零拷贝，使用操作系统内存。</p><p><img src="/2022/07/15/NIO%E5%9F%BA%E7%A1%80/零拷贝优化.png" alt></p><p>可以看到，不通过内核缓冲区了，这就避免了两次次内核切换和两次数据复制。</p><ul><li>整个复制过程中，只有一次用户态和内核态的切换</li><li>参与了2次数据拷贝</li><li>适合小文件的传输</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;目前互联网环境下，分布式系统十分重要，而分布式的根基在于网络编程。Netty是java领域网络编程的佼佼者。而要学好Netty，首先就必须要会NIO编程。本笔记旨在学习NIO的概念、使用及原理，并附带一些代码实现。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;NIO三大组件&lt;/li&gt;
&lt;li&gt;文件编程&lt;/li&gt;
&lt;li&gt;阻塞和非阻塞的NIO网络编程&lt;/li&gt;
&lt;li&gt;非阻塞多线程解决方案&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="网络编程" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="NIO" scheme="http://yoursite.com/tags/NIO/"/>
    
  </entry>
  
  <entry>
    <title>Kafka自整理学习笔记</title>
    <link href="http://yoursite.com/2022/01/01/Kafka%E8%87%AA%E6%95%B4%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2022/01/01/Kafka%E8%87%AA%E6%95%B4%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-01-01T03:30:14.000Z</published>
    <updated>2022-11-14T13:38:53.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><ol><li><p>本博客整理了一些Kafka的基本概念和使用</p></li><li><p>自己用来当笔记的，故不需要图帮助理解</p></li><li>只有Java端的使用，C++端的以后可能会补上</li></ol></blockquote><a id="more"></a><h1 id="1-事件流"><a href="#1-事件流" class="headerlink" title="1. 事件流"></a>1. 事件流</h1><p>事件流的三个特征：数据格式+持续性的流+分发。</p><ul><li>实时从事件源读取事件流</li><li>数据持久化存储和恢复</li><li>实时或者异步处理和响应流数据</li><li>将数据流路由到不同的目的地</li></ul><h1 id="2-Kafka"><a href="#2-Kafka" class="headerlink" title="2. Kafka"></a>2. Kafka</h1><p>Kafka是一个数据流平台，其具有三个能力：</p><ol><li>发布和订阅事件流，可以持续地从其他系统导入和导出data</li><li>持久可靠地存储事件流</li><li>可以同步和异步化处理事件流</li></ol><p>以上的功能Kafka都能以<strong>分布式、高度可拓展、高容错、高安全</strong>的方式提供。</p><h1 id="3-Kafka如何工作"><a href="#3-Kafka如何工作" class="headerlink" title="3. Kafka如何工作"></a>3. Kafka如何工作</h1><p>Server和Clients通过高性能的TCP网络来进行通讯。</p><h2 id="3-1-Servers"><a href="#3-1-Servers" class="headerlink" title="3.1 Servers"></a>3.1 Servers</h2><p>​    可以通过集群进行部署，一个或者多个server都可以运行，用于存储的服务器称为brokers。kafka集群具有高度的可拓展性和容错能力，如何任何服务器发生故障，其他服务器将接管其工作。</p><h2 id="3-2-Clients"><a href="#3-2-Clients" class="headerlink" title="3.2 Clients"></a>3.2 Clients</h2><p>微服务或者分布式客户端并行地读取、写和处理事件流。</p><h2 id="3-3-主要概念和术语"><a href="#3-3-主要概念和术语" class="headerlink" title="3.3 主要概念和术语"></a>3.3 主要概念和术语</h2><p>​    事件（event）可以称之为消息。从kafka读取或者写入数据，数据要遵循一定的格式：概念上，一条消息要包含一个key，一个value、一个时间戳以及可选择的元数据信息。</p><p>​    在kafka中，生产者和消费者之间是独立的。生产者不必等待消费者消费数据，但Kafka会保证同一个消费者不会重复消费同一条数据。</p><p>​    消息会以Topic进行分组和永久存储。简单来说，Topic就像文件系统一个文件夹，消息就像是文件夹中的文件。一个Topic可以有多个生产者和多个消费者，<strong>消息被消费后不会删除</strong>，用户可以通过配置文件来决定就消息可以保存多久，但是磁盘上的消息数量不会影响kafka的性能。</p><p>​    一个Topic下有多个Partition（分区）。简单解释就是，一个topic里面的消息被拆分了，而且分布在了不同的broker上。这种分布式的结构在一定程度上实现了生产者和消费者同时进行消息的写入与读取。当一条消息被发布到了Topic中，它实际上是被加到了一个partition中。相同key的消息会被写入到同一个partition中，kafka保证任意消费者会严格按照消息的写入顺序来消费消息。为了保证数据的容错率和高可用性，每个Topic都有存有副本（每个partition分布在不同的broker，每个broker会存有其他partition数据的副本）</p><h1 id="4-安装"><a href="#4-安装" class="headerlink" title="4. 安装"></a>4. 安装</h1><p><strong>这里注意一样，kafka3.0号称不依赖zk了，但是我看了一下官网样例，还是写的带zk的部署方式，不依赖zk的只是有范本，还未有稳定版本。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">tar -zxf kafka_2.13-3.0.0.tgz</span><br><span class="line"><span class="built_in">cd</span> kafka_2.13-3.0.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 至少需要java8</span></span><br><span class="line">bin/zookeeper-server-start.sh config/zookeeper.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># 在另一台终端开启kafka broker</span></span><br><span class="line">bin/kafka-server-start.sh config/server.properties</span><br></pre></td></tr></table></figure><h1 id="5-使用"><a href="#5-使用" class="headerlink" title="5. 使用"></a>5. 使用</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建topic</span></span><br><span class="line"><span class="comment"># 一个partition，一个副本，topic名称test</span></span><br><span class="line">./kafka-topics.sh --create --zookeeper ip:2182 --replication-factor 1 --partition 1 --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前kafka有多少topic</span></span><br><span class="line">./kafka-topics.sh --list --zookeeper ip:2182</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发送消息</span></span><br><span class="line"><span class="comment"># kafka自带了一个producer客户端，可与从本地文件或者命令行中传递消息（把内容以消息的形式发送到kafka集群）</span></span><br><span class="line"><span class="comment"># 发送两条消息</span></span><br><span class="line">./kafka-console-producer.sh --broker-list ip:9092 --topic <span class="built_in">test</span></span><br><span class="line">&gt; message1</span><br><span class="line">&gt; message2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 消费消息</span></span><br><span class="line"><span class="comment"># kafka携带了一个命令行客户端，会将获取到内容在命令行输出，默认消费最新消息</span></span><br><span class="line"><span class="comment"># 方式一：从最后一条消息的偏移量+1开始消费</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server ip:9092 --topic <span class="built_in">test</span></span><br><span class="line"><span class="comment"># 方式二：从头开始消费</span></span><br><span class="line">./kafka-console-consumer.sh --bootstarp-server ip:9092 --from-beginning --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h2 id="5-1-消费者的几个注意点："><a href="#5-1-消费者的几个注意点：" class="headerlink" title="5.1 消费者的几个注意点："></a>5.1 消费者的几个注意点：</h2><ul><li>消息是持久化存储的</li><li>消费是顺序存储的，先进先出</li><li>消息有偏移量</li><li>消息可以指定偏移量进行消费</li></ul><h1 id="6-顺序消费原理"><a href="#6-顺序消费原理" class="headerlink" title="6. 顺序消费原理"></a>6. 顺序消费原理</h1><p>kafka安装时的配置文件中指定的<code>log.dir</code>是kafka保存消息的路径。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># log.dir 内部</span></span><br><span class="line">默认有一个主题：__consumer_offsets，这个主题有多个分区，里面存放着消费者维护的偏移量。</span><br><span class="line"><span class="comment"># 每个消费者消费到了某个partition的第几条数据(offset)会存储在这个主题里面，以便于恢复</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">test</span>主题：</span><br><span class="line">- 00000.index <span class="comment"># offset position（段的偏移）</span></span><br><span class="line">- 00000.log <span class="comment"># 消息本体</span></span><br><span class="line">- 00000.timestamp</span><br><span class="line"></span><br><span class="line"><span class="comment"># .log文件其实就是分段(segment)，分段文件的大小可以在server.properties里面配置，默认1GB</span></span><br><span class="line"><span class="comment"># 查看分段文件</span></span><br><span class="line">./kafka-run-class.sh kafka.tools.DumpLogSegments --files 00000.log --<span class="built_in">print</span>-data-log </span><br><span class="line"><span class="comment"># segment结构如下：</span></span><br><span class="line">- offset: 相对于该分区的偏移值，可以理解成第几条消息</span><br><span class="line">- position: 相对于当前segment的偏移值</span><br><span class="line">- CreateTime: 记录创建的时间</span><br><span class="line">- isValid: 表示key的长度</span><br><span class="line">- valuesize: 表示value的长度</span><br><span class="line">- magic: 本次发布的kafka服务协议版本号</span><br><span class="line">- compressscodec: 压缩工具</span><br><span class="line">- producedId: 生产者ID（用于幂等）</span><br><span class="line">- sequence: 消息的序列号（用于幂等）</span><br><span class="line">- payload: 表示具体的消息</span><br></pre></td></tr></table></figure><p>原理：</p><ul><li>生产者将消息发送给broker，broker将消息保存在本地的日志文件中</li><li>消息的保存是有时序的，通过offset偏移量来保证消息的有序性</li><li>消费者消费消息时也是通过offsets来描述当前要消费的那条消息的位置（offset+1）</li></ul><h1 id="7-单播消息和多播消息"><a href="#7-单播消息和多播消息" class="headerlink" title="7. 单播消息和多播消息"></a>7. 单播消息和多播消息</h1><p>在一个topic中，启动两个消费者，一个生产者，问：生产者发送消息，这条消息是否会被两个消费者消费？</p><h2 id="7-1-单播消息"><a href="#7-1-单播消息" class="headerlink" title="7.1 单播消息"></a>7.1 单播消息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单播消息</span></span><br><span class="line"><span class="comment"># consumer-1</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server ip:9092 --consumer-property group.id=testGroup --topic <span class="built_in">test</span></span><br><span class="line"><span class="comment"># consumer-2</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server ip:9092 --consumer-property group.id=testGroup --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">&gt; 生产者发送了消息</span><br><span class="line">&gt; message1</span><br><span class="line">&gt; message2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 发现消费者group中只有一个消费者会受到订阅的test主题的消息，而且这个消费者还不会变（因为test主题只有一个partition）</span></span><br><span class="line"><span class="comment"># 可以理解成这个消费者订阅了这个partition</span></span><br></pre></td></tr></table></figure><h2 id="7-2-多播消息"><a href="#7-2-多播消息" class="headerlink" title="7.2 多播消息"></a>7.2 多播消息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 多播消息</span></span><br><span class="line"><span class="comment"># consumer-1</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server ip:9092 --consumer-property group.id=testGroup1 --topic <span class="built_in">test</span></span><br><span class="line"><span class="comment"># consumer-2</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-server ip:9092 --consumer-property group.id=testGroup2 --topic <span class="built_in">test</span></span><br><span class="line"></span><br><span class="line">&gt; 生产者发送了消息</span><br><span class="line">&gt; message1</span><br><span class="line">&gt; message2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 两个消费者都收到了消息</span></span><br></pre></td></tr></table></figure><h2 id="7-3-解释"><a href="#7-3-解释" class="headerlink" title="7.3 解释"></a>7.3 解释</h2><p>​    概念就是消费者组，一个消费者组可以看成是一个消费者，一个消费者是不能重复消费消息的，消费者组是为了满足并发消费消息，从而实现高吞吐的设计。一个partition效果不明显，但是当partition多了，一个消费者组中不同的消费者可以通过某个topic的消息效率。</p><h2 id="7-4-查看消费组及信息"><a href="#7-4-查看消费组及信息" class="headerlink" title="7.4 查看消费组及信息"></a>7.4 查看消费组及信息</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看当前节点下有多少消费者组</span></span><br><span class="line">./kafka-consumer-groups.sh --bootstrap-server ip:9092 --list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看消费者组中的具体信息：当前偏移量、最后一条消息的偏移量</span></span><br><span class="line">./kafka-consumer-groups.sh --bootstrap-server ip:9092 --describe --group testGroup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以看到以下信息</span></span><br><span class="line">GROUP TOPIC PARTITION CURRENT-OFFSET LOG-END-OFFSET LAG(还有多少未被消费的消息) CONSUMER-ID  HOST CLIENT-ID</span><br><span class="line"><span class="comment"># 如果消费者挂了，以上信息依然会存在，生产者可以继续生产消息，但是CURRENT-OFFSET是不动的，因为消费者没有消费消息</span></span><br></pre></td></tr></table></figure><p>重点关注：</p><ul><li>CURRENT-OFFSET：最后被消费的消息的偏移量</li><li>LOG-END-OFFSET：最后一条消息的偏移量</li><li>LAG：当前消费组未消费的消息数量</li></ul><h1 id="8-主题与分区"><a href="#8-主题与分区" class="headerlink" title="8. 主题与分区"></a>8. 主题与分区</h1><h2 id="8-1-Topic"><a href="#8-1-Topic" class="headerlink" title="8.1 Topic"></a>8.1 Topic</h2><p>​    主题就是Kafka消息的<strong>逻辑</strong>划分，一个主题下相当与一个类别。Kafka通过Topic将消息进行分类，不同的Topic会被订阅该Topic的消费者消费。</p><p>​    如果一个Topic中的消息巨多无比（可能有几个T），而消息是会被保存到<code>.log</code>文件中的，用一个文件，压力太大。为了解决这个问题，kafka使用了partition来分布式存储这些消息。</p><h2 id="8-2-Partition"><a href="#8-2-Partition" class="headerlink" title="8.2 Partition"></a>8.2 Partition</h2><ul><li>分区存储，可以解决统一存储文件过大的问题</li><li>提高了读写的吞吐量</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 主题多分区</span></span><br><span class="line">./kafka-topics.sh --create --zookeeper ip:2181 --replication-factor 1 --partitions 2 --topic test2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看log文件，可以看见如果有多个partition，一个topic其实就会有两个文件夹存在磁盘上</span></span><br><span class="line">test2-0</span><br><span class="line">- 0000.index</span><br><span class="line">- 0000.log</span><br><span class="line">- 0000.timestamp</span><br><span class="line"></span><br><span class="line">test2-1</span><br><span class="line">- 0000.index</span><br><span class="line">- 0000.log</span><br><span class="line">- 0000.timestamp</span><br></pre></td></tr></table></figure><p><strong>小细节，大改变：</strong></p><ul><li>kafka内部默认有50个主题__consumer_offsets，这些主题用存储消费者消费消息的偏移量</li><li>消费者会定期把自己消费分区的offset提交给kafka内部的主题__consumer_offsets，提交的时候，key是<code>consumerGroupId+topic+分区号</code>，value是当前分区的offset。（消费者）</li><li>__conusmer_offsets有多个分区（可以server.properties里面配置，默认50），消费者通过<code>hash(consumerGroupId)%分区数</code>来确定消息被存储到哪个分区</li><li>kafka会定期消费已经消费过的数据，默认是7天，旧消息会被删除</li><li>__consumer_offsets里面有多个分区是为了提高并发效率，很多消费者可以同时写入自己的offset</li></ul><h1 id="9-集群与副本"><a href="#9-集群与副本" class="headerlink" title="9. 集群与副本"></a>9. 集群与副本</h1><h2 id="9-1-搭建集群（伪），三个broker"><a href="#9-1-搭建集群（伪），三个broker" class="headerlink" title="9.1 搭建集群（伪），三个broker"></a>9.1 搭建集群（伪），三个broker</h2><p>准备3个server.properties，这里演示建在一台机器上的伪集群</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># server.properties</span></span><br><span class="line">broker.id = 0</span><br><span class="line">listeners=PLAINEXT://ip:9092</span><br><span class="line">log.dir=/usr/<span class="built_in">local</span>/data/kafka-logs-0</span><br><span class="line"></span><br><span class="line"><span class="comment"># server1.properties</span></span><br><span class="line">broker.id = 1</span><br><span class="line">listeners=PLAINEXT://ip:9093</span><br><span class="line">log.dir=/usr/<span class="built_in">local</span>/data/kafka-logs-1</span><br><span class="line"></span><br><span class="line"><span class="comment"># serve2r.properties</span></span><br><span class="line">broker.id = 2</span><br><span class="line">listeners=PLAINEXT://ip:9094</span><br><span class="line">log.dir=/usr/<span class="built_in">local</span>/data/kafka-logs-2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动三个kafka服务器</span></span><br><span class="line">bin/kafka-server-start.sh -deamon config/server.properties</span><br><span class="line">bin/kafka-server-start.sh -deamon config/server1.properties</span><br><span class="line">bin/kafka-server-start.sh -deamon config/server2.properties</span><br><span class="line"></span><br><span class="line"><span class="comment"># 可以登录zkClient来看一下节点有没有顺利注册(brokers/ids下有三个znode(0, 1, 2))</span></span><br></pre></td></tr></table></figure><h2 id="9-2-副本的概念"><a href="#9-2-副本的概念" class="headerlink" title="9.2 副本的概念"></a>9.2 副本的概念</h2><p>​    副本是为主题中的分区创建多个备份，多个副本在Kafka集群中多个broker中，<strong>会有一个副本是Leader</strong>，其他是Follower，副本数量一般不超过Broker的数量，不然没有意义。</p><p>创建1个主题，2个分区，三个副本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./kafka-topics.sh --create --zookeeper ip:2181 --replication-factor 3 --partitions 2 --topic my-replica-topic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看主题</span></span><br><span class="line">./kafka-topics.sh --describe --zookeeper ip:2181 --topic my-replica-topic</span><br></pre></td></tr></table></figure><p>结构：</p><div class="table-container"><table><thead><tr><th>Topic:my-replica-topic</th><th>PartitionCount:2</th><th>ReplicationFactor:3</th><th>Configs:</th><th></th></tr></thead><tbody><tr><td>- Topic：my-replica-topic</td><td>- Partition: 0</td><td>- Leader:2</td><td>Replicas: 2,0,1</td><td>lsr:2,0,1</td></tr><tr><td>- Topic：my-replica-topic</td><td>- Partition: 2</td><td>- Leader:0</td><td>Replicas: 0,1,2</td><td>lsr:0,1,2</td></tr></tbody></table></div><ul><li><strong>Leader负责读写</strong>，Follower中的副本会同步Leader中的数据</li><li>不同Partition所在的Broker是不一样的</li><li>每个Partition的Leader可能都不一样，说明Leader不是Topic的概念。Leader所在Broker负责该Partition的读写，也负责Follower的数据同步</li><li>lsr：可以同步或者已经同步的节点存放在isr中，如果一个节点同步性能很差，该节点会被T掉</li><li>Leader挂掉，新Leader会在lsr集合中选举</li></ul><h1 id="10-Kafka集群的消息发送和消费"><a href="#10-Kafka集群的消息发送和消费" class="headerlink" title="10. Kafka集群的消息发送和消费"></a>10. Kafka集群的消息发送和消费</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 发送</span></span><br><span class="line">./kafka-console-producer.sh --broker-list ip:9092.ip:9093,ip:9094 --topic my-replica-topic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 单消费者</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-list ip:9092.ip:9093,ip:9094  --from-beginning --topic my-replica-topic</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一个组两个消费者</span></span><br><span class="line"><span class="comment"># 消费者1</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-list ip:9092.ip:9093,ip:9094 --consumer-property group.id=testGroup1 --from-beginning --topic my-replica-topic</span><br><span class="line"><span class="comment"># 消费者2</span></span><br><span class="line">./kafka-console-consumer.sh --bootstrap-list ip:9092.ip:9093,ip:9094 --consumer-property group.id=testGroup1 --from-beginning --topic my-replica-topic</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>一个Partition最多被一个消费组里的一个消费者消费，因为要保证消息消费的顺序性（想想并发）</li><li>一个消费者可以消费多个Partition</li><li>Kafka只能保证Partition中局部的消息顺序，不能保证Topic中的消息顺序消费</li><li>消费组中的消费者的数量一般不会多于Partition的数量，因为会有消费者消费不到消息</li><li>如果某个消费者挂了，就会触发rebalance机制，让其他消费者消费其对应的partition</li></ul><h1 id="10-Kafka-Java生产者实现"><a href="#10-Kafka-Java生产者实现" class="headerlink" title="10. Kafka Java生产者实现"></a>10. Kafka Java生产者实现</h1><h2 id="10-1-实现"><a href="#10-1-实现" class="headerlink" title="10.1 实现"></a>10.1 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖</span></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">&lt;groupId&gt;org.apache.kafka&lt;/groupId&gt;</span><br><span class="line">&lt;artifactId&gt;kafka-clients&lt;/artifactId&gt;</span><br><span class="line">&lt;version&gt;与kafka版本一致&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">            </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySimpleProducer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TOPIC_NAME = <span class="string">"memo-kafka-test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 1. 设置参数</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"192.168.1.249:9092,192.168.1.249:9093,192.168.1.249:9094"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 把key和value从字符串序列转成字节数组</span></span><br><span class="line">        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 配置同步消息的ack</span></span><br><span class="line">        props.put(ProducerConfig.ACKS_CONFIG, <span class="string">"1"</span>);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 发送失败会重试，默认重试间隔100ms，重试能保证消息发送的可靠性，但也会造成消息的重复发送，</span></span><br><span class="line"><span class="comment">         * 如网络抖动，所以需要在接收者那边做好消息接收的幂等性处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        props.put(ProducerConfig.RETRIES_CONFIG, <span class="number">3</span>);</span><br><span class="line">        <span class="comment">// 发送消息重试间隔时间，设为300</span></span><br><span class="line">        props.put(ProducerConfig.RETRY_BACKOFF_MS_CONFIG, <span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 设置消息发送的本地缓冲区，如果设置了该缓冲区，消息会先发送到本地缓冲区(默认32M)，</span></span><br><span class="line"><span class="comment">         * kafka生产者客户端会启一条本地线程拉16kb的数据发送给kafka，如果消息没达到16kb，该线程</span></span><br><span class="line"><span class="comment">         * 10毫秒以后也会将数据发送</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class="number">10240</span>);</span><br><span class="line">        props.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="number">16384</span>);</span><br><span class="line">        props.put(ProducerConfig.LINGER_MS_CONFIG, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 创建生产消息的客户端，传入参数</span></span><br><span class="line">        Producer&lt;String, String&gt; producer = <span class="keyword">new</span> KafkaProducer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 创建消息</span></span><br><span class="line">        <span class="comment">// key的作用是决定往哪个分区上发，value是具体消息内容</span></span><br><span class="line">        ProducerRecord&lt;String, String&gt; producerRecord = <span class="keyword">new</span> ProducerRecord&lt;&gt;(TOPIC_NAME, <span class="string">"mytestKey"</span>, <span class="string">"hello kafka2"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 发送消息,得到消息发送的元数据并输出</span></span><br><span class="line">        RecordMetadata recordMetadata = producer.send(producerRecord).get();</span><br><span class="line">        System.out.println(<span class="string">"**********************************"</span>);</span><br><span class="line">        System.out.println(<span class="string">"同步方式发送结果："</span> + <span class="string">"topic-"</span> + recordMetadata.topic()</span><br><span class="line">                + <span class="string">"|partition-"</span> + recordMetadata.partition() + <span class="string">"|offset-"</span> + recordMetadata.offset());</span><br><span class="line">        producer.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-2-同步发送和异步发送"><a href="#10-2-同步发送和异步发送" class="headerlink" title="10.2 同步发送和异步发送"></a>10.2 同步发送和异步发送</h2><p>同步发送和异步发送都是针对生产者和Kafka服务端的，同步用的比较多，异步的性能提升不明显，反而会出现消息丢失的可能。</p><h3 id="10-2-1-同步发送"><a href="#10-2-1-同步发送" class="headerlink" title="10.2.1 同步发送"></a>10.2.1 同步发送</h3><p>如果生产者发送消息，没有收到kafka给服务端的<code>ack</code>，生产者会阻塞，阻塞到3S的时间（可以配置），如果还没有收到消息，则会进行重试，重试的次数默认也为3个，还不行，就会报错了。</p><h3 id="10-2-2-异步发送"><a href="#10-2-2-异步发送" class="headerlink" title="10.2.2 异步发送"></a>10.2.2 异步发送</h3><p>不会确认收到kafka的<code>ack</code>，会触发一个回调函数（不会阻塞）。生产者发送完消息可以做别的事情，broker收到消息后就会触发回调（callback）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">producer.send(producerRecord, (recordMetadata, e) -&gt; &#123;</span><br><span class="line">               <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   System.err.println(<span class="string">"发送消息失败:"</span> + Arrays.toString(e.getStackTrace()));</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">if</span> (recordMetadata != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   System.out.println(<span class="string">"异步方式发送结果："</span> + <span class="string">"topic-"</span> + recordMetadata.topic()</span><br><span class="line">                           + <span class="string">"|partition-"</span> + recordMetadata.partition() + <span class="string">"|offset-"</span> + recordMetadata.offset());</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-3-关于生产者ack配置"><a href="#10-3-关于生产者ack配置" class="headerlink" title="10.3 关于生产者ack配置"></a>10.3 关于生产者ack配置</h2><p><code>ack</code>就是在<strong>同步发送</strong>中，生产者给kafka发送消息后的，kafka给的一个确认信号。</p><p><code>ack</code>会有三个参数配置：</p><ul><li>ack=0：kafka不需要任何broker收到消息，会立即返回ack给生产者（最容易丢消息，但是效率最高）。</li><li>ack=1：leader已经收到消息，并把消息写入到本地的log中，才会返回ack生产者。性能和安全性是最均衡的。</li><li>ack=-1/all：里面有默认配置<code>min.insync.replicas=2(默认为1，推荐配置大于等于2)</code>，leader同步2个副本之后（此时集群中有2个broker已完成数据的接收），才会返回ack给生产者。最安全但性能最差。默认是1，那么和ack=1是一样的，因为leader本身就是1个副本。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置同步消息的ack</span></span><br><span class="line">     props.put(ProducerConfig.ACKS_CONFIG, <span class="string">"1"</span>);</span><br><span class="line">     <span class="comment">/*</span></span><br><span class="line"><span class="comment">      * 发送失败会重试，默认重试间隔100ms，重试能保证消息发送的可靠性，但也会造成消息的重复发送，</span></span><br><span class="line"><span class="comment">      * 如网络抖动，所以需要在接收者那边做好消息接收的幂等性处理</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     props.put(ProducerConfig.RETRIES_CONFIG, <span class="number">3</span>);</span><br><span class="line">     <span class="comment">// 发送消息重试间隔时间，设为300</span></span><br><span class="line">     props.put(ProducerConfig.RETRY_BACKOFF_MS_CONFIG, <span class="number">300</span>);</span><br></pre></td></tr></table></figure><h2 id="10-4-关于消息发送的缓冲区"><a href="#10-4-关于消息发送的缓冲区" class="headerlink" title="10.4 关于消息发送的缓冲区"></a>10.4 关于消息发送的缓冲区</h2><ul><li>kafka默认会创建一个消息缓冲区，默认为32MB（可配置）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 设置消息发送的本地缓冲区，如果设置了该缓冲区，消息会先发送到本地缓冲区(默认32M)，</span></span><br><span class="line"><span class="comment"> * kafka生产者客户端会启一条本地线程拉16kb的数据发送给kafka，如果消息没达到16kb，该线程</span></span><br><span class="line"><span class="comment"> * 10毫秒以后也会将数据发送</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">props.put(ProducerConfig.BUFFER_MEMORY_CONFIG, <span class="number">33554432</span>);</span><br></pre></td></tr></table></figure><ul><li>kafka客户端本地线程会去缓冲区一次拉16kb的数据，发送给broker</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(ProducerConfig.BATCH_SIZE_CONFIG, <span class="number">16384</span>);</span><br></pre></td></tr></table></figure><ul><li>如果线程拉不到16kb的数据，间隔10ms也会发送给broker</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">props.put(ProducerConfig.LINGER_MS_CONFIG, <span class="number">10</span>);</span><br></pre></td></tr></table></figure><h1 id="11-Java客户端消费者的实现"><a href="#11-Java客户端消费者的实现" class="headerlink" title="11. Java客户端消费者的实现"></a>11. Java客户端消费者的实现</h1><h2 id="11-1-实现"><a href="#11-1-实现" class="headerlink" title="11.1 实现"></a>11.1 实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 依赖也是kafka-clients</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MySimpleConsumer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TOPIC_NAME = <span class="string">"memo-kafka-test"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String CONSUMER_GROUP_NAME = <span class="string">"memoGroup"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 1. 设置参数</span></span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.put(ConsumerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="string">"192.168.1.249:9092,192.168.1.249:9093,192.168.1.249:9094"</span>);</span><br><span class="line">        <span class="comment">// 消费者组</span></span><br><span class="line">        props.put(ConsumerConfig.GROUP_ID_CONFIG, CONSUMER_GROUP_NAME);</span><br><span class="line">        props.put(ConsumerConfig.KEY_DESERIALIZER_CLASS_CONFIG, StringDeserializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        props.put(ConsumerConfig.VALUE_DESERIALIZER_CLASS_CONFIG, StringDeserializer<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>())</span>;</span><br><span class="line">        <span class="comment">// 开启offset自动提交，默认是true</span></span><br><span class="line">        props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="string">"true"</span>);</span><br><span class="line">        <span class="comment">// 设置自动提交的时间间隔，默认1000ms</span></span><br><span class="line">        props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 一次poll最大拉取消息的条数，可以根据消费的速度来设置，默认500</span></span><br><span class="line">        props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, <span class="number">500</span>);</span><br><span class="line">        <span class="comment">// 如果两次poll的时间如果超过了30s的时间间隔，kafka会人认为其消费能力过弱，会把其T出消费者组，并把分区分给其他消费者（rebalance）。</span></span><br><span class="line">        props.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, <span class="number">30</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// consumer给broker发送心跳的间隔时间</span></span><br><span class="line">        props.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, <span class="number">1000</span>);</span><br><span class="line">        <span class="comment">// kafka如果10秒没有收到消费者的心跳，则会把消费者踢出消费组，进行rebalance</span></span><br><span class="line">        props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, <span class="number">10</span> * <span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        KafkaConsumer&lt;String, String&gt; consumer = <span class="keyword">new</span> KafkaConsumer&lt;&gt;(props);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2. 订阅主题列表</span></span><br><span class="line">        <span class="comment">// consumer.subscribe(Collections.singletonList(TOPIC_NAME));</span></span><br><span class="line">        <span class="comment">// 指定分区消费</span></span><br><span class="line">        consumer.assign(Collections.singleton(<span class="keyword">new</span> TopicPartition(TOPIC_NAME, <span class="number">1</span>)));</span><br><span class="line">        <span class="comment">// 消息回溯消费</span></span><br><span class="line">        consumer.seekToBeginning(Collections.singleton(<span class="keyword">new</span> TopicPartition(TOPIC_NAME, <span class="number">1</span>)));</span><br><span class="line">        <span class="comment">// 从partition1的offset=5开始消费</span></span><br><span class="line">        <span class="comment">//consumer.seek(new TopicPartition(TOPIC_NAME, 1), 5);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从指定时间点开始消费</span></span><br><span class="line">        List&lt;PartitionInfo&gt; topicPartitions = consumer.partitionsFor(TOPIC_NAME);</span><br><span class="line">        <span class="keyword">long</span> fetchDateTime = <span class="keyword">new</span> Date().getTime() - <span class="number">1000</span> * <span class="number">60</span> * <span class="number">60</span>;</span><br><span class="line">        Map&lt;TopicPartition, Long&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (PartitionInfo partition : topicPartitions) &#123;</span><br><span class="line">            map.put(<span class="keyword">new</span> TopicPartition(TOPIC_NAME, partition.partition()), fetchDateTime);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        // 根据时间找偏移量</span></span><br><span class="line"><span class="comment">        Map&lt;TopicPartition, OffsetAndTimestamp&gt; parMap = consumer.offsetsForTimes(map);</span></span><br><span class="line"><span class="comment">        for (Map.Entry&lt;TopicPartition, OffsetAndTimestamp&gt; entry : parMap.entrySet()) &#123;</span></span><br><span class="line"><span class="comment">            TopicPartition topicPartition = entry.getKey();</span></span><br><span class="line"><span class="comment">            OffsetAndTimestamp offsetAndTimestamp = entry.getValue();</span></span><br><span class="line"><span class="comment">            if (topicPartition == null || offsetAndTimestamp == null) continue;</span></span><br><span class="line"><span class="comment">            long offset = offsetAndTimestamp.offset();</span></span><br><span class="line"><span class="comment">            System.out.println("partition-" + topicPartition.partition() + "|offset-" + offset);</span></span><br><span class="line"><span class="comment">            // 指定offset开始消息</span></span><br><span class="line"><span class="comment">            consumer.assign(Collections.singletonList(topicPartition));</span></span><br><span class="line"><span class="comment">            consumer.seek(topicPartition, offset);</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 3. poll() API是拉取消息的长轮询,如果poll在1000ms内没有拉满，就会在1000ms之内一直等待</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br><span class="line">            <span class="keyword">for</span> (ConsumerRecord&lt;String, String&gt; record : records) &#123;</span><br><span class="line">                <span class="comment">// 消费</span></span><br><span class="line">                System.out.printf(<span class="string">"收到消息: partition=%d, offset=%d, key=%s, value=%s%n"</span>,</span><br><span class="line">                        record.partition(), record.offset(), record.key(), record.value());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">            // 消费结束后</span></span><br><span class="line"><span class="comment">            if (!records.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">                // 同步提交，当前线程会阻塞到offset提交成功</span></span><br><span class="line"><span class="comment">                // consumer.commitAsync();</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">                // 异步提交</span></span><br><span class="line"><span class="comment">                consumer.commitAsync((map, e) -&gt; &#123;</span></span><br><span class="line"><span class="comment">                    if (e != null) &#123;</span></span><br><span class="line"><span class="comment">                        e.printStackTrace();</span></span><br><span class="line"><span class="comment">                    &#125;</span></span><br><span class="line"><span class="comment">                &#125;);</span></span><br><span class="line"><span class="comment">            &#125;</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-2-消费者的自动提交和手动提交"><a href="#11-2-消费者的自动提交和手动提交" class="headerlink" title="11.2 消费者的自动提交和手动提交"></a>11.2 消费者的自动提交和手动提交</h2><p>消费者无论是自动提交还是手动提交，都需要把所属的<strong>消费组+消费的某个主题+消费的某个分区及消费的偏移量</strong>，这样的信息提交到集群的__consuemr_offset主题里面。</p><p>详细点来：消费者会把offset提交到borker-0上的__consumer_offset主题上，这个broker-0是一个controller。消费者要根据offset进行消费，消费者是先把消息给poll下来，然后不管有没有消费，就会定时把当前偏移量给提交给offset主题（自动提交）；手动提交就是把消息消费时或者消费完再手动提交offset。</p><h3 id="11-2-1-自动提交"><a href="#11-2-1-自动提交" class="headerlink" title="11.2.1 自动提交"></a>11.2.1 自动提交</h3><p>消费者poll到消息后默认情况下，会自动向broker的__consumer_offset主题提交当前主题-分区消费的偏移量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启offset自动提交，默认是true</span></span><br><span class="line">props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="string">"true"</span>);</span><br><span class="line"><span class="comment">// 设置自动提交的时间间隔，默认1000ms</span></span><br><span class="line">props.put(ConsumerConfig.AUTO_COMMIT_INTERVAL_MS_CONFIG, <span class="string">"1000"</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>自动提交可能会丢消息，当消费者刚提交offset之后，没来得及消费就挂了，下一个消费者会从已经提交的offset的下一个位置开始消费消息。未被消费的消息就丢失掉了。</p><h3 id="11-2-2-手动提交"><a href="#11-2-2-手动提交" class="headerlink" title="11.2.2 手动提交"></a>11.2.2 手动提交</h3><ul><li>设置手动提交参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启offset手动提交</span></span><br><span class="line">props.put(ConsumerConfig.ENABLE_AUTO_COMMIT_CONFIG, <span class="string">"false"</span>);</span><br></pre></td></tr></table></figure><ul><li>手动同步提交</li></ul><p>会等待broker-0返回ack</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费结束后</span></span><br><span class="line"><span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 同步提交，当前线程会阻塞到offset提交成功</span></span><br><span class="line">consumer.commitAsync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>手动异步提交</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 消费结束后</span></span><br><span class="line"><span class="keyword">if</span> (!records.isEmpty()) &#123;</span><br><span class="line"><span class="comment">// 异步提交</span></span><br><span class="line">consumer.commitAsync((map, e) -&gt; &#123;</span><br><span class="line"><span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 异步提交失败处理逻辑</span></span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="11-3-长轮询消息"><a href="#11-3-长轮询消息" class="headerlink" title="11.3 长轮询消息"></a>11.3 长轮询消息</h2><ul><li>默认情况下，消费者一次会poll500条消息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一次poll最大拉取消息的条数，可以根据消费的速度来设置，默认500</span></span><br><span class="line">props.put(ConsumerConfig.MAX_POLL_RECORDS_CONFIG, <span class="number">500</span>);</span><br></pre></td></tr></table></figure><ul><li>代码中设置了长轮询的时间是1000ms</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* 3. poll() API是拉取消息的长轮询,如果poll在1000ms内没有拉到数据，则返回空</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofMillis(<span class="number">1000</span>));</span><br></pre></td></tr></table></figure><p>意味着：</p><ul><li><ul><li>如果一次poll到了数据，最大为500条，就会直接执行for循环</li><li>如果1000ms内没poll到数据，则返回空</li></ul></li><li><p>如果两次poll的时间间隔太长（默认30s），消费者会被kafkaT出消费者组</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果两次poll的时间如果超过了30s的时间间隔，kafka会人认为其消费能力过弱，会把其T出消费者组，并把分区分给其他消费者（rebalance）。</span></span><br><span class="line">props.put(ConsumerConfig.MAX_POLL_INTERVAL_MS_CONFIG, <span class="number">30</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h1 id="12-消费者的其他配置"><a href="#12-消费者的其他配置" class="headerlink" title="12. 消费者的其他配置"></a>12. 消费者的其他配置</h1><h2 id="12-1-健康状态检查"><a href="#12-1-健康状态检查" class="headerlink" title="12.1 健康状态检查"></a>12.1 健康状态检查</h2><p>消费者每隔1s像kafka集群发送心跳，集群发现如果有10s没有续约的消费者，将被T出消费组，触发该消费组的rebalance。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// consumer给broker发送心跳的间隔时间</span></span><br><span class="line">props.put(ConsumerConfig.HEARTBEAT_INTERVAL_MS_CONFIG, <span class="number">1000</span>);</span><br><span class="line"><span class="comment">// kafka如果10秒没有收到消费者的心跳，则会把消费者踢出消费组，进行rebalance</span></span><br><span class="line">props.put(ConsumerConfig.SESSION_TIMEOUT_MS_CONFIG, <span class="number">10</span> * <span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h2 id="12-2-指定分区消费"><a href="#12-2-指定分区消费" class="headerlink" title="12.2 指定分区消费"></a>12.2 指定分区消费</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定分区消费</span></span><br><span class="line">consumer.assign(Collections.singleton(<span class="keyword">new</span> TopicPartition(TOPIC_NAME, <span class="number">0</span>)));</span><br></pre></td></tr></table></figure><h2 id="12-3-消息回溯消费"><a href="#12-3-消息回溯消费" class="headerlink" title="12.3 消息回溯消费"></a>12.3 消息回溯消费</h2><p>每次消费都从offset=0开始消费，需要先指定分区，再seek</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定分区消费</span></span><br><span class="line">consumer.assign(Collections.singleton(<span class="keyword">new</span> TopicPartition(TOPIC_NAME, <span class="number">1</span>)));</span><br><span class="line"><span class="comment">// 消息回溯消费</span></span><br><span class="line">onsumer.seekToBeginning(Collections.singleton(<span class="keyword">new</span> TopicPartition(TOPIC_NAME, <span class="number">1</span>)));</span><br></pre></td></tr></table></figure><h2 id="12-4-指定offset消费"><a href="#12-4-指定offset消费" class="headerlink" title="12.4 指定offset消费"></a>12.4 指定offset消费</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定分区消费</span></span><br><span class="line">consumer.assign(Collections.singleton(<span class="keyword">new</span> TopicPartition(TOPIC_NAME, <span class="number">1</span>)));</span><br><span class="line"><span class="comment">// 消息回溯消费</span></span><br><span class="line"><span class="comment">// consumer.seekToBeginning(Collections.singleton(new TopicPartition(TOPIC_NAME, 1)));</span></span><br><span class="line"><span class="comment">// 从partition1的offset=5开始消费</span></span><br><span class="line">consumer.seek(<span class="keyword">new</span> TopicPartition(TOPIC_NAME, <span class="number">1</span>), <span class="number">5</span>);</span><br></pre></td></tr></table></figure><h2 id="12-5-从指定时间点开始消费"><a href="#12-5-从指定时间点开始消费" class="headerlink" title="12.5 从指定时间点开始消费"></a>12.5 从指定时间点开始消费</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据时间找偏移量</span></span><br><span class="line">Map&lt;TopicPartition, OffsetAndTimestamp&gt; parMap = consumer.offsetsForTimes(map);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;TopicPartition, OffsetAndTimestamp&gt; entry : parMap.entrySet()) &#123;</span><br><span class="line">TopicPartition topicPartition = entry.getKey();</span><br><span class="line">OffsetAndTimestamp offsetAndTimestamp = entry.getValue();</span><br><span class="line"><span class="keyword">if</span> (topicPartition == <span class="keyword">null</span> || offsetAndTimestamp == <span class="keyword">null</span>) <span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">long</span> offset = offsetAndTimestamp.offset();</span><br><span class="line">System.out.println(<span class="string">"partition-"</span> + topicPartition.partition() + <span class="string">"|offset-"</span> + offset);</span><br><span class="line"><span class="comment">// 指定offset开始消息</span></span><br><span class="line">consumer.assign(Collections.singletonList(topicPartition));</span><br><span class="line">consumer.seek(topicPartition, offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-6-新消费者组的offset"><a href="#12-6-新消费者组的offset" class="headerlink" title="12.6 新消费者组的offset"></a>12.6 新消费者组的offset</h2><p>之前命令行的时候搞过的就是这个<code>--from-beginning</code>还记得吗。</p><p>默认的消费是最后的<code>offset+1</code>。知道这个就可以理解这个配置了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* latest(默认)：新消费者组从最后offset+1开始消费</span></span><br><span class="line"><span class="comment">* earliest：第一次从头，然后跟着offset，注意和seekBeginning区分</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">props.put(ConsumerConfig.AUTO_OFFSET_RESET_CONFIG, <span class="string">"earliest"</span>);</span><br></pre></td></tr></table></figure><h1 id="13-SpringBoot集成Kafka"><a href="#13-SpringBoot集成Kafka" class="headerlink" title="13. SpringBoot集成Kafka"></a>13. SpringBoot集成Kafka</h1><h2 id="13-1-基本配置"><a href="#13-1-基本配置" class="headerlink" title="13.1 基本配置"></a>13.1 基本配置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">//</span> <span class="string">依赖</span></span><br><span class="line"><span class="string">&lt;dependency&gt;</span></span><br><span class="line"><span class="string">&lt;groupId&gt;org.springframework.kafka&lt;/groupId&gt;</span></span><br><span class="line"><span class="string">&lt;artifactId&gt;spring-kafka&lt;/artifactId&gt;</span></span><br><span class="line"><span class="string">&lt;/dependency&gt;</span></span><br><span class="line">      </span><br><span class="line"><span class="string">//</span> <span class="string">配置</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line">  <span class="attr">kafka:</span></span><br><span class="line">    <span class="attr">bootstrap-servers:</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.249</span><span class="string">:9092,192.168.1.249:9093,192.168.1.249:9094</span></span><br><span class="line">    <span class="attr">producer:</span></span><br><span class="line">      <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line">      <span class="attr">batch-size:</span> <span class="number">16384</span> <span class="comment"># 16k</span></span><br><span class="line">      <span class="attr">buffer-memory:</span> <span class="number">33554432</span> <span class="comment"># 32M</span></span><br><span class="line">      <span class="attr">acks:</span> <span class="number">1</span></span><br><span class="line">      <span class="attr">key-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">      <span class="attr">value-serializer:</span> <span class="string">org.apache.kafka.common.serialization.StringSerializer</span></span><br><span class="line">    <span class="attr">consumer:</span></span><br><span class="line">      <span class="attr">group-id:</span> <span class="string">default-group</span></span><br><span class="line">      <span class="attr">enable-auto-commit:</span> <span class="literal">false</span></span><br><span class="line">      <span class="attr">auto-offset-reset:</span> <span class="string">earliest</span></span><br><span class="line">      <span class="attr">key-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">      <span class="attr">value-deserializer:</span> <span class="string">org.apache.kafka.common.serialization.StringDeserializer</span></span><br><span class="line">      <span class="attr">max-poll-records:</span> <span class="number">500</span></span><br><span class="line">    <span class="attr">listener:</span></span><br><span class="line">      <span class="comment"># TIME: 当一批poll()的数据被消费者Listener处理后，距离上次提交时间大于TIME时提交offset</span></span><br><span class="line">      <span class="comment"># COUNT: 当一批poll()的数据被消费者Listener处理后，处理record数量大于等于COUNT时提交offset</span></span><br><span class="line">      <span class="comment"># COUNT_TIME: 满足TIME或者COUNT</span></span><br><span class="line">      <span class="comment"># MANUAL: 当一批poll()的数据被消费者Listener处理后，手动调用acknowledge()提交offset</span></span><br><span class="line">      <span class="comment"># BATCH：当一批poll()数据被消费者Listener处理后，自动提交offset</span></span><br><span class="line">      <span class="comment"># record：当每一条记录被处理后，自动提交offset</span></span><br><span class="line">      <span class="attr">ack-mode:</span> <span class="string">MANUAL_IMMEDIATE</span> <span class="comment"># 手动调用acknowledge()后（处理一条消息后），提交offset</span></span><br></pre></td></tr></table></figure><h2 id="13-2-生产者"><a href="#13-2-生产者" class="headerlink" title="13.2 生产者"></a>13.2 生产者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/msg"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyKafkaController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String TOPIC_NAME = <span class="string">"memo-kafka-test"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> KafkaTemplate&lt;String, String&gt; kafkaTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/send"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sendMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        kafkaTemplate.send(TOPIC_NAME, <span class="string">"KEY"</span>, <span class="string">"this kafka sb test msg!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="13-3-消费者"><a href="#13-3-消费者" class="headerlink" title="13.3 消费者"></a>13.3 消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyConsumer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这里是一条条处理的，一次poll的消息有很多，这里一条条消费啦，thanks for springboot</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> record：收到的消息</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> ack: 针对手动提交很作用</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@KafkaListener</span>(topics = <span class="string">"memo-kafka-test"</span>, groupId = <span class="string">"memoGroup1"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenGroup</span><span class="params">(ConsumerRecord&lt;String, String&gt; record, Acknowledgment ack)</span> </span>&#123;</span><br><span class="line">        String value = record.value();</span><br><span class="line">        System.out.println(value);</span><br><span class="line">        System.out.println(record);</span><br><span class="line">        <span class="comment">// 手动提交offset</span></span><br><span class="line">        ack.acknowledge();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="13-4-消费者的详细配置"><a href="#13-4-消费者的详细配置" class="headerlink" title="13.4 消费者的详细配置"></a>13.4 消费者的详细配置</h1><h3 id="13-4-1-设置多主题，指定分区，指定offset，同组下的消费者个数（并发消费数）"><a href="#13-4-1-设置多主题，指定分区，指定offset，同组下的消费者个数（并发消费数）" class="headerlink" title="13.4.1 设置多主题，指定分区，指定offset，同组下的消费者个数（并发消费数）"></a>13.4.1 设置多主题，指定分区，指定offset，同组下的消费者个数（并发消费数）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">// 1个消费者，消费"memo-kafka-test"两个分区，"test"一个分区（并从offset=1开始消费） </span></span><br><span class="line"><span class="meta">@KafkaListener</span>(groupId = <span class="string">"memoGroup2"</span>, topicPartitions = &#123;</span><br><span class="line">           <span class="meta">@TopicPartition</span>(topic = <span class="string">"memo-kafka-test"</span>, partitions = &#123;<span class="string">"0"</span>, <span class="string">"1"</span>&#125;),</span><br><span class="line">           <span class="meta">@TopicPartition</span>(topic = <span class="string">"test"</span>, partitionOffsets = <span class="meta">@PartitionOffset</span>(partition = <span class="string">"0"</span>,initialOffset = <span class="string">"1"</span>))</span><br><span class="line">   &#125;, concurrency = <span class="string">"1"</span>)<span class="comment">// concurrency 就是同组下的消费者个数，就是并发消费数，建议小于等于分区总数</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">listenGroupPro</span><span class="params">(ConsumerRecord&lt;String, String&gt; record, Acknowledgment ack)</span> </span>&#123;</span><br><span class="line">       String value = record.value();</span><br><span class="line">       System.out.println(value);</span><br><span class="line">       System.out.println(record);</span><br><span class="line">       <span class="comment">// 手动提交offset</span></span><br><span class="line">       ack.acknowledge();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="13-4-2-一些有关Listener的配置"><a href="#13-4-2-一些有关Listener的配置" class="headerlink" title="13.4.2 一些有关Listener的配置"></a>13.4.2 一些有关Listener的配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">listener:</span></span><br><span class="line">  <span class="comment"># TIME: 当一批poll()的数据被消费者Listener处理后，距离上次提交时间大于TIME时提交offset</span></span><br><span class="line">  <span class="comment"># COUNT: 当一批poll()的数据被消费者Listener处理后，处理record数量大于等于COUNT时提交offset</span></span><br><span class="line">  <span class="comment"># COUNT_TIME: 满足TIME或者COUNT</span></span><br><span class="line">  <span class="comment"># MANUAL: 当一批poll()的数据被消费者Listener处理后，手动调用acknowledge()提交offset</span></span><br><span class="line">  <span class="comment"># BATCH：当一批poll()数据被消费者Listener处理后，自动提交offset</span></span><br><span class="line">  <span class="comment"># record：当每一条记录被处理后，自动提交offset</span></span><br><span class="line">  <span class="attr">ack-mode:</span> <span class="string">MANUAL_IMMEDIATE</span> <span class="comment"># 手动调用acknowledge()后（处理一条消息后），提交offset</span></span><br></pre></td></tr></table></figure><h1 id="14-Kafka集群Controller、Rebalance、HW和LEO"><a href="#14-Kafka集群Controller、Rebalance、HW和LEO" class="headerlink" title="14. Kafka集群Controller、Rebalance、HW和LEO"></a>14. Kafka集群Controller、Rebalance、HW和LEO</h1><h2 id="14-1-Controller"><a href="#14-1-Controller" class="headerlink" title="14.1 Controller"></a>14.1 Controller</h2><p>​    <strong>kafka启动的时候会先向zookeeper创建一个临时序号节点，获得的序号最小的那个broker作为集群的controller，</strong>负责管理整个集群中的所有分区和副本的状态：</p><ul><li>当某个分区的leader出现故障时，由controller负责为该分区选举新的leader副本</li><li>当检测到某个分区的ISR集合发生变化时（broker新增或减少），由controller负责通知所有broker更新其元数据信息</li><li>当使用kafka-topics.sh脚本为某个topic增加分区数量时，同样还是由controller通知其他broker</li></ul><h2 id="14-2-Rebalance"><a href="#14-2-Rebalance" class="headerlink" title="14.2 Rebalance"></a>14.2 Rebalance</h2><p>前提时：消费者没有指明分区消费。当消费组里的消费者和分区关系发生变化，那么就会触发rebalance机制。</p><p>这个机制会重新调整消费者消费哪个分区。</p><p>在触发rebalance机制之前，消费者消费哪个分区有三种策略：</p><ul><li>range：通过公式来计算某个消费者消费哪个分区</li><li>轮询：大家轮着消费</li><li>sticky：在触发了rebalance之后，在消费者消费的原分区不变的基础上进行调整</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;本博客整理了一些Kafka的基本概念和使用&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;自己用来当笔记的，故不需要图帮助理解&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;只有Java端的使用，C++端的以后可能会补上&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
      <category term="中间件" scheme="http://yoursite.com/categories/Java/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Kafka" scheme="http://yoursite.com/tags/Kafka/"/>
    
      <category term="中间件" scheme="http://yoursite.com/tags/%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>git用法浅析</title>
    <link href="http://yoursite.com/2021/09/01/git%E7%94%A8%E6%B3%95%E6%B5%85%E6%9E%90/"/>
    <id>http://yoursite.com/2021/09/01/git%E7%94%A8%E6%B3%95%E6%B5%85%E6%9E%90/</id>
    <published>2021-09-01T14:47:31.000Z</published>
    <updated>2021-09-29T02:42:48.575Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要记录git常见的基础用法以及如何离线在linux上安装git。</p><p>本文旨在让人成为git使用者而不是git使用专家，所有命令基本都是充分且必要的。</p><blockquote><ol><li>git是什么</li><li>linux离线安装git</li><li>git基本用法</li></ol></blockquote><a id="more"></a><h1 id="git是什么"><a href="#git是什么" class="headerlink" title="git是什么"></a>git是什么</h1><p>　　Git是目前世界上最先进的分布式<strong>版本控制</strong>系统。所谓版本控制，打个简单的比方：修改一份文件，我们往往会另存为很多个备份，每个备份可能代表一个版本，如图所示:</p><p><img src="/2021/09/01/git%E7%94%A8%E6%B3%95%E6%B5%85%E6%9E%90/multiDoc.png" alt></p><p>　这导致了两个严重的问题：第一，你不知道这些文件的每个版本都有谁改动过；第二，过了一段时间，你自己都不知道这些文件代表啥， <strong>但是你还不敢删。</strong>我们希望文件的管理是这样的：<strong>每次文件的改动都有相应的记录，不仅记录了是谁改了文件，还要有改动文件的说明</strong>，看起来就像这样。</p><p><img src="/2021/09/01/git%E7%94%A8%E6%B3%95%E6%B5%85%E6%9E%90/multiPerson.png" alt></p><p>　　简而言之，git就是干这活的，把每个文件都想这样管理起来，这样我们只需要保存两样东西：</p><ul><li>一份最新的文件</li><li>这份文件所有的历史改动信息</li></ul><p>　　<font color="red"><strong>这里说一下</strong></font>，git比svn好在哪里。</p><p>　　SVN是典型的集中式的版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。中央服务器就好比是一个图书馆，你要改一本书，必须先从图书馆借出来，然后回到家自己改，改完了，再放回图书馆。</p><p>　　那分布式版本控制系统与集中式版本控制系统有何不同呢？首先，分布式版本控制系统根本没有“中央服务器”，<strong>每个人的电脑上都是一个完整的版本库</strong>，这样，你工作的时候，就不需要联网了，因为版本库就在你自己的电脑上。既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</p><p>　　和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。而集中式版本控制系统的中央服务器要是出了问题，所有人都没法干活了。</p><p>　　在实际使用分布式版本控制系统的时候，其实很少在两人之间的电脑上推送版本库的修改，因为可能你们俩不在一个局域网内，两台电脑互相访问不了，也可能今天你的同事病了，他的电脑压根没有开机。因此，<strong>分布式版本控制系统通常也有一台充当“中央服务器”的电脑，但这个服务器的作用仅仅是用来方便“交换”大家的修改，没有它大家也一样干活，只是交换修改不方便而已</strong>。</p><p>　　而且git最有用的是其强大的分支管理，而SVN全在同一条分支上进行开发，非常混乱。</p><h1 id="linux离线安装git"><a href="#linux离线安装git" class="headerlink" title="linux离线安装git"></a>linux离线安装git</h1><p>　　啥都不说了，工作需要，一般情况用不到这种安装方式，这里记录一下，防止忘记。步骤如下：</p><ol><li><a href="https://git-scm.com/" target="_blank" rel="noopener">git官网</a>下载linux下git安装包(.tar.gz)，不要下载.rpm，因为公司电脑没有rpm。</li><li>安装步骤</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 解压: xxx自己换成下载的版本</span></span><br><span class="line">tar -zxvf git.xxx.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装路径: 自己选安装在哪，我给装的都是在/home/git</span></span><br><span class="line">cd git-xxx</span><br><span class="line">./configure --prefix=/home/git</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 配置环境变量</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 这里java自己配</span></span></span><br><span class="line">export GIT_HOME=/usr/local/git</span><br><span class="line">export PATH=$JAVA_HOME/bin:$PATH:$GIT_HOME/bin</span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 激活环境变量</span></span></span><br><span class="line">source /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 检查有没有装好</span></span><br><span class="line">git --version</span><br></pre></td></tr></table></figure><h1 id="git基本用法"><a href="#git基本用法" class="headerlink" title="git基本用法"></a>git基本用法</h1><h2 id="配置用户并生成公钥私钥"><a href="#配置用户并生成公钥私钥" class="headerlink" title="配置用户并生成公钥私钥"></a>配置用户并生成公钥私钥</h2><p>　　安装好git后第一件事就是把全局的<code>user</code>配置了，不然无法上传代码。</p><p>　　git基于ssh连接，配置公钥到远程仓库中可以省去认证。这里不讲怎么放，只讲怎么生成。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 配置用户</span></span><br><span class="line">git config --global user.name "xxx"</span><br><span class="line">git config --global user.email "xxx@yyy.com"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 输入命令后一路回车，公钥在 ~/.ssh 文件夹下</span></span><br><span class="line">ssh-keygen -t rsa -C "xxx@yyy.com"</span><br></pre></td></tr></table></figure><h2 id="git版本库"><a href="#git版本库" class="headerlink" title="git版本库"></a>git版本库</h2><p>　　每个人使用git的时候，会在项目中创建一个git版本库，这个库是实际可以理解为一个<code>.git</code>文件夹，git的所有操作，都是对这个<code>.git</code>文件夹进行修改。当我们用git来进行项目管理时，版本库会把这个项目分成三个区域，如图所示: </p><p><img src="/2021/09/01/git%E7%94%A8%E6%B3%95%E6%B5%85%E6%9E%90/gitRepo.png" alt></p><p>　　<strong>工作区就是我们的文件夹，暂存区(stage)和最终的提交区域就是我们的git版本库</strong>，这里的控制都是在<code>.git</code>中进行的，请注意区分工作区和版本库，这两个概念是不同的。图中<code>add、commit、HEAD</code>等下文再讲。看到这里我们应该清楚了一个git仓库的基本结构。</p><h3 id="创建git版本库"><a href="#创建git版本库" class="headerlink" title="创建git版本库"></a>创建git版本库</h3><p>　　命令：<code>git init</code>。这个命令可以创建一个纯净的git版本库，运行这个命令后，会在这个文件夹下生成一个<code>.git文件夹</code>，这说明你的这个文件夹可以开始被git管理了。<strong>这里值得注意的是</strong>，运行这个命令后，不管你的文件夹下有没有内容，<code>.git</code>初始化后始终是一个纯净的空仓库。    </p><p>我们可以通过<code>git status</code>命令来查看git版本库的情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br><span class="line">已初始化空的 Git 仓库于 /Users/memoforward/Project/<span class="built_in">test</span>/testgit/temp/.git/</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line">位于分支 master</span><br><span class="line">尚无提交</span><br><span class="line">无文件要提交（创建/拷贝文件并使用 <span class="string">"git add"</span> 建立跟踪）</span><br></pre></td></tr></table></figure><h3 id="把文件添加到版本库并提交"><a href="#把文件添加到版本库并提交" class="headerlink" title="把文件添加到版本库并提交"></a>把文件添加到版本库并提交</h3><p>先在工作区创建一个新文件.gitignore</p><p>通过<code>git add</code>将修改的内容从<code>工作区</code>添加到git版本库的<code>暂存区</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git add 文件名+后缀</span><br><span class="line"></span><br><span class="line">*********实例**********</span><br><span class="line">git add .gitignore</span><br><span class="line">git status</span><br><span class="line">位于分支 master</span><br><span class="line">尚无提交</span><br><span class="line">要提交的变更：</span><br><span class="line">  （使用 <span class="string">"git rm --cached &lt;文件&gt;..."</span> 以取消暂存）</span><br><span class="line">新文件：   .gitignore</span><br></pre></td></tr></table></figure><p>通过<code>git commit</code>将<code>暂存区</code>的内容提交到最终的区域，并添加提交说明</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">"提交说明"</span></span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">"添加gitignore"</span></span><br><span class="line">[master（根提交） c92669e] 添加.gitignore</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 .gitignore</span><br><span class="line"></span><br><span class="line">git status</span><br><span class="line">位于分支 master</span><br><span class="line">无文件要提交，干净的工作区</span><br></pre></td></tr></table></figure><p>此时我们的git项目就通过本地git仓库进行了管理</p><h2 id="回滚"><a href="#回滚" class="headerlink" title="回滚"></a>回滚</h2><p>　　我们可能不小心提交了一个错误的版本（即最新的版本存在问题），为了保证git仓库中最新的版本是稳定的，我们在短期内搞不定的情况，就要对版本进行回滚。</p><p>　　<strong>PS：</strong>其实在自己本地的库上影响不严重，但是在远程的库上若有这种问题，则情况就非常严重，因为一般情况下，远程库中的git就是线上的版本，线上出问题，一般很难定位。此时，回滚是一个兜底策略，非常重要。</p><h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>　　一个项目可能有很多人在进行开发，会进行成百上千次提交，每次提交就是一个版本，我们不可能记得住每个版本都修改了哪些内容，但是git能帮我们记住，只需要输入<code>git log</code> 就行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br><span class="line"><span class="comment"># 将日志一行显示，更加简洁，我喜欢加上这样的命令, 但是看不到作者信息了</span></span><br><span class="line">git <span class="built_in">log</span> --oneline </span><br><span class="line"></span><br><span class="line">3fc2d100b (HEAD -&gt; master, origin/master, origin/HEAD) <span class="built_in">enable</span> Github Action <span class="keyword">for</span> Unit <span class="built_in">test</span> (<span class="comment">#6726)</span></span><br><span class="line">a2a14dcb4 add short/byte data <span class="built_in">type</span> support <span class="keyword">for</span> PojoUtils<span class="comment">#getDefaultValue (#6551)</span></span><br><span class="line">b14e53443 fix boolean data <span class="built_in">type</span> issue <span class="keyword">for</span> Pojoutils.java<span class="comment">#getDefaultValue</span></span><br><span class="line">4a265a52b update dubbo-provider.xml <span class="keyword">for</span> demo (<span class="comment">#6857)</span></span><br><span class="line">1a3949ebb remove impossible reach branch and the useless variable <span class="keyword">for</span> RedisRegistry.java (<span class="comment">#6862)</span></span><br></pre></td></tr></table></figure><p>　　这个命令能让你看到所有的提交，<code>commit</code>后面可以理解为版本号，以下包括<strong>作者</strong>，<strong>提交时间</strong>以及<strong>提交说明</strong>。这就体现了每次提交都写提交说明的重要性，为了方便我们对每次版本进行查看。</p><p>　　当我们获取到了该一个git项目所有历史版本号之后，我们就可以把git提交区域的版本回退到特定历史。下面介绍回退版本的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^ <span class="comment"># 回退到上个版本</span></span><br><span class="line">git reset --hard HEAD^^ <span class="comment"># 回退到上上个版本</span></span><br><span class="line">git reset --hard HEAD~10 <span class="comment"># 回退到10个版本以前</span></span><br><span class="line">git reset  --hard commit_id <span class="comment"># 可以调到任意一个版本，可以回退可以前进</span></span><br></pre></td></tr></table></figure><p>　　git版本回退的原理是维护一个指向版本的指针，这个指针名叫HEAD，git保存的不是每次版本的文件，而是保存每次版本的修改，因此十分高效，如下图所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph BT</span><br><span class="line">subgraph table</span><br><span class="line">commit_id2 ---&gt; commit_id1</span><br><span class="line">commit_id3 ---&gt; commit_id2</span><br><span class="line">end</span><br><span class="line">HEAD((HEAD)) ---&gt; commit_id2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文主要记录git常见的基础用法以及如何离线在linux上安装git。&lt;/p&gt;
&lt;p&gt;本文旨在让人成为git使用者而不是git使用专家，所有命令基本都是充分且必要的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;git是什么&lt;/li&gt;
&lt;li&gt;linux离线安装git&lt;/li&gt;
&lt;li&gt;git基本用法&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式笔记</title>
    <link href="http://yoursite.com/2021/07/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/07/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-22T00:39:38.000Z</published>
    <updated>2021-07-22T05:56:34.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要对正则表达式的一些语法进行了一些记录，有机会长期补充一下：</p><blockquote><p>正则表达式基础语法</p></blockquote><a id="more"></a><h1 id="正则基础语法"><a href="#正则基础语法" class="headerlink" title="正则基础语法"></a>正则基础语法</h1><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>　　元字符用来对字符串进行简单的匹配。</p><div class="table-container"><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>.</code></td><td style="text-align:center">匹配除换行符以外的任意字符</td></tr><tr><td style="text-align:center"><code>\w</code></td><td style="text-align:center">匹配 字母、数字、下划线或汉汉字</td></tr><tr><td style="text-align:center"><code>\s</code></td><td style="text-align:center">匹配任意空白符</td></tr><tr><td style="text-align:center"><code>\d</code></td><td style="text-align:center">匹配数字</td></tr><tr><td style="text-align:center"><code>\b</code></td><td style="text-align:center">匹配单词的开始或结束</td></tr><tr><td style="text-align:center"><code>^</code></td><td style="text-align:center">匹配字符串的开始</td></tr><tr><td style="text-align:center"><code>$</code></td><td style="text-align:center">匹配字符串的结束</td></tr></tbody></table></div><p>　　例子：</p><ol><li>匹配有abc开头的字符串</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\babc或^abc</span><br></pre></td></tr></table></figure><ol><li>匹配3位数字</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d\d\d$</span><br></pre></td></tr></table></figure><ol><li>配7开头的3位数字</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^<span class="number">7</span>\d\d$</span><br></pre></td></tr></table></figure><h2 id="重复限定符"><a href="#重复限定符" class="headerlink" title="重复限定符"></a>重复限定符</h2><p>　　元字符规则匹配的一般是单个或固定多个字符的情况，这很笨重，有时候多个字符匹配的规则是一样的，这时候就需要用重重复限定符去进行一个匹配。</p><div class="table-container"><table><thead><tr><th style="text-align:center">重复限定符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center">重复任意次数，包括0次</td></tr><tr><td style="text-align:center"><code>+</code></td><td style="text-align:center">重复1次以上</td></tr><tr><td style="text-align:center"><code>?</code></td><td style="text-align:center">重复0次或1次</td></tr><tr><td style="text-align:center"><code>{n}</code></td><td style="text-align:center">重复n次</td></tr><tr><td style="text-align:center"><code>{n,}</code></td><td style="text-align:center">重复n次即以上</td></tr><tr><td style="text-align:center"><code>{n, m}</code></td><td style="text-align:center">重复n到m次之间都匹配</td></tr></tbody></table></div><p>　　用了重复限定符之后会优雅很多。</p><ol><li>匹配11位手机号，必须以1开头</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^<span class="number">1</span>\d&#123;<span class="number">10</span>&#125;$</span><br></pre></td></tr></table></figure><ol><li>匹配a开头，x结尾，中间是12-18位数字的字符串</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^a\d&#123;<span class="number">12</span>-<span class="number">18</span>&#125;x$</span><br></pre></td></tr></table></figure><ol><li>匹配a开头，0个或多个b结尾的字符串</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ab*$</span><br></pre></td></tr></table></figure><h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>　　使用括号来对一组字符进行匹配。</p><ol><li>匹配xy开头的任意数量的字符</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(xy)*$</span><br></pre></td></tr></table></figure><h1 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h1><p>　　防止正则符号和字符符号冲突。</p><ol><li>匹配任意数量(ab)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\(ab\)*</span><br></pre></td></tr></table></figure><h1 id="条件或和区间"><a href="#条件或和区间" class="headerlink" title="条件或和区间"></a>条件或和区间</h1><p>　　用<code>|</code>表示或，[]表示区间（[0-9][a-z][A-Z][156]等，<strong>[]只能匹配一个字符</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^((<span class="number">13</span>[<span class="number">0</span>-<span class="number">2</span>])|(<span class="number">15</span>[<span class="number">56</span>])|(<span class="number">18</span>[<span class="number">5</span>-<span class="number">6</span>])|<span class="number">145</span>|<span class="number">176</span>)\d&#123;<span class="number">8</span>&#125;$</span><br><span class="line">^(<span class="number">130</span>|<span class="number">131</span>|<span class="number">132</span>|<span class="number">155</span>|<span class="number">156</span>|<span class="number">185</span>|<span class="number">186</span>|<span class="number">145</span>|<span class="number">176</span>)\d&#123;<span class="number">8</span>&#125;$ <span class="comment">// 等价</span></span><br></pre></td></tr></table></figure><h1 id="前断言和后断言"><a href="#前断言和后断言" class="headerlink" title="前断言和后断言"></a>前断言和后断言</h1><p>　　先不写了，有点事，以后再说。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文主要对正则表达式的一些语法进行了一些记录，有机会长期补充一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;正则表达式基础语法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Java中的继承</title>
    <link href="http://yoursite.com/2021/07/19/Java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2021/07/19/Java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/</id>
    <published>2021-07-19T10:35:19.000Z</published>
    <updated>2021-07-20T03:50:14.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文主要针对一些比较模糊的问题进行总结：</p><ol><li>引用是父类，实例是子类</li><li>super和this</li></ol></blockquote><a id="more"></a><h1 id="父类和子类的引用情况"><a href="#父类和子类的引用情况" class="headerlink" title="父类和子类的引用情况"></a>父类和子类的引用情况</h1><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>　　父类的引用可以指向子类的对象（向上转型），子类引用不能指向父类对象。这个很好理解，子类实例化会执行父类的构造器，此时父类的属性已经在内存中了，使用父类的引用可以访问到父类的属性信息；但是父类实例化不会执行子类的构造器，因此内存中不会有子类的属性信息，使用子类的引用无法访问到子类的成员信息。这里有个口诀对于对象的类型：<strong>编译看左边，运行看右边，静态全看左</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Father f = <span class="keyword">new</span> Son(); <span class="comment">// ok</span></span><br><span class="line">Son s = <span class="keyword">new</span> Father(); <span class="comment">// 编译不通过</span></span><br><span class="line">Son ss = (Son)<span class="keyword">new</span> Father(); <span class="comment">// 编译通过，运行时抛出ClassCastException（类型转换异常）</span></span><br></pre></td></tr></table></figure><p>　　这里比较特殊的是，父类引用指向子类的对象，该引用<strong>只能</strong>调用父类定义的成员变量和成员方法（因为编译看左边），<font color="red"><strong>而在运行中，调用同名的成员变量会调用父类的成员变量，如果调用同名的成员方法（即重写的方法），则会调用子类的方法</strong></font>。这里很奇怪，既然运行看右边，为什么我访问的不是子类对象中同名的成员变量呢？</p><p>　　这和Java的运行机制有关，<font color="brown">Java中的<strong>成员变量、静态成员方法、private以及final方法都是静态绑定的</strong>，所谓静态绑定是指在编译期绑定，这时候引用<code>f</code>已经和父类的成员变量绑定了；而<strong>普通的成员方法是动态绑定的</strong>，也就是运行时绑定，此时引用<code>f</code>在调用方法的时候是访问的是子类方法表的地址</font>。也就是说，Java的多态是指在运行时多态，只是指普通成员方法的多态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">"父亲"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">"儿子"</span>;</span><br><span class="line">    <span class="keyword">public</span> String name2 = <span class="string">"儿子小名"</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Father f = <span class="keyword">new</span> Son();</span><br><span class="line">    System.out.println(f.name); <span class="comment">// 父亲</span></span><br><span class="line">    System.out.println(f.getName()); <span class="comment">//儿子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这里补充一下：虽然引用<code>f</code>无法直接调用子类的成员变量和父类没有的成员方法，但是在运行时，这些属性仍然是开辟了空间的，但是无法访问（主要是因为编译不过）。这里给出一个验证，我们知道反射是典型的在运行时可以操作对象的方式，这里通过反射在运行时强行去找<code>f</code>的成员变量，可以看到实际上<code>f</code>在运行时是一个子类的实例对象，通过反射可以访问到父类没有的变量或者方法（代码只写了变量），但是因为静态绑定了，所以直接通过<code>f.name</code>显示的是父亲的<code>name</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Father f = <span class="keyword">new</span> Son();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field field = f.getClass().getField(<span class="string">"name"</span>);</span><br><span class="line">        Field field2 = f.getClass().getField(<span class="string">"name2"</span>);</span><br><span class="line">        System.out.println(f.name); <span class="comment">// 父亲</span></span><br><span class="line">        System.out.println(f.getName()); <span class="comment">// 儿子</span></span><br><span class="line">        String name = (String)field.get(f); <span class="comment">// 儿子</span></span><br><span class="line">        String name2 = (String)field2.get(f); <span class="comment">// 儿子小名</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Super和This"><a href="#Super和This" class="headerlink" title="Super和This"></a>Super和This</h1><p>　　大家都知道两点：</p><ol><li>子类初始化会调用父类的构造器</li><li>子类中使用super可以调用父类的变量和方法（除了<code>private</code>修饰的）</li></ol><p>　　但是这里要强调一下，<font color="red"><strong>子类实例化不会创建父类的实例</strong></font>，调用父类的构造器只是在内存中开辟了父类属性的空间，也就是说和<code>this</code>不同，<code>super</code>并不指代一个对象。如果调用<code>super.hashcode()</code>就会发现结果和<code>this.hashcode()</code>的值一样，因为根本就没有父类对象，调用父类的<code>hashcode</code>和子类的<code>hashcode</code>得到的都是子类的<code>hashcode</code>，从这可以推导得出，就算是在父类的构造器中调用<code>this.hashcode()</code>得到的也是子类的<code>hashcode</code>。</p><p>　　<strong>总结一下</strong>就是：<code>super</code>只是一个标志，不指向任何对象，它能调用父类的构造器和方法，并不是说指向了父类对象，因为根本没有父类对象被创建。</p><p>　　另外，<code>hashcode</code>方法是运行时调用的，因此上述的结论和引用是不是子类类型并无关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写Son和Father</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类this.hashcode(): "</span> + <span class="keyword">this</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类this.hashcode(): "</span> + <span class="keyword">this</span>.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"子类super.hashcode(): "</span> + <span class="keyword">super</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Son s = <span class="keyword">new</span> Son();</span><br><span class="line">    System.out.println(<span class="string">"==========="</span>);</span><br><span class="line">    Father f = <span class="keyword">new</span> Son();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">父类<span class="keyword">this</span>.hashcode(): <span class="number">1554874502</span></span><br><span class="line">子类<span class="keyword">this</span>.hashcode(): <span class="number">1554874502</span></span><br><span class="line">子类<span class="keyword">super</span>.hashcode(): <span class="number">1554874502</span></span><br><span class="line">===========</span><br><span class="line">父类<span class="keyword">this</span>.hashcode(): <span class="number">1846274136</span></span><br><span class="line">子类<span class="keyword">this</span>.hashcode(): <span class="number">1846274136</span></span><br><span class="line">子类<span class="keyword">super</span>.hashcode(): <span class="number">1846274136</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　　Java继承主要就是要处理两个问题：一、什么东西是静态绑定的；二、子类实例化，会不会实例化一个父类对象？懂了这两个问题，所有问题都能推导出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文主要针对一些比较模糊的问题进行总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;引用是父类，实例是子类&lt;/li&gt;
&lt;li&gt;super和this&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java8特性lambda表达式笔记</title>
    <link href="http://yoursite.com/2021/07/19/Java8%E7%89%B9%E6%80%A7lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/07/19/Java8%E7%89%B9%E6%80%A7lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-19T00:38:48.000Z</published>
    <updated>2021-07-23T10:22:30.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文涉及以下知识：</p><ol><li>Lambda表达式基本概念</li><li>Lambda表达式语法</li><li>Lambda表达式实战：java.util.function</li><li>Stream 流的概念</li><li>Stream实战</li></ol></blockquote><a id="more"></a><h1 id="Lambda基本概念"><a href="#Lambda基本概念" class="headerlink" title="Lambda基本概念"></a>Lambda基本概念</h1><p>　　Java8的一个新特性就是引入了函数式接口。通常我们的方法的入参都是基本数据类型，或者是实例对象的引用，这在一定程度上限制了方法的多样性，因此Java引入了函数式编程，即<font color="red"><strong>在声明（构造器或者方法）时把一个函数接口当成入参</strong></font>。一般这样的入参在实际使用时，会用一个实现了该接口的类对象来传入，这种对象我们一般会写成匿名的，如下所示（声明一个线程）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口Runnable作为声明时的入参，在使用时使用一个匿名类来传入</span></span><br><span class="line">Thread td = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>　　这种匿名函数写起来很笨重，<strong>因此引入了Lambda表达式来简化匿名函数的定义</strong>，如果用Lambda表达式来声明上述<code>td</code>对象，则可以写成如下形式（两种写法的作用是完全一致的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread td = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"run"</span>));</span><br></pre></td></tr></table></figure><p>　　可以说，labmda表达式就是一种简洁的匿名类书写方式，用来增强代码的简洁性和可读性。</p><h1 id="Lambda表达式语法"><a href="#Lambda表达式语法" class="headerlink" title="Lambda表达式语法"></a>Lambda表达式语法</h1><h2 id="Lambda使用的条件"><a href="#Lambda使用的条件" class="headerlink" title="Lambda使用的条件"></a>Lambda使用的条件</h2><p>　　使用Lambda表达式来实现某个接口时，<strong>必须保证该接口只有一个抽象方法</strong>。如果该接口有两个或者两个以上的抽象方法，则无法使用Lambda。这里需要注意一点：因为Java8为接口加入了<code>default</code>和<code>static</code>方法，这两种方法不是抽象方法，是可以使用lambda的，如下例所示：</p><ul><li>可以使用Lambda的情况</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有一个抽象方法，可以用使用lambda</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">canUseLambda</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"log..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"perf..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InterA interA = () -&gt; System.out.println(<span class="string">"canUseLambda"</span>); <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><ul><li>不可以使用Lambda的情况</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canUseLambda</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cantUseLambda</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会报如下的错误：</p><p><img src="/2021/07/19/Java8%E7%89%B9%E6%80%A7lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/mutiAbstarct.png" alt></p><h2 id="Lambda-语法"><a href="#Lambda-语法" class="headerlink" title="Lambda 语法"></a>Lambda 语法</h2><p>　　Lambda语法很简单，完整写法就是<code>(参数列表) -&gt; {具体实现代码(有返回类型可以写return)}</code>。举个例子，假设有一个<code>Rectangle</code>接口，里面有一个抽象方法，接收两个参数，返回一个<code>double</code>;同时也有一个<code>Circle</code>接口，里面有一个方法，接收一个参数，返回一个<code>double</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>完整</strong>定义的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rectangle rect1 = (x, y) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Circle circle1 = (x) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>简化写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当具体实现代码只有一行的时候，不需要写大括号，如果有return，则省去return</span></span><br><span class="line">Rectangle rect2 = (x, y) -&gt; x * y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果入参只有一个，则入参的()也可以省略</span></span><br><span class="line">Circle circle2 = x -&gt; Math.sqrt(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果参数只有一个，而且调用的方法也只需要传入这个参数</span></span><br><span class="line"> Circle circle3 = Math::sqrt;</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rect1.cal(<span class="number">4.0</span>,<span class="number">5.0</span>); <span class="comment">// 20.0</span></span><br><span class="line">rect2.cal(<span class="number">4.0</span>, <span class="number">5.0</span>); <span class="comment">// 20.0</span></span><br><span class="line">circle1.cal(<span class="number">81.0</span>); <span class="comment">// 9.0</span></span><br><span class="line">circle2.cal(<span class="number">81.0</span>); <span class="comment">// 9.0</span></span><br><span class="line">circle3.cal(<span class="number">81.0</span>); <span class="comment">// 9.0</span></span><br></pre></td></tr></table></figure><h1 id="Lambda实战-java-util-function"><a href="#Lambda实战-java-util-function" class="headerlink" title="Lambda实战: java.util.function"></a>Lambda实战: java.util.function</h1><p>　　Lambda主要用在函数式编程里面，而Java8引入了一个新的包用来支持函数式编程，那就是<code>java.util.fuction</code>。</p><h2 id="java-util-function常用接口"><a href="#java-util-function常用接口" class="headerlink" title="java.util.function常用接口"></a>java.util.function常用接口</h2><p>接口文档可查看：<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="noopener">java.util.function接口文档</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">接口</th><th style="text-align:center">方法</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center"><code>Consumer&lt;T&gt;</code></td><td style="text-align:center"><code>void accept(T t)</code></td><td style="text-align:center">表示”消费者”，接收一个参数（一般用消费<code>t</code>来实现某个功能）</td></tr><tr><td style="text-align:center"><code>Supplier&lt;T&gt;</code></td><td style="text-align:center"><code>T get()</code></td><td style="text-align:center">表示”生产者”，不接收参数，返回一个值</td></tr><tr><td style="text-align:center"><code>Predicate&lt;T&gt;</code></td><td style="text-align:center"><code>bool test(T t)</code></td><td style="text-align:center">预测接口，提供一个参数，返回一个<code>bool</code>值</td></tr><tr><td style="text-align:center"><code>Function&lt;T, R&gt;</code></td><td style="text-align:center"><code>R apply(T t)</code></td><td style="text-align:center">接收一个参数<code>t</code>，返回一个值</td></tr></tbody></table></div><p>　　这里写个简单的例子，这些接口一般会经常用在<code>Stream</code>里，下一章会介绍这些方法的具体应用，这里写个简单的，方便理解。<font color="red"><strong>下列方法一个重要的理解方式就是：入参函数使用了另一个入参作为了参数，类方法又调用了入参函数。</strong></font></p><ul><li>定义一个类，使用上述接口作为参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoLambda</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">doSupply</span><span class="params">(Supplier&lt;T&gt; supplier)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doConsumer</span><span class="params">(T t, Consumer&lt;T&gt; consumer)</span> </span>&#123;</span><br><span class="line">        consumer.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">doPredicate</span><span class="params">(T t, Predicate&lt;T&gt; predicate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> predicate.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T, R&gt; <span class="function">R <span class="title">doFunction</span><span class="params">(T t, Function&lt;T, R&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function.apply(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用这些方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DoLambda d = <span class="keyword">new</span> DoLambda();</span><br><span class="line">    System.out.println(d.doSupply(() -&gt; <span class="string">"生产者提供的一个字符串"</span>));</span><br><span class="line">    d.doConsumer(<span class="string">"消费者要消费这个字符串"</span>, System.out::println);</span><br><span class="line">    d.doPredicate(<span class="string">"判断这个字符串的长度是否为10"</span>, x -&gt; x.length() == <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">boolean</span> flag = d.doPredicate(<span class="string">"判断这个字符串的长度是否为10"</span>, x -&gt; x.length() == <span class="number">10</span>);</span><br><span class="line">    System.out.println(flag);</span><br><span class="line">    Double a = d.doFunction(<span class="number">53.4</span>, x -&gt; &#123;</span><br><span class="line">        System.out.print(<span class="string">"计算53.4的平方: "</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.pow(x, <span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******输出如下*******/</span></span><br><span class="line">生产者提供的一个字符串</span><br><span class="line">消费者要消费这个字符串</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">计算<span class="number">53.4</span>的平方: <span class="number">2851.56</span></span><br></pre></td></tr></table></figure><h1 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h1><p>　　StreamAPI也是Java8引入的新特性，可以实现<font color="red">集合</font>的<strong>串行或者并行的流操作</strong>。这是Java8最实用的功能。<strong>这里说一个重要的，流只是操作，不改变原集合。</strong></p><ul><li><div id="person">创建流</div></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; stream1 = 集合&lt;T&gt;对象.stream() <span class="comment">// 串行流</span></span><br><span class="line">Stream&lt;T&gt; stream2 = 集合&lt;T&gt;对象.parallelStream() <span class="comment">// 并行流</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"yi"</span>, <span class="number">45</span>)); <span class="comment">// name, age</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"two"</span>, <span class="number">11</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"three"</span>, <span class="number">56</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"four"</span>, <span class="number">27</span>));</span><br><span class="line">        Stream&lt;Person&gt; stream = list.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>部分流操作</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">流操作</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>void forEach(Consumer&lt;? super T&gt; action)</code></td><td style="text-align:center">迭代这个集合中的每一个数据</td></tr><tr><td style="text-align:center"><code>Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code></td><td style="text-align:center">把集合中的每一个T类型数据映射成R类型数据，<strong>返回一个R类型的流</strong></td></tr><tr><td style="text-align:center"><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></td><td style="text-align:center">对集合中每一个数据进行筛选，筛出符合条件的数据(true)，并返回一个流</td></tr><tr><td style="text-align:center"><code>Stream&lt;T&gt; limit(long maxSize)</code></td><td style="text-align:center">获取指定数量的流，数量为maxSize（串行有序，并行无序）</td></tr><tr><td style="text-align:center"><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code></td><td style="text-align:center">累加器，两两相加，最后返回一个Optional容器（Optional是为了防止空指针，用<code>容器对象.get()</code>得到T，关于BinaryOperator去看<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="noopener">文档</a>）</td></tr><tr><td style="text-align:center"><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></td><td style="text-align:center">有初始值的累加，因为有初始值，所以不会出现空指针，直接返回T</td></tr><tr><td style="text-align:center"><code>Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)</code></td><td style="text-align:center">对集合类进行排序，传入一个比较器，返回一个流对象</td></tr><tr><td style="text-align:center"><code>Object[] toArray() 和 collect(Collectors.toList())</code></td><td style="text-align:center">对流进行数组或集合类型的转化</td></tr></tbody></table></div><h1 id="Stream实战"><a href="#Stream实战" class="headerlink" title="Stream实战"></a>Stream实战</h1><p><a href="#person">以上</a>写了一个<code>Person</code>的列表，要求用流分别实现如下功能：</p><ol><li><p>将人的按照年龄大小排序并打印</p></li><li><p>筛选出年龄小于50的并打印</p></li><li><p>打印出总年龄</p></li><li><p>打印前3个人</p></li><li><p>把每个人的年龄加100，并打印</p></li><li><p>将所有的人映射到一个Map集合里面，key是名字，value是年龄</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"====问题1===="</span>);</span><br><span class="line">list.stream().sorted((o1, o2) -&gt; o1.getAge() - o2.getAge()).forEach(Person::print);</span><br><span class="line">System.out.println(<span class="string">"====问题2===="</span>);</span><br><span class="line">list.stream().filter(p -&gt; p.getAge() &lt; <span class="number">50</span>).forEach(Person::print);</span><br><span class="line">System.out.println(<span class="string">"====问题3===="</span>);</span><br><span class="line">System.out.println(list.stream().mapToInt(Person::getAge).reduce(Integer::sum).orElse(-<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">"====问题4===="</span>);</span><br><span class="line">list.stream().limit(<span class="number">3</span>).forEach(Person::print);</span><br><span class="line">System.out.println(<span class="string">"====问题5===="</span>);</span><br><span class="line">list.forEach(p -&gt; p.setAge(p.getAge() + <span class="number">100</span>));</span><br><span class="line">list.forEach(Person::print);</span><br><span class="line">System.out.println(<span class="string">"====问题6===="</span>);</span><br><span class="line">Map&lt;String, Integer&gt; map = list.stream().collect(Collectors.toMap(Person::getName, Person::getAge));</span><br><span class="line"><span class="keyword">for</span>(String key: map.keySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"姓名："</span> + key + <span class="string">"  年龄："</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">====问题<span class="number">1</span>====</span><br><span class="line">姓名：two  年龄：<span class="number">11</span></span><br><span class="line">姓名：four  年龄：<span class="number">27</span></span><br><span class="line">姓名：yi  年龄：<span class="number">45</span></span><br><span class="line">姓名：three  年龄：<span class="number">56</span></span><br><span class="line">====问题<span class="number">2</span>====</span><br><span class="line">姓名：yi  年龄：<span class="number">45</span></span><br><span class="line">姓名：two  年龄：<span class="number">11</span></span><br><span class="line">姓名：four  年龄：<span class="number">27</span></span><br><span class="line">====问题<span class="number">3</span>====</span><br><span class="line"><span class="number">139</span></span><br><span class="line">====问题<span class="number">4</span>====</span><br><span class="line">姓名：yi  年龄：<span class="number">45</span></span><br><span class="line">姓名：two  年龄：<span class="number">11</span></span><br><span class="line">姓名：three  年龄：<span class="number">56</span></span><br><span class="line">====问题<span class="number">5</span>====</span><br><span class="line">姓名：yi  年龄：<span class="number">145</span></span><br><span class="line">姓名：two  年龄：<span class="number">111</span></span><br><span class="line">姓名：three  年龄：<span class="number">156</span></span><br><span class="line">姓名：four  年龄：<span class="number">127</span></span><br><span class="line">====问题<span class="number">6</span>====（顺序是随机的）</span><br><span class="line">姓名：yi  年龄：<span class="number">145</span></span><br><span class="line">姓名：four  年龄：<span class="number">127</span></span><br><span class="line">姓名：three  年龄：<span class="number">156</span></span><br><span class="line">姓名：two  年龄：<span class="number">111</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　　本章内容主要介绍了一下Lambda表达式，同时稍微介绍了一点StreamAPI的知识，这部分知识不难，主要难在架构设计，希望以后我忘记这部分内容的时候能够通过这篇文章回想起来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文涉及以下知识：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Lambda表达式基本概念&lt;/li&gt;
&lt;li&gt;Lambda表达式语法&lt;/li&gt;
&lt;li&gt;Lambda表达式实战：java.util.function&lt;/li&gt;
&lt;li&gt;Stream 流的概念&lt;/li&gt;
&lt;li&gt;Stream实战&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>限流工具RateLimiter和Semaphore解析</title>
    <link href="http://yoursite.com/2020/10/30/%E9%99%90%E6%B5%81%E5%B7%A5%E5%85%B7RateLimiter%E5%92%8CSemaphore/"/>
    <id>http://yoursite.com/2020/10/30/%E9%99%90%E6%B5%81%E5%B7%A5%E5%85%B7RateLimiter%E5%92%8CSemaphore/</id>
    <published>2020-10-30T03:19:09.000Z</published>
    <updated>2020-11-02T08:34:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文主要介绍限流工具RateLimiter和Semaphore</p><ol><li>RateLimiter介绍</li><li>Semaphore</li><li>使用场景分析</li></ol></blockquote><a id="more"></a><h1 id="RateLimiter"><a href="#RateLimiter" class="headerlink" title="RateLimiter"></a>RateLimiter</h1><h2 id="RateLimiter原理简介"><a href="#RateLimiter原理简介" class="headerlink" title="RateLimiter原理简介"></a>RateLimiter原理简介</h2><p>　　RateLimiter是谷歌出品的一个限流工具，使用令牌桶策略进行限流。所谓令牌桶策略，直观上来看就是：规定桶里最多能放N个令牌，如果桶没满，则按照一定的速率（可以是匀速，也可以是变速）往桶里追加令牌，如果有线程打到了这个实例上，则会拿走一个或多个令牌，如果没有令牌可以拿，就会阻塞几秒，直到可以拿到令牌为止。</p><p>　　这种原理很好理解，有点类似小时候”浴缸一边加水一边放水“的感觉，但同时这个如果按照这个理解去实现这个RateLimiter的话，会出现很多的问题，比如”我们如何实现每秒钟往桶里放令牌呢？“，上面的思路实现就会是：这个类会始终启动一个线程无时无刻去放令牌。这种做法显然会造成极大的资源浪费。在下一小节，我将针对RateLimiter的部分源码来解释一下谷歌对于限流的实现。</p><h2 id="RateLimiter源码解析"><a href="#RateLimiter源码解析" class="headerlink" title="RateLimiter源码解析"></a>RateLimiter源码解析</h2><p>　　 先说结论：RateLimiter本身不会自启一个线程去往桶里放令牌，<strong>放令牌的数量是基于时间的</strong>，RateLimiter中会<font color="brown"><strong>记录下一个请求从何时（记为x）开始才能获取到令牌</strong></font>，根据当前请求的时间（y）和x作比较，如果x &lt; y，则一定可以获得令牌（可预支），然后根据其申请的令牌数计算下次可以获取到令牌的具体时间；如果x &gt; y，则说明目前是桶中是没有令牌的，则会计算出线程获得令牌需要等待的时间（t），同时也会进一步更新，线程将沉睡t时间后再去执行方法。</p><p><strong>这里有两点需要注意：</strong></p><ol><li><strong>线程获取令牌这个操作是串行的，不会出现两个线程同时争夺同一块令牌的情况;</strong></li><li><strong>同时，如果桶中只有10个令牌，我的请求需要20个令牌，我是可以立刻获取到这些令牌并执行方法的，但是下一个请求将会等待这多出来的生产10个令牌的时间。</strong>这里给出谷歌官方文档的原文: It is important to note that the number of permits requested <em>never</em> affects the throttling of the request itself (an invocation to <code>acquire(1)</code> and an invocation to <code>acquire(1000)</code> will result in exactly the same throttling, if any), but it affects the throttling of the <em>next</em> request. I.e., if an expensive task arrives at an idle RateLimiter, it will be granted immediately, but it is the <em>next</em> request that will experience extra throttling, thus paying for the cost of the expensive task.</li></ol><p>　　下面我先介绍一下<code>RateLimiter</code>类的一些基本概念。<code>RateLimiter</code>是一个抽象的基类，自身是不含有成员变量的，仅包含了一些通用的方法，具体参数的定义都放在了它的子类<code>SmoothRateLimiter</code>中，这个类又派生出了两个”限流桶“的实现内部类，分别是：<code>SmoothBursty</code>类和<code>SmoothWarmingUp</code>类。前者是恒定速率生产令牌的”限流桶“，后者是变速生产令牌的桶（类似于TCP的慢开始策略）。本文因为篇幅限制，仅介绍实现稍微简单一些的<code>SmoothBursty</code>类。</p><ul><li>上面讲到，”限流桶“其中一个实现类是SmoothBursty，下表列出了这个类的<strong>核心参数</strong>和含义。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">参数含义</th></tr></thead><tbody><tr><td style="text-align:center"><font color="orange">double </font><font color="purple">storedPermits</font></td><td style="text-align:center">当前存储的令牌数量</td></tr><tr><td style="text-align:center"><font color="orange">double </font> <font color="purple">maxPermits</font></td><td style="text-align:center">允许存储的最大令牌数量 =<font color="purple"> maxBurstSeconds * permitsPerSecond</font></td></tr><tr><td style="text-align:center"><font color="orange">double </font> <font color="purple">stableIntervalMicros</font></td><td style="text-align:center">稳定生产一个令牌所用的时间（微秒）</td></tr><tr><td style="text-align:center"><font color="orange">private long </font> <font color="purple">nextFreeTicketMicros</font></td><td style="text-align:center">下次可以获取到令牌的具体时间，如果当前时间小于这个时间，则不能获取</td></tr><tr><td style="text-align:center"><font color="orange">final double </font> <font color="purple">maxBurstSeconds</font></td><td style="text-align:center">桶中可以放几秒的限值（默认是一秒，可以用来应对突发的大流量）</td></tr></tbody></table></div><p>　　接下来，我将介绍一下RateLimiter类的几个核心方法：</p><ul><li><font color="green">RateLimiter.create(double permitsPerSecond)</font>这个方法会生成一个匀速产生令牌的”限流桶”：<font color="blue">SmoothBursty</font>。这个函数没什么好讲的，主要就是将以上的参数都给赋值，尤其是把 <font color="purple">storedPermits</font>给填满。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// created方法是RateLimiter类的方法，核心是setRate，限流器核心参数的赋值都是基于我们设置的permitsPerSecond</span></span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, SleepingStopwatch stopwatch)</span> </span>&#123;</span><br><span class="line">    RateLimiter rateLimiter = <span class="keyword">new</span> SmoothBursty(stopwatch, <span class="number">1.0</span> <span class="comment">/* maxBurstSeconds */</span>);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// setRate方法在下层有两个操作，其中一个是用来给stableIntervalMicros赋值，另一个用来调整maxPermits和stroedPermits</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 核心方法，根据时间来更新令牌数</span></span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="comment">// 这个很好理解</span></span><br><span class="line">    <span class="keyword">double</span> stableIntervalMicros = SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;</span><br><span class="line">    <span class="keyword">this</span>.stableIntervalMicros = stableIntervalMicros;</span><br><span class="line">    doSetRate(permitsPerSecond, stableIntervalMicros);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> stableIntervalMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> oldMaxPermits = <span class="keyword">this</span>.maxPermits;</span><br><span class="line">    maxPermits = maxBurstSeconds * permitsPerSecond;</span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">      <span class="comment">// if we don't special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">      storedPermits = maxPermits;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 防止更新了桶的大小后，令牌数超标的情况</span></span><br><span class="line">      storedPermits =</span><br><span class="line">          (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">              ? <span class="number">0.0</span> <span class="comment">// initial state</span></span><br><span class="line">              : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码中有一个核心的方法：<font color="red">resync(nowMicros)</font>。这个方法将根据目前线程的请求时间和上一次请求所间隔的时间，来计算出这段时间中桶中生产了多少个令牌，并更新这个桶中的令牌数量，这个方法是RateLimiter实现添加加令牌操作的基础方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// if nextFreeTicket is in the past, resync to now</span></span><br><span class="line">  <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">    <span class="comment">// 计算出这段时间内，一共可以生产多少令牌</span></span><br><span class="line">    <span class="comment">// coolDownIntervalMicros()对于SmoothBurst而言一直是stableIntervalMicros</span></span><br><span class="line">    <span class="keyword">double</span> newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class="line">    <span class="comment">// 添加令牌, 如果桶空闲了，令牌数是可以填满的</span></span><br><span class="line">    storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">    <span class="comment">// 目前下一次获取令牌的时间是当前请求的时间，因为进到这个方法里表示请求一定可以拿到令牌（下面的方法会讲，RateLimiter可以预约令牌）</span></span><br><span class="line">    nextFreeTicketMicros = nowMicros;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><font color="green">RateLimiter.acquire(int permits)</font>：这个方法是从桶中拿走permits个令牌，入参可不写，默认拿走一个令牌，返回可以获得令牌等待了多长时间。如果不能够取得足够数量的令牌，则线程会阻塞一段时间，然后再尝试获取。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 核心方法，意思为”预定“，每个线程都会去申请这个令牌的获取，返回需要等待的时间</span></span><br><span class="line">  <span class="keyword">long</span> microsToWait = reserve(permits);</span><br><span class="line">  <span class="comment">// 线程根据等待的时间进行阻塞</span></span><br><span class="line">  stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// reserve操作加了锁，保证线程不会争夺同一块令牌</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">  checkPermits(permits);</span><br><span class="line">  <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">    <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没什么好讲的，这个就是在计算需要等的时间</span></span><br><span class="line"><span class="comment">// reserveEarliestAvailable计算了当前请求能够拿到令牌的系统时间，如果是future就会阻塞，不是future就是0，表示立刻就能拿到</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveAndGetWaitLength</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> momentAvailable = reserveEarliestAvailable(permits, nowMicros);</span><br><span class="line">  <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体限流桶的方法，两种限流桶不太一样（主要是因为生成的速率不一样，思路是一样的）</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveEarliestAvailable</span><span class="params">(<span class="keyword">int</span> requiredPermits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据时间间隔计算桶中当前应该有多少令牌，更新一下stroedPermits，并把nextFreeTicketMicros和当前时间同步</span></span><br><span class="line">  resync(nowMicros);</span><br><span class="line">  <span class="comment">// 进到这个方法，不管桶中令牌够不够都不会阻塞，如果不够，多余的开销由下一次请求承担，所以直接直接返回当前的时间，表示线程不会阻塞</span></span><br><span class="line">  <span class="keyword">long</span> returnValue = nextFreeTicketMicros;</span><br><span class="line">  <span class="comment">// 计算需要至多能从桶中拿多少的令牌</span></span><br><span class="line">  <span class="keyword">double</span> storedPermitsToSpend = min(requiredPermits, <span class="keyword">this</span>.storedPermits);</span><br><span class="line">  <span class="comment">// 计算预支的令牌数</span></span><br><span class="line">  <span class="keyword">double</span> freshPermits = requiredPermits - storedPermitsToSpend;</span><br><span class="line">  <span class="comment">// 计算额外的开销</span></span><br><span class="line">  <span class="keyword">long</span> waitMicros =</span><br><span class="line">      storedPermitsToWaitTime(<span class="keyword">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">          + (<span class="keyword">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line">  <span class="comment">// 额外的开销将会更新到”下次可以获取到令牌的具体时间“，如果额外开销很大</span></span><br><span class="line">  <span class="comment">// 这个时间就会是很遥远的future，下次请求阻塞的时间就越长</span></span><br><span class="line">  <span class="keyword">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);</span><br><span class="line">      <span class="comment">// 如果”预支“了，storedPermits就会清零</span></span><br><span class="line">  <span class="keyword">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class="line">  <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RateLimiter总结"><a href="#RateLimiter总结" class="headerlink" title="RateLimiter总结"></a>RateLimiter总结</h2><p>　　RateLimiter是用来进行QPS限流的，请求获取令牌但不释放令牌，同时线程在获取令牌时是串行的，保证了限流数量的一致性。当有操作量大的线程一下子获取了多余的令牌后，RateLimter会使用预支的方式保证这个请求能够顺利响应，同时也不会影响到限流的可靠性，因为多余的开销会由下一次请求承担。同时RateLimiter桶在空闲时会将令牌先塞满桶，这样当在QPS突然非常高的时候（从空闲状态突然变高），RateLimiter可以短时间处理高于限值的请求数，等桶中令牌消耗完了，QPS就会趋于限值并稳定下来。但是RateLimiter获取令牌的操作是用sychronize实现的，因此其无法保证公平性。</p><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><h2 id="Semaphore简介"><a href="#Semaphore简介" class="headerlink" title="Semaphore简介"></a>Semaphore简介</h2><p>　　Semaphore是J.U.C提供的共享锁，名为”信号量”。这个策略比较直观，控制最大并发数，维护一个”信号量“记录当前可用并发量（同样用令牌数来表示信号量的数值），请求要执行操作需要获取<strong>一个</strong>令牌，方法执行结束后需要释放这个令牌。但信号量为0时（令牌数为0），则线程会进一个等待链表（<strong>head是个虚拟头结点，以下说的链表头都指head.next</strong>），进链表后这个线程机会阻塞，直到某个线程释放了令牌，这个释放了令牌的线程会唤醒处在链表头的线程，然后这个线程再去尝试获取令牌。　</p><h2 id="Semaphore源码解析"><a href="#Semaphore源码解析" class="headerlink" title="Semaphore源码解析"></a>Semaphore源码解析</h2><p>　　Semaphore主要是通过一个抽象的内部类Sync的两个子类：NonfairSync和FairSync（公平锁和非公平锁）来实现相关功能。这两个类的实现功能是一样的，就是线程获取令牌的公平性问题：进入等待的线程会形成一个链表，每个线程在忙循环中都会尝试去获取令牌，FairSync保证了只有链表头的线程才能够获取到最新的空闲令牌。</p><ul><li>Sync类继承了AbstractQueuedSynchronizer（AQS）类，这个类中有实现功能的核心参数</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">参数含义</th></tr></thead><tbody><tr><td style="text-align:center"><font color="orange">private volatile int</font> <font color="purple">state</font></td><td style="text-align:center">可用的令牌数量（设置的最大并发数），所有的操作都会基于这个值</td></tr><tr><td style="text-align:center"><font color="orange">static final</font> <font color="brown">class Node</font></td><td style="text-align:center">等待线程的链表</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">Node类核心参数</th><th style="text-align:center">参数含义</th></tr></thead><tbody><tr><td style="text-align:center"><font color="orange">volatile</font> <font color="brown">Thread thread</font></td><td style="text-align:center">每一个node与当前线程绑定</td></tr><tr><td style="text-align:center"><font color="orange">volatile int</font> <font color="purple">waitStatus</font></td><td style="text-align:center">记录这个Node的状态，比如cancelled</td></tr></tbody></table></div><p> Semaphore最核心的两个操作是acquire()和release()，下面将针对NonFairSync和FairSync详细介绍一下这两个方法。</p><ul><li>acquire()：这个方法会尝试获取一个令牌，对中断敏感，如果线程中断了，则会抛出异常（还有一个acquireUninterruptibly方法，对中断不敏感，这里不介绍了）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 去获取一个令牌</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取令牌的具体实现</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// tryAcquireShared 尝试获取令牌，返回获取后剩余的令牌数量，&lt;0则表示无法获取令牌</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// NonfairSync版本tryAcquireShared</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这个循环是为了配合CAS</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 可用的令牌数</span></span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="comment">// 剩余令牌数</span></span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="comment">// 根据java特性，如果剩余令牌数 &lt; 0，就不会执行后面的CAS操作</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// FaieSync版本tryAcquireShared</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 主要就是加了个这个判断，如果等待链表为空，或者当前线程在等待链表的开头（head.next），则可以获取</span></span><br><span class="line">            <span class="comment">// 这避免了新来的线程”插队“</span></span><br><span class="line">            <span class="comment">// 因为在多线程的情况下，即使有了等待队列，available也可能会大于0</span></span><br><span class="line">            <span class="comment">// 此时新来的线程在非公平的情况下，可能会绕过链表直接获取到令牌</span></span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">               <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果tryAcquire的值小于0了，则会执行doAcquireSharedInterruptibly方法来将执行忙循环</span></span><br><span class="line"><span class="comment">// 不停地去请求获取令牌,这个方法对于公不公平没有区分</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 当前请求第一次进来会在等待链表后面添加一个node</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="comment">// 默认这个请求最终能获取令牌</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 线程被唤醒后再次去尝试获取令牌，获取不到就继续被阻塞</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 查询这个node的prev</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 如果这个prev是head再去尝试获取令牌（</span></span><br><span class="line">                <span class="comment">// 等待列表是有序的，只有链表的头（head.next）才有资格去尝试获取令牌，也只有链表头会被唤醒）</span></span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// 公平锁可以保证这个线程一定可以获取到令牌，非公平锁不能保证</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 重新设置链表头</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">// shouldParkAfterFailedAcquire: 重组链表，清除无效节点</span></span><br><span class="line">                <span class="comment">// parkAndCheckInterrupt: 将当前线程挂起，同时检测中断</span></span><br><span class="line">                <span class="comment">// 如果中断则捕获异常（这里多嘴一句，内部用了LockSupport.park()来阻塞线程</span></span><br><span class="line">                <span class="comment">// 这个方法自己不能捕获中断，所以我们不能try..catch）</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                <span class="comment">// 放弃获取令牌，将node的状态置为cancelled</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// setHeadAndPropagate比想象中复杂</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        <span class="comment">// 重新设置链表头</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="comment">// 如果下一个节点为空，或者节点是共享模式（只有虚拟head是独占的，其他node都是共享模式），则尝试唤醒线程</span></span><br><span class="line">            <span class="comment">// s == null 的时候一定不会唤醒后继节点，感觉有点多余</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                <span class="comment">// 尝试唤醒线程，在release方法里详细写</span></span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>这里注意一下，tryAcquireShared在AQS也有带有超时阻塞的重载方法tryAcquireSharedNanos(int arg, long nanosTimeout)，当线程请求超时，直接退出自旋，但是其在Semaphore中没有使用。</strong></p><ul><li>release()：释放令牌，这个操作没有特别大的学问。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去释放一个令牌</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放的具体实现</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试去释放令牌，tryReleaseShared已经增加了令牌数</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 释放成功，唤醒链表头的线程</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这个函数比较难懂，最主要的原因就是在共享模式下</span></span><br><span class="line"><span class="comment">// 线程获取令牌和释放令牌都会尝试去唤醒下一个线程，所以这个函数加了一些if判断防止线程被重复唤醒，却没有唤醒应该唤醒的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// SIGNAL表示下一个线程需要被唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 这个函数在唤醒线程</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; <span class="comment">// 0表示dump状态，链表刚刚初始化</span></span><br><span class="line">                     <span class="comment">// PROPAGATE表示线程已经被唤醒，如果交换成功，则跳出if</span></span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) </span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果同时有线程获取和释放了锁，这里的head可能改变，需要重新唤醒后继线程</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore总结"><a href="#Semaphore总结" class="headerlink" title="Semaphore总结"></a>Semaphore总结</h2><p>　　Semaphore本质上一个基于AQS的共享锁，说到底还是一个锁的模式，如果锁没有释放，其他线程就得一直阻塞或者超时返回。一个非常直观的应用场景可以是数据库的连接，可以控制最大的并发数在1000，只要连接不断开，其他线程就无法访问数据库。</p><h1 id="Semaphore和RateLimiter的区别"><a href="#Semaphore和RateLimiter的区别" class="headerlink" title="Semaphore和RateLimiter的区别"></a>Semaphore和RateLimiter的区别</h1><h2 id="原理上的区别"><a href="#原理上的区别" class="headerlink" title="原理上的区别"></a>原理上的区别</h2><p>　　Semaphore限制了服务的最大并发量，并提供了等待队列来阻塞线程，当有令牌可用时会唤醒队列中的线程，队列中线程通过自旋的策略来保证自动获取令牌；而RateLimiter则是限制了QPS，本质上是对速率的一种控制。RateLimiter可能对服务器的CPU造成更大的压力，但也保证了很高的处理效率，因为其只控制在1秒内最多能有多少请求访问资源，但是不会管这个请求会占用资源多久：如果某个请求会占用这个服务2秒，我们限制了QPS为100，则这个服务最大并发量可能会有200。</p><h2 id="使用场景上的区别"><a href="#使用场景上的区别" class="headerlink" title="使用场景上的区别"></a>使用场景上的区别</h2><p>大多数场景下，限制QPS和限制并发量的场景都是互通的，限制的并发量。</p><ul><li>如果请求的平均响应时间是不确定的，那么建议控制并发量来保证服务器不会受到太大的压力；</li><li>其他情况建议使用限制QPS的限流器：<ul><li>从两种种工具的实现上来看，Semaphore通过阻塞唤醒机制来控制线程，默认情况下线程被唤醒后不一定能够获取到令牌，从而又会重新进入阻塞状态，同时每次自旋都会重新处理等待链表也比较消耗资源，而RateLimiter会计算线程阻塞的时间，到时间自动唤醒，没有自旋，也没有额外开销，比Semaphore开销小。</li><li>从应对突发请求来看，Semaphore没有机制来应对，突发的大流量可能直接使等待链表变得超级大，<strong>而RateLimiter可以通过”令牌空闲累积“以及“预支”的策略来保证1秒的内的实际请求量可能临时大于限值，等桶中令牌消耗完了就会趋于稳定，稳定在我们限制的QPS中</strong>，这样在一定程度上保证了服务的可用性<strong>。</strong></li></ul></li></ul><h1 id="关于并发数和QPS的思考"><a href="#关于并发数和QPS的思考" class="headerlink" title="关于并发数和QPS的思考"></a>关于并发数和QPS的思考</h1><p>　　  这里先明确一个概念，在实际的业务场景中，QPS是稳定的，影响服务器性能的主要是并发数，试想一下如果我们服务的响应时间特别短，在某一个时刻我们预期的并发数会很低，不会对服务器造成很大的压力，符合逻辑；如果时延很高，这就表示我们的服务链出了问题，这样系统在某个时刻的并发数就会很高，因为时延高会导致某些线程迟迟不释放系统资源。这也是符合逻辑的。</p><p> 　　根据以上逻辑，这套QPS和并发量的转换公式就是：$QPS = 1000 / t <em> C$。$t$表示服务的平均响应时延，$C$表示该服务在这个QPS下的最大并发量。在使用Semaphore中，我们将会进行单机的并发数限流，通过上面的公式，我们可以对并发数的控制有一个相应的预期，<em>*在控制并发数的前提下，服务的稳定性会影响QPS（默认在限流生效的情况下），</em></em>如果服务时延降低，QPS预期会提高，如果服务时延提高，对应的QPS就会下降；我建议对被限流的请求进行打点统计，因为在限制并发数的前提下，QPS的降低不一定是用户侧的问题，也可能是服务稳定性的问题，比如网络的波动也会导致QPS降低。</p><p>　　举个简单的例子：某个服务的QPS有15W，平均请求时延为40ms，部署了600个实例。</p><p>　　这就是说，我们平时对这个服务的QPS期望不超过15W，单机平均QPS为：$Q = 150000 / 600 = 250$; 此时如果用Semaphore限流，设置的最大并发数为: $C = 250 * 40 / 1000 = 10$。也就是说，如果服务的时延稳定在40ms，理论上最大设置10个并发就能满足15WQPS的需要。</p><p>　　日常使用的时候，用RateLimiter可能更加直观，但是RateLimiter有一个问题：在满额QPS在跑的时候，如果服务可用性下降，请求时延陡增，系统的并发数也会陡增，导致严重的后果。因此，如果使用RateLimiter，建议对服务的请求时延做一个监控，当时延超过一定的阈值的时候，对服务降级处理，防止对服务器产生过大的压力。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://guava.dev/releases/snapshot-jre/api/docs/" target="_blank" rel="noopener">Google Guava API DOCS</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">Java8 API DOCS</a></li><li><a href="https://www.django-rest-framework.org/api-guide/throttling/" target="_blank" rel="noopener">DRF框架 Throttling API DOCS</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文主要介绍限流工具RateLimiter和Semaphore&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RateLimiter介绍&lt;/li&gt;
&lt;li&gt;Semaphore&lt;/li&gt;
&lt;li&gt;使用场景分析&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="限流" scheme="http://yoursite.com/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>HTTP详解</title>
    <link href="http://yoursite.com/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-09-18T03:19:09.000Z</published>
    <updated>2020-09-22T12:33:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文主要梳理HTTP协议的知识体系</p><ol><li>HTTP基础</li><li>DNS</li><li>HTTP缓存策略</li><li>HTTPS</li><li>常见问题</li></ol></blockquote><a id="more"></a><h1 id="HTTP各版本之间的差异"><a href="#HTTP各版本之间的差异" class="headerlink" title="HTTP各版本之间的差异"></a>HTTP各版本之间的差异</h1><p>超文本传输协议。<strong>「HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范」</strong>。</p><h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h2><ul><li>只有一个GET请求，只支持纯文本，早已过时</li></ul><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h2><ul><li>可以传送任何格式的文件，如图像、视频、文本等。</li><li>除了GET命令，还有POST和HEAD等。</li><li>HTTP的请求和回应的格式改变，除了数据部分，每次通信还必须包含头信息（HTTP header），用来描述一些元数据。</li><li>只使用header中<code>If-Modified-Since</code> 和<code>Expires</code>作为缓存失效的标准。</li><li>不支持断点续传，每次都会传送全部的页面和数据。</li><li>通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）</li><li><code>keep-alive</code>（默认关闭）</li></ul><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h2><p>HTTP是当前最主流的http协议版本。</p><ul><li>支持持久连接（presistent connection），即TCP连接默认不关闭，可以被多个请求复用。长连接的连接时长由请求头中的<code>keep-alive</code>（默认开启）来设置。</li><li>引入了管道机制（pipeline），即在同一个TCP连接里，客户端可以同时发送多条请求，提高了HTTP协议的效率。</li><li>HTTP 1.1 中新增加了 <code>E-tag，If-Unmodified-Since, If-Match, If-None-Match</code>等缓存控制标头来控制缓存失效。</li><li>支持断点续传，通过使用请求头中的<code>Range</code>来实现。</li><li>使用了虚拟网络，在一台物理服务器上可以存在多个物理主机（Multi-homed Web Servers），并且它们共享一个ip地址。</li><li>新增方法：PUT、 PATCH、 OPTIONS、 DELETE。</li></ul><h2 id="HTTP-1-x-的版本问题"><a href="#HTTP-1-x-的版本问题" class="headerlink" title="HTTP 1.x 的版本问题"></a>HTTP 1.x 的版本问题</h2><ul><li>传输的数据都是明文，没有加密，客户端和服务端都无法验证对方的身份，很不安全。</li><li>HTTP/1.1默认允许复用TCP连接，但是在同一个TCP连接里，所有的数据都是有序传输的，服务器只有处理完一个回应后才会去处理下一个，因此如果前面有数据阻塞，后面的都无法传输，这就是<strong>队头阻塞</strong>。</li><li>HTTP/1.x 支持长连接，为了避免创建多次连接产生的延迟，但是这同样会给服务器带来压力。对于单文件的请求，在请求结束后还会保持不必要的连接。</li></ul><h3 id="聊一聊队头阻塞"><a href="#聊一聊队头阻塞" class="headerlink" title="聊一聊队头阻塞"></a>聊一聊队头阻塞</h3><p>　　对于每一个HTTP/1.x请求而言，这些任务是会被放入一个任务队列中串行执行的，一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是<code>HTTP队头阻塞</code>问题。可以通过如下方式解决：</p><ul><li>并发连接：增加多个TCP连接。</li><li>域名分片：把一个域名分成很多二级域名，相当于也是增加了多个连接</li></ul><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><ul><li><strong>二进制分帧：</strong>将数据全部转为二进制，头信息和数据体都是二进制，统称为<strong>“帧”</strong>：头信息帧和数据帧。</li><li><strong>头部压缩：</strong>HTTP/1.x版本中可能会出现的<code>User-Agent、Cookie、Accept、Server、Range</code>等字段可能会占用几百甚至几千字节，而body部分可能才几十字节，导致头部偏重。HTTP 2.0 使用 <code>HPACK</code> 算法进行压缩。</li><li><strong>多路复用：</strong>复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求和回应，且不用按照顺序一一对应，这样就解决了队头阻塞的问题。</li><li><strong>服务器推送：</strong> 允许服务器未经请求，主动向客户端发送资源，即服务器推送。</li><li><strong>请求优先级：</strong> 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</li></ul><h1 id="HTTP-2-0介绍"><a href="#HTTP-2-0介绍" class="headerlink" title="HTTP 2.0介绍"></a>HTTP 2.0介绍</h1><p>更加详细且权威的内容请参考：<a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-CN" target="_blank" rel="noopener">谷歌开发手册HTTP2.0</a>。</p><h2 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h2><p>　　上一节讲到HTTP/1.x的头部包含了太多的内容，导致头部偏重的问题。HTTP/2.0采用了HPACK算法进行了头部压缩。这一节主要介绍一下HPACK算法。官方文档：<a href="https://www.rfc-editor.org/rfc/rfc7541.txt" target="_blank" rel="noopener">RFC7541</a>。</p><h3 id="HPACK"><a href="#HPACK" class="headerlink" title="HPACK"></a>HPACK</h3><ul><li><p><strong>基本原理：</strong>HPACK 使用2个索引表(静态索引表和动态索引表)来把头部映射到索引值，并对不存在的头部使用哈夫曼编码，并动态缓存到索引，从而达到压缩头部的效果。</p><p>  <img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/hpack.png" alt></p><blockquote><p>从上面看，我们可以看到类似于索引表，每个索引表对应一个值，比如索引为2对应头部中的method头部信息，这样子的话，在传输的时候，不在是传输对应的头部信息了，而是传递索引，对于之前出现过的头部信息，只需要把<strong>「索引」</strong>(比如1，2，…)传给对方即可，对方拿到索引查表就行了。</p></blockquote></li><li><p>静态索引表：定义在RFC中的固定头部，当发送的值符合索引表时，只需要发送索引值就行。比如<code>2 :method GET</code>和<code>3 :method POST</code>是静态表中的两个字段，这样请求的方式如果是<code>GET</code>就可以只发送索引2。</p></li><li><p>动态索引表：动态表是一个由先进先出的队列维护的有空间限制的表，里面同样维护的是头部与对应的索引。<strong>每个动态表只针对一个TCP连接，也就是说每个TCP连接压缩解压缩的上下文中有且只有一个动态表。</strong>当一个头部没有出现过的时候，会把他插入动态表中，下次同名的值就可能会在表中查到到索引并替换掉头部。动态表初始为空。</p></li></ul><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>HTTP/1.x中，如果想并发多个请求需要建立多个TCP连接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP连接请求限制。</p><p>HTTP/2.0：</p><ul><li><p>同域名的所有通信在单个连接上完成</p></li><li><p>单个通信可以承载任意数量的双向数据流</p></li><li><p>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，根据帧首部的流标识重新组装，也就是<code>Stream ID</code>，这个标识符标志了这个帧是属于哪一条消息的，通过这个标识符，接收方就可以从乱序的二进制帧中选择ID相同的帧，按照顺序进行组装成一个报文。</p></li><li><p>这里要注意一下，TCP是字节有序的协议，所有报文之间必须顺序传送，<strong>同一个报文的帧也是顺序传送的</strong>，但是不同报文的帧可以交错，如下图：</p><p>  <img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/多路复用.png" alt></p></li></ul><h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><p>浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源（发送多个响应），这样浏览器就不用发起后续请求。</p><p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/服务器推送.png" alt></p><blockquote><p>HTTP/2 打破了严格的请求-响应语义，支持一对多和服务器发起的推送工作流，在浏览器内外开启了全新的互动可能性。 这是一项使能功能，对我们思考协议、协议用途和使用方式具有重要的长期影响。</p></blockquote><p>​        为什么在浏览器中需要一种此类机制呢？一个典型的网络应用包含多种资源，客户端需要检查服务器提供的文档才能逐个找到它们。 那为什么不让服务器提前推送这些资源，从而减少额外的延迟时间呢？ 服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场。</p><p><strong>优势：</strong></p><ul><li>推送资源可以由不同页面共享</li><li>服务器可以按照优先级推送资源</li><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送过来的资源</li></ul><h2 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h2><p>以前的版本都是明文传输，不利于计算机解析。HTTP/2.0采用二进制格式，全部传输01串，便于计算机解码。</p><p>这样子，一个报文就被拆分成一个个二进制帧，用<strong>Headers帧</strong>存放头部字段，<strong>Data帧</strong>存放请求体数据。</p><h3 id="数据流-消息-帧"><a href="#数据流-消息-帧" class="headerlink" title="数据流 消息 帧"></a>数据流 消息 帧</h3><p>这里简单解释一下数据流，消息和帧的概念：</p><ul><li>数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。</li><li>消息：与逻辑请求或响应消息对应的完整的一系列帧。</li><li>帧：HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。</li></ul><p>这些概念的总结如下：</p><ul><li>所有通信都在一个TCP连接上完成，此连接可以承载任意数量的双向字节流。</li><li>每个数据流都有唯一的标识符和可选的优先级信息，用于承载双向消息。</li><li>每条消息都是一条逻辑HTTP消息（请求或者响应），包含一个或多个帧</li><li>帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装（所谓乱序）。</li></ul><h3 id="乱序帧的组装"><a href="#乱序帧的组装" class="headerlink" title="乱序帧的组装"></a>乱序帧的组装</h3><ul><li><strong>所谓的乱序，指的是不同ID的Stream是乱序的，对于同一个<code>Stream ID</code>的帧是按顺序传输的。</strong>（不厌其烦地再解释一遍）</li><li>接受方收到二进制帧之后，把相同<code>Stream ID</code>的帧组装成完整的请求报文或响应报文。</li><li>二进制帧中有一些字段，控制着<code>优先级</code>和<code>流量控制</code>等功能，这样子的话，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验。</li></ul><h1 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h1><p>RFC定义了HTTP的状态码为三位数，第一个数字为响应的类别，一共分为五类。</p><ul><li><strong>1XX：</strong>代表请求已接受，需要后续处理</li><li><strong>2XX：</strong>表示成功</li><li><strong>3XX：</strong>重定向状态</li><li><strong>4XX：</strong>客户端错误</li><li><strong>5XX：</strong>服务端错误</li></ul><h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><ul><li><strong>200 OK</strong>：表示客户端的请求在服务端被正确请求。</li><li>204 No Content：表示请求成功，但是没有资源返回。</li><li>206 Paritial Content：表示客户端进行了范围请求，服务端成功执行了这部分的请求。响应报文中包含由<code>Content Range</code>指定范围的实体内容。</li></ul><h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><ul><li><strong>301 moved permanently：</strong>永久重定向，表示资源已被分配了新的URL，这时应该按 Location 首部字段提示的 URL 重新访问。</li><li><strong>302 found：</strong>临时重定向，表示资源被临时分配了新的URL。</li><li>303 see other：表示资源存在着另一个URL，应使用GET方法获取资源。</li><li>304 not modified，当协商缓存命中时会返回这个状态码。</li><li>307 temporary redirect，临时重定向，和302含义相同,不会改变method</li></ul><blockquote><ol><li><p>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送</p></li><li><p>301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做</p></li></ol></blockquote><h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><ul><li><p>400 bad request：请求报文存在语法错误。</p></li><li><p>401 unauthorized：表示发送的请求需要有通过HTTP认证的认证信息。</p></li><li><p>403 forbidden：表示请求资源的请求被服务器拒绝。</p></li><li><p>404 not fond：表示在服务器上没有找到相应的资源。</p></li><li><p>405 Method Not Allowed：服务器禁止使用该方法，客户端可以通过options方法来查看服务器允许的访问方法，如下 ：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods →GET,HEAD,PUT,PATCH,POST,DELETE</span><br></pre></td></tr></table></figure></li></ul><h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><ul><li>500 internal sever error：表示服务端在执行请求时出现了错误。</li><li>502 Bad Gateway：服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道。</li><li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求。</li></ul><h1 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>缓解服务器的压力</li><li>降低客户端获取资源的速度：缓存一般存在在内存中，而且缓存服务器可能比源服务器更近一点（浏览器缓存）。</li></ul><h2 id="储存位置"><a href="#储存位置" class="headerlink" title="储存位置"></a>储存位置</h2><ul><li>代理服务器进行缓存</li><li>客户端浏览器进行缓存</li></ul><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>浏览器在请求资源时会先判断有没有命中强缓存。HTTP/1.0 版本用<code>Expires</code>字段来控制强缓存，HTTP/1.1 版本使用<code>Cache-Control</code>来控制。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>　　设置缓存的过期时间，这个时间是针对服务器时间而言的，存在于服务器返回的响应头中，在这个过期时间内可以使用缓存，不需要再次请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires:Mon, 29 Jun 2029 11:10:23 GMT <span class="comment"># 过期时间为2029年06月29日</span></span><br></pre></td></tr></table></figure><p>　　可以注意到，浏览器的时间和服务器的时间可能不一致，因此在HTTP/1.1中用新的字段<code>Cache-Control</code></p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>　　<code>Cache-Control</code>通过设置<code>Max-Age</code>来设置缓存的过期时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:max-age=6000 <span class="comment"># 6000秒后过期</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>当<code>Expires</code>和<code>Cache-Control</code>同时存在时，优先考虑Cache-Control。</p></li><li><p>当然了，当缓存资源失效了，也就是没有命中强缓存，接下来就进入协商缓存</p></li></ul><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p> 　　强缓存失效后，浏览器在请求头中携带响应的<code>缓存Tag</code>来向服务器发送请求，服务器根据对应的tag，<strong>来决定是否使用缓存</strong>。Tag分为两种，<code>Last Modified</code>和<code>ETag</code>。如果两种方式都支持的话，服务器会优先考虑<code>ETag</code>。</p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last Modified"></a>Last Modified</h3><p>　　这个字段表示最后修改时间，当浏览器给服务器第一次发请求后，服务器会在响应头中加上这个字段。浏览器接收到这个请求后，如果<strong>再次发起请求</strong>，会在请求头中携带<code>IF-Modified-Since</code>字段，这个字段值就是服务器传来的最后修改时间。服务器拿到<code>IF-Modified-Since</code>字段后，<strong>会与服务器资源目前最新修改的时间最对比</strong>：</p><ul><li>如果<code>IF-Modified-Since</code>比最新修改的时间要小，也就是说服务器资源更新了，那么就会返回新的资源。</li><li>如果相等，则说明资源没有修改，那么返回304，告诉浏览器直接用缓存。</li></ul><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>　　ETag是服务器根据当前文件的内容，对文件生成唯一的标识，比如MD5算法，只要里面的内容有改动，这个值就会修改，<strong>服务器通过把响应头把该字段给浏览器</strong>。浏览器接收到Tag值，会在下次请求中把这个值放到<code>IF-None-Match</code>字段里发个服务器。服务器拿到这个值后，和最新资源的ETag做对比：</p><ul><li>相等，返回304</li><li>否则，返回新的资源</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li><p>性能上，<code>Last-Modified</code>优于<code>ETag</code>，<code>Last-Modified</code>记录的是时间点，而<code>Etag</code>需要根据文件的MD5算法生成对应的hash值。</p></li><li><p>精度上，<code>ETag</code>优于<code>Last-Modified</code>。<code>ETag</code>按照内容给资源带上标识，能准确感知资源变化，<code>Last-Modified</code>在某些场景并不能准确感知变化，比如：</p><ul><li>编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。</li><li>Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>首先检查<code>Cache-Control</code>， 看强缓存是否可用</p></li><li><p>如果可用的话，直接使用</p></li><li><p>否则进入协商缓存，发送HTTP请求，服务器通过请求头中的<code>If-Modified-Since</code>或者<code>If-None-Match</code>字段检查资源是否更新</p></li><li><p>资源更新，返回资源和200状态码。</p></li><li><p>否则，返回304，直接告诉浏览器直接从缓存中去资源。</p></li></ol><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="和HTTP的区别"><a href="#和HTTP的区别" class="headerlink" title="和HTTP的区别"></a>和HTTP的区别</h2><p>　　HTTPS相比HTTP就是多了一个安全性的概念，实际上，HTTPS并不是一个全新的应用层协议，它就是<code>HTTP + TLS/SSL</code>，而安全性就是<code>TLS/SSL</code>做的工作。</p><ul><li>SSL（Secure Sockets Layer）：安全套接层</li><li>TLS（Transport Layer Security）：传输层安全，目前使用的版本是1.2</li></ul><p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/HTTPS.png" alt></p><p>主要有如下区别：</p><ul><li>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li><li>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页。</li><li>HTTPS标准端口443，HTTP标准端口80。</li><li>HTTPS需要用到SSL证书，而HTTP不用。</li></ul><p><strong>HTTPS有两点关键的作用：</strong></p><ul><li>建立信息安全的通道，保证数据传输的安全。</li><li>对网站服务其进行真实身份验证。</li></ul><h2 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h2><p>工作原理就是过了一层<code>SSL/TCL</code>连接。</p><blockquote><p>TLS/SSL 的功能实现主要依赖于三类基本算法：<code>散列函数</code> 、<code>对称加密</code>和<code>非对称加密</code>。</p><ul><li>非对称加密实现身份认证和密钥协商</li><li>对称加密算法采用协商的密钥对数据加密</li><li>散列函数验证信息的完整性。</li></ul></blockquote><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>　　对称加密就是指客户端和服务端使用同一个密钥来加密明文。</p><p>　　但是不同的客户端密钥肯定不同，服务器要和客户端拥有相同的密钥就需要把密钥从客户端通过HTTP传输过来，这样密钥就会被拦截，很不安全。但是如果这个密钥别人获取不到，那么就是安全的。</p><h3 id="非对称加密TLS-1-2"><a href="#非对称加密TLS-1-2" class="headerlink" title="非对称加密TLS 1.2"></a>非对称加密TLS 1.2</h3><p>　　采用的算法是RSA，所以在一些文章中也会看见<strong>传统RSA握手</strong>，基于现在TLS主流版本是1.2，所以接下来梳理的是<strong>TLS/1.2握手过程</strong>。非对称加密需要知道以下要点：</p><ul><li>有一堆密钥，公钥和私钥。</li><li>公钥加密的内容，只有私钥也可以解开，私钥加密的内容，只有公钥可以解开。</li><li>公钥发送给所有客户端，私钥只保存在服务端。</li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/TLS1.2.PNG" alt></p><p><strong>步骤解释：</strong></p><ol><li><p>Client发送一个HTTPS请求，连接443端口。这个请求可以理解成是<strong>请求公钥</strong>。</p></li><li><p>Server端收到请求后通过第三方机构私钥加密，会把数字证书（公钥证书）发给Client。</p></li><li><p>浏览器验证公钥证书</p><ul><li><p>浏览器安装后会自动带一些权威第三方机构公钥，使用匹配的公钥对数字签名进行解密。</p></li><li><p>根据签名生成的规则对网站信息进行本地签名生成，然后两者比对。</p></li><li><p>通过比对两者签名，匹配则说明认证通过，不匹配则获取证书失败。</p></li></ul></li><li><p>在安全拿到<strong>服务器公钥</strong>后，客户端Client随机生成一个<strong>会话密钥</strong>（SessionID），使用<strong>服务器公钥</strong>（证书的公钥）加密这个<strong>对称密钥</strong>，发送给Server(服务器)。</p></li><li><p>Server端用私钥解密得到会话密钥，至此两端都有了一个相同的密钥作为<strong>对称密钥</strong>。</p></li><li><p>两端使用对称密钥对请求的数据进行加密和解密</p></li></ol><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>　　在第二步的时候，我发给Client的公钥证书被劫持且篡改了怎么办？因为证书中有公钥，这个公钥是公开的，如果有中间人替换了这个公钥，Client是感知不到的。</p><p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/公钥劫持.png" alt></p><h2 id="第三方认证"><a href="#第三方认证" class="headerlink" title="第三方认证"></a>第三方认证</h2><p>如果只用非对称加密，一旦证书被劫持，Client感知不到。如果让Cilent可以感知呢？</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>在HTTPS中，通过”<strong>证书 + 数字签名</strong>”来解决这个问题。</p><p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/数字签名.png" alt></p><p>　　可以看到，数字签名是单独加密的：<strong>使用第三方认证机构的私钥。</strong></p><p>　　如果证书再被劫持，把服务器的公钥替换成假的公钥，因为有数字签名的存在，客户端会发现数字签名不匹配。因为数字签名有第三方的私钥加密，这个私钥中间人是不知道的。<font color="red">数字签名用<strong>散列函数</strong>计算了<strong>公钥证书</strong>中部分信息</font>，如果中间人修改了公钥证书，客户端解开数字签名后，内容就会不匹配，这就保证了可靠性。</p><h3 id="客户端如果对比数字签名？"><a href="#客户端如果对比数字签名？" class="headerlink" title="客户端如果对比数字签名？"></a>客户端如果对比数字签名？</h3><ol><li>浏览器会去安装一些比较权威的第三方认证机构的公钥，比如VeriSign、Symantec以及GlobalSign等等。</li><li>验证数字签名的时候，会直接从本地拿到相应的第三方的公钥，对私钥加密后的数字签名进行解密得到真正的签名。</li><li>然后客户端利用签名生成规则（这里具体的规则就不讲了，散列函数只是一种）进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。</li></ol><h2 id="SSL断开后如何恢复？"><a href="#SSL断开后如何恢复？" class="headerlink" title="SSL断开后如何恢复？"></a>SSL断开后如何恢复？</h2><p>　　可以看到，HTTPS建立连接十分麻烦，且十分耗时。有两种方式可以快速的恢复SSL连接，一种是使用SessionID，另一种是Session Ticket。</p><h3 id="SessionID"><a href="#SessionID" class="headerlink" title="SessionID"></a>SessionID</h3><p>　　使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，<strong>如果我们的请求通过负载平衡被转移到了其他的服务器上</strong>，那么就无法恢复对话。</p><h3 id="Session-Ticket"><a href="#Session-Ticket" class="headerlink" title="Session Ticket"></a>Session Ticket</h3><p>　　另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。</p><h1 id="短轮询、长轮询和-WebSocket"><a href="#短轮询、长轮询和-WebSocket" class="headerlink" title="短轮询、长轮询和 WebSocket"></a>短轮询、长轮询和 WebSocket</h1><h2 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h2><p><strong>短轮询的基本思路:</strong></p><ul><li>浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行 响应。</li><li>这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。</li></ul><p><strong>优缺点：</strong></p><ul><li>优点是便于理解</li><li>缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</li></ul><h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p><strong>长轮询的基本思路:</strong></p><ul><li>首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。</li><li>如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。</li></ul><p><strong>优缺点：</strong></p><ul><li>长轮询和短轮询比起来，它的优点是<strong>「明显减少了很多不必要的 http 请求次数」</strong>，相比之下节约了资源。</li><li>长轮询的缺点在于，连接挂起也会导致资源的浪费。</li></ul><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><ul><li><p>WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。</p></li><li><p>使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息。</p></li></ul><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>DNS协议提供了一种主机名到IP地址的转换服务，就是我们常说的域名系统。这是应用层的协议，通常该协议建立在UDP之上，这就要求域名解析器和域名服务器都必须自己处理超时和重传来确保可靠性，使用53端口号。有两种情况会建立TCP连接：</p><ul><li>返回的响应超过了512个字节（UDP最多传递512字节）</li><li>区域传送（主域名向辅助域名传送数据）</li></ul><h2 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h2><ol><li>客户端不会直接去请求本地DNS服务器，而是通过下图流程一步步查询：</li></ol><p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/客户端请求域名.png" alt></p><ol><li>本地DNS服务器查询IP的过程一般是<strong>递归查询</strong></li></ol><p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/本地DNS迭代查询.png" alt></p><ol><li><strong>迭代查询：</strong>用户请求DNS服务器后，DNS服务器直接返回结果，如果没有找到域名，则由用户自己发送下一级请求。</li></ol><p>　　可以这么理解：本地服务器看起来自己的请求时递归的，因为我只需要发一次请求，但是本地DNS服务器的请求是迭代的，需要服务器一次次去查询。</p><h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><p>　　在一个请求中，当某个DNS服务器收到一个DNS回答后，他能够将回答中的信息存储到本地储存器中。返回资源中的TTL代表该记录的缓存时间。</p><h2 id="DNS为什么要使用UDP？"><a href="#DNS为什么要使用UDP？" class="headerlink" title="DNS为什么要使用UDP？"></a>DNS为什么要使用UDP？</h2><p><strong>「DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。」</strong></p><ul><li>为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢。</li><li>大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。</li></ul><h2 id="DNS实现负载均衡"><a href="#DNS实现负载均衡" class="headerlink" title="DNS实现负载均衡"></a>DNS实现负载均衡</h2><p>想不到吧，DNS还能做负载均衡，因为一个域名可能对应不同的ip。</p><ul><li>当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合</li><li>在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。</li><li>以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>DNS域名系统是应层的协议，运行在UDP之上，使用端口53</li><li>查询过程，本地查询是递归查询，依次通过 <strong>浏览器缓存—-本地hosts文件—-本地DNS解析器—-本地DNS服务器—-其他域名服务器请求</strong>。 接下来的过程就是迭代过程。</li><li>递归查询一般而言，发送一次请求就够，迭代过程需要用户发送多次请求。</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://www.jianshu.com/p/f44b930cfcac" target="_blank" rel="noopener">HPACK完全解析</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-CN" target="_blank" rel="noopener">HTTP/2简介 Google</a></li><li><a href="https://juejin.im/post/6857287743966281736#heading-59" target="_blank" rel="noopener">「查缺补漏」巩固你的HTTP知识体系</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#%E5%85%ADhttps" target="_blank" rel="noopener">CS-NOTE</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文主要梳理HTTP协议的知识体系&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTTP基础&lt;/li&gt;
&lt;li&gt;DNS&lt;/li&gt;
&lt;li&gt;HTTP缓存策略&lt;/li&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;常见问题&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>计网相关基础知识</title>
    <link href="http://yoursite.com/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-09-17T03:19:09.000Z</published>
    <updated>2020-11-02T09:27:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文旨在介绍计网的相关基础知识，只介绍到网络层之上</p><ol><li>计算机网络概述</li><li>应用层</li><li>Socket</li><li>传输层</li><li>网络层</li></ol></blockquote><a id="more"></a><h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><p>​    计算机网络就是为了解决<strong>计算机之间的通信问题</strong>。通讯就是指数据的交换，即信息的交换。计算机的世界里，一切信息都是数据。</p><p>​    与计算机网络有关的东西有很多：网线，网卡，路由器，IP地址，TCP，HTTP，FTP等等。这些东西分别对应着计算机网络中的不同层次。层次有不同的分法：</p><ul><li>OSI模型将计算机网络分成了7层，由上至下分别是：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。因为分的太细，与实际操作时不相匹配的，因此市场上很少使用这种模型。</li><li>市场上成功的模型一般是四层或者五层，分成五层比较好理解：应用层、传输层、网络层、数据链路层、物理层。网线属于物理层，网卡属于数据链路层，路由器属于网络层，对应的协议有IP和ICMP协议，TCP属于传输层，HTTP属于应用层等等。</li></ul><p>​    计算机网络分层的原因在于其体系结构太复杂了，按照不同设备的功能划分成不同的层次更易于规范的标准化，而且每一层相对其它层独立且透明，这一层变化了也不影响其他层的工作，更易于维护。透明的含义可以解释如下：计算机网络的每一层之间不需要理解对方是则怎么工作的，我只需要接收下层给我的数据，这个数据符合我定义的数据规范，我解读并处理了该数据后，按照上一层定义的数据格式封装我的数据，并提交给上一层，上一层就能正确接收到我的数据。分层之后，某层的修改不会影响到其他层，<strong>举个通俗的例子：</strong>IPV4和IPV6是网络层不同版本的协议，但是这两种版本的切换对应用层HTTP是没有区别的，因为不管用IPV4或者IPV6，传给HTTP的数据格式都是一样的。</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>​    应用层协议比较多，每个协议有不同的功能和用法，比如HTTP用于网页内容的传输，FTP用于文件的传输，SMTP用于邮件的传输等。HTTP是做web服务必须了解的知识点，但是内容很多，我单独写了一片博客：<a href>HTTP详解</a></p><h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>​    在应用层和传输层之间有一个接口叫做Socket。Socket不属于某一个层，它可以理解应用层和传输层之间的一个管道，用来连接操作系统和应用层中的具体应用进程，应用可以操作Socket来使用操作系统的网络功能。</p><p>​    因为传输层之下基本都是由操作系统控制，而应用层协议是由应用进程控制，所以要定义一个接口来建立起应用进程和底层协议的桥梁，这个接口的实现就是Socket。大部分操作系统都实现了Socket。</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>​    传输层最经典的两个协议是TCP和UDP，其他的比如DCCP，SCTP本文就不讲了。传输层提供的是应用进程之间的逻辑通信机制。传输层通过Socket提供的端口号，把一个进程的数据传送到另一个进程。</p><p>​    传输层有多路复用的概念，这和物理层中的多路复用不一样，物理层的多路复用是指物理线路上的复用，如：频分复用、码分复用等；而传输层中多路复用是指：多个数据报被同时接收，计算机如何处理这些数据包是如何分发，按照什么原则分发。在传输层之下，所有的数据包都经过了相同的处理，但到了传输层，不同的数据包传输就有了区别。所有其他主机给我发送的所有UDP数据包都会被提交到同一个端口，而TCP数据包会根据其连接的不同分发给不同的端口。因为TCP连接是一对一的，每个端口只对应一个连接，也同时对应发送数据的主机上某个唯一端口，因此如果发送数据的主机想要和我创建多条TCP连接，需要创建不同的进程或者线程，还需要相应的端口号。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>​    UDP只对IP协议做简单的拓展，仅仅只把网络层传输过来的数据区分一下端口号，就递给进程了，有可能也会做一点简单的错误检测。UDP有以下的好处（主要和TCP对比）：</p><ol><li>不需要建立连接，因此数据请求的延迟小；</li><li>实现简单，不需要负责实现过程，比如维护连接等；</li><li>头部开销很小，在数据内容之上，只包装了一些区别端口号和差错检验的账号；</li><li>应用层可以很好地对其进行拓展。</li></ol><p>​    UDP数据报的结构如下：<img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/UDP数据包.png" alt></p><p>​    可以看到，一个UDP数据报，除了具体的传输数据，还在首部增加了8个字节的数据用来区分端口，限制长度和差错校验。其中这个数据长度是包含了8个字节的头部数据的，可以看出一个UDP的数据包的长度是有限制的，不能太大。UDP的源端口号可以省略，如果省略则代表了我的数据一旦发出去，就不需要回复了；校验和字段也可以省略，不过一般都会做一些简单的校验，防止数据在传输过程中出错，导致数据乱序，残缺。这种数据应用层接受到是无法使用的。校验后这种错误的数据会在传输层废弃，然后给发送源一个ICMP数据包，告知数据错误，然后这个数据传输就结束了，因为UDP不提供重传机制。</p><p>​    UDP进行差错检验的方法和IP中的方法一致，这里先不提。UDP的差错检验保证了端口与端口之间正确传输的检测，也能核实出数据部分是否产生了错误。在进行差错检测时，会添加一些额外的数据参与计算，这些数据计算完之后就丢弃了，真正用来传输的数据格式还是上面那个。伪首部结构如下图红色的部分：</p><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/UDP数据包-伪首.png" alt></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP是一个点到点（端口到端口）的协议，是一个可靠的，按序字节流的协议。是一个面向连接的协议。</p><p>接收方和发送方都会有一定的存储空间用来缓存数据，一般用于重传，分组重组等功能。</p><p>面向连接的含义：通信前必须建立连接，两端维护连接，中间节点不连接。</p><p>TCP提供了可靠的数据传输，流量控制和拥塞控制。</p><h3 id="可靠的数据传输"><a href="#可靠的数据传输" class="headerlink" title="可靠的数据传输"></a>可靠的数据传输</h3><p>​    TCP实现可靠的数据传输主要是基于一种确认（acknowledge，ACK）机制。简单说来就是，我发你一个数据包，你得告诉我你收到了，不然我默认你没收到，等一段时间后就会重新发这个数据包给你，直到你告诉我你收到了。这是保证可靠传输的逻辑。</p><p>​    在可靠传输的具体实现中，TCP采用的是累加确认，确认的是数据中的自己号，而不是确认收到了第几个数据包。正因如此，TCP才被叫做按序字节流的协议。</p><p>​    在TCP发出报文后，如果没有收到确认，要过多久才会重新发送数据呢？计算超时时间有一个算法，里面最主要的参数是RTT（Round Trip delay time），RTT指我发出一个报文开始，到我接受到ACK报文所经过的时间。根据历史值的平均数，和上一个数据包的 RTT 值，经过加权计算之后的值设置为当前数据报的超时时间。这样结合了当前网络和历史网络的状况后得到的结果最合理。如果我发过了一个报文，过了超时时间，就会重新发。因为等待ACK报文需要时间，一个个发报文严重影响传输效率，因此TCP一般都一段段发：<font color="red"><strong>TCP有一个滑动窗口机制</strong></font>，一段一段的发送数据，确认时只按收到了第几个字节数（可以理解成下一个报文的头位置）来确认。这一过程中会遇到这样的问题：第五段报文丢失了，第六段、第七段和第八段报文被接收了，接收方因为没有收到第五段报文，因此在收到第六段报文时，接收方会发一个第五段报文的ACK报文，然后又收到了第七段报文，没办法，只好再发一次第五段的ACK，然后又收到了第八段报文，只好再发一次第五段报文ACK，至此，接收方连续发送了<strong>三次</strong>第五段报文的ACK，发送方立刻重发第五段报文，这就是<font color="red"><strong>快重传机制</strong></font>，可见快重传不需要等待计时器超时。一般设置了3次重复ACK报文就会启动重传，因为如果丢包，必然会有两次以上的ACK，但是如果只收到了两次ACK，则很有可能是乱序造成的，这时候重传解决不了问题，详见<a href="https://www.zhihu.com/question/21789252/answer/110640581" target="_blank" rel="noopener">TCP 快速重传为什么是三次冗余 ACK，这个三次是怎么定下来的？</a></p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>上面讲到TCP的有一个滑动窗口机制。接收方也有一个缓存窗口。如果数据的读取很慢，但是网速却很快，数据大量集中，超过了接收方缓存的大小，这时候即使再来数据，也无法接收，于是接收方就不停地发送缓存窗口最后一个位置的ACK，然后发送方就会不停地进行重传，这大大浪费了网络资源。因此，<strong>接收方每次返回ACK报文时，会在报文中加入缓存空间的剩余量是多少</strong>，发送方根据剩余量的多少发送数据。<strong>这里有一个边界问题：如果接受方的ACK报文中剩余量为0时怎么办？</strong>肯定不可能停止发送数据，因为停止发送就再也不知道剩余缓存量的变化了。因此，如果接收方缓存剩余量为0，发送方会间歇性、尝试性地发送一组探测报文（ZWP），探测一下对方还有多少余量，如果余量变多了就恢复数据的传输，这就实现了TCP的流量控制。</p><h3 id="拥塞机制"><a href="#拥塞机制" class="headerlink" title="拥塞机制"></a>拥塞机制</h3><p>TCP采用的是端到端的控制方法，由两端的计算机控制，中间的路由不提供明显的控制。TCP的拥塞控制中有多种算法。目前TCP的拥塞控制流程一般是这样的：</p><ul><li>最一开始，采用<strong>慢开始</strong>算法，发送窗口的大小成指数上升到某一阈值。举个例子，窗口大小依次为：1，2，4，8，16，32，64（阈值ssthresh，假设这个值是64）</li><li>到达阈值后，采用线性增算法（<strong>拥塞避免</strong>），发送窗口的大小每个时间点增加一：64，65，66，67….。</li><li>这时候会出现两种情况<ul><li>当增加到80时，发送方连续收到三个相同的ACK：立刻将发送窗口大小设为40（减一半），并将阈值也设置成40，随后线性增加发送窗口大小的算法。<font color="red"><strong>这就是快恢复</strong></font>。</li><li>当增加到80时，发送方发现一个数据包超时了（也就是没有收到接收方的ACK报文），立刻把发送窗口的大小设置成1。</li><li>解释<ul><li>第一种情况要么是乱序，要么是丢包，不管是那种，数据包都是能够传输进来的，网络很通畅，因此可以指定快恢复。</li><li>第二种情况直接超时了，说明网络质量很差，这时候需要降低发送速率，防止阻塞。</li></ul></li></ul></li></ul><p>为什么TCP有拥塞控制？因为其有重传机制，网络环境差就会不停地重传，造成阻塞，而UDP不依赖于网络环境，丢了就丢了。</p><h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP报文.png" alt></p><p>由上至下依次解释如下：</p><ul><li>1、源端口号：数据发起者的端口号，16bit</li><li>2、目的端口号：数据接收者的端口号，16bit</li><li>3、<font color="red"><strong>序列号</strong></font>：32bit的序列号，<strong>真正发送数据时使用，告知当前发送的一段数据的<font color="red">首字节的序列号</font></strong>，如果发的报文不含数据（如确认报文），此字段是没有变化的。若 SYN=1 或 FIN =1 的数据报当作含有一字节数据。</li><li>4、<font color="red"><strong>确认序列号</strong></font>：32bit的确认号，是接收数据方<strong>期望收到发送方的下一个报文段</strong>的序号，<strong>因此确认序号应当是对方刚刚发给你的 TCP 报文中的序号字段加数据长度的值再<font color="red">加1</font>，是你的确认序号</strong>，你要回复他说，我收到你的数据了，所以要确认的是对方的序号。  </li><li>5、首部长度：4位，最大可表示的数为 15 。而光首部就有 20 字节，所以在这里规定，每个 1 代表 4 字节，就是上图中的一行，这个字段值为几，就是几行。最大可表示 15*4 = 60 字节。</li><li>6、保留：6bit，均为0</li><li>7、紧急URG：当URG=1时，表示报文段中有紧急数据，应尽快传送，紧急指针字段有效。</li><li>8、确认比特ACK：ACK = 1时代表这是一个确认报文，取值 0 则不是确认报文；</li><li>9、<strong>推送比特PSH</strong>：当发送端PSH=1时，接收端尽快的交付给应用进程；</li><li>10、复位比特（RST）：当RST=1时，表明TCP连接中出现严重差错，必须释放连接，再重新建立连接；</li><li>11、<strong>同步比特SYN：在建立连接是用来同步序号</strong>。<strong>一个报文中 SYN=1,ACK=0时，是表示这一个连接请求报文段。SYN=1，ACK=1时表示的是接收方同意建立连接。</strong></li><li>12、<strong>终止比特FIN</strong>：FIN=1时，表明此报文段的发送端的数据已经发送完毕，并要求释放传输连接。</li><li>13、<strong>窗口</strong>：就是提供流量控制的功能，表示可缓存字节数的多少。</li><li>14、校验和：该字段检验的范围包括首部和数据这两部分。由发端计算和存储，并由收端进行验证。</li><li>15、紧急指针：紧急指针在URG=1时才有效，它指出本报文段中的紧急数据的字节数。</li><li>16、选项：长度可变，最长可达40字节。绝大多数不适用此字段，也就是说 TCP 绝大部分是 20 字节。</li></ul><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TCP是面向连接的，双方进行数据交换前必须建立连接。TCP的连接机制就是注明的三次握手，四次挥手。</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>讲握手机制之前必须明确一个概念。序列号，用来标志我发送数据的第一个字节的序号。在建立连接前，会根据计算机的时钟信号初始化一个序列号，这个序列号是操作系统计算出来的（防止有人伪造连接）。目前我还没有发送数据，所以TCP头部信息中的序号的值就是初始值。</p><ul><li>发送端发起连接请求：向接收端发起一个请求连接的TCP报文，初始化一个序号x，SYN = 1, ACK = 0。</li><li>接收端收到连接请求，发起一个同意连接的TCP报文：接收端也会初始化一个序号y，SYN = 1, ACK = 1（同时确认序列号为：x + 1，可以简写成 ACK = x + 1)</li><li>发送端也发送了一次ACK，告知接收端我收到了你的同意：ACK = 1（确认序号为：y + 1，简写成 ACK = y + 1）</li></ul><p>​    两台主机都有自己的序号，建立连接的过程就是相互确认对方的序列号，从而在交换数据的时候保证有效。确认序号要确认的是期望得到的下一段报文的序号。</p><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/三次握手.png" alt></p><p>​    为什么需要三次握手呢？发送方如果发送了一条请求连接的报文A，但是因为网络问题超时了，此时发送端会重新再发一条请求B，这两条请求的序号是不一样的，此时如果接收方返回了一个同意连接的请求C，这个C的确认序号是基于A报文的序号的，如果此时接收方建立了连接，那就是B和C建立了连接，此时序号对不上，那么数据传输就会失败。此时引入了三次握手，如果接受方收不到C报文的ACK，就不会建立连接。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ul><li>我准备断开连接了，此时发送一条请求断开连接的TCP报文：FIN = 1, seq = x + 2，ACK = 1（ACK = y + 1）。<ul><li>官方文档规定，除了建立连接，任何时候ACK都要是1</li><li>我一旦发出了FIN报文，我就不会再发送有数据的报文了</li><li>这里seq是x+2主要是为了与图片一致</li></ul></li><li>你收到了我的FIN报文，回复一个ACK，同意断开：ACK = x + 3<ul><li>此时，你虽然应答了我的断开连接报文，但是你仍可以继续传输数据。比如你的数据还没有穿完我就发给你一个断开连接的报文，如果你没有传完数据，是可以继续一直传的。</li></ul></li><li>你传完了数据，发我一个FIN：seq = y + 1</li><li>我收到了你的FIN，发送一个ACK：ACK = y + 2<ul><li>此时你如果收到了我的ACK，就可以立刻释放连接了</li><li>我不能释放连接，因为我不确定你有没有收到我的ACK，因此我需要等一段时间再释放（数据包最大存活时间的两倍：2MSL）</li></ul></li></ul><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/四次挥手.png" alt></p><p>注意：</p><ol><li><p>收到我的FIN之后，如果你没有要传给我的数据，那么你就直接返回个FIN给我，这样就简化成了三次挥手。</p></li><li><p>为什么要四次挥手？要么保证发送方能够正确释放连接，要么保证接受方能够正确释放连接，少一个都不行。</p></li><li>为什么要等待2MSL，超过2MSL后，连接中的所有报文会自动丢弃，这样我释放连接再建立了新连接后，可以保证没有旧的报文。</li></ol><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>​    网络层的核心功能是<strong>转发</strong>和<strong>路由</strong>。因为要实现路由和转发功能，所以这一层实现了很多路由协议，要实现转发，就需要知道转发地址，这用到了IP协议。IP协议中规定一些寻址规则，以及数据报过大时如何切成一小片一小片的问题等。此外，网络层还包括重要的 ICMP 协议，依托于这种协议的数据都像是网络中的指令，计算机或者中间路由设备就成为了官兵的角色，根据指令内容做出相应的动作反应。</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><h3 id="基础知识科普"><a href="#基础知识科普" class="headerlink" title="基础知识科普"></a>基础知识科普</h3><p>​    IP地址是有限的，只有32bit，所以要对其进行划分，比如中国一部分，美国一部分。划分大块后还要继续划分，划给省、市、学校等等。这个划分过程，称为划分子网。于是就规定了，IP地址是有两个部分组成的<strong><font color="red">网络号和主机号</font></strong>。网络号的位置是不确定的，如果一个子网很大，网络号就小，主机号就可以很多。</p><p>​    以前会把IP地址划分成A,B,C类，还有划分子网的概念，将主机号中的一部分拿出来作为子网号：IP = 网络号 + 子网号 + 主机号。要使用子网必须使用子网掩码，一个B类地址默认的子网号是<code>255.255.0.0</code>，如果他的子网占两个比特，那么他的子网掩码就是<code>11111111.11111111.11000000.00000000 = 255.255.192.0</code>。外部网络是看不见子网的。</p><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/IP地址分类.png" alt></p><p>​    现在划分子网的方式是CIDR（无类域间路由），形式是 <code>x.x.x.x/n</code>，例如：<code>202.113.132.45/24</code>，这表示前24位是网络号，后8位是主机号。</p><p>​    这里列举一些特殊的网络地址：</p><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/特殊的网络地址.png" alt></p><p>​    以上特殊的网络地址有可能会碰到，放在这里记录一下。</p><p>​    还有一些是私有的网络地址，一般是自己的内部局域网访问，比如校园网什么的。如下图所示：</p><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/私有网络地址.png" alt></p><h3 id="IP数据格式"><a href="#IP数据格式" class="headerlink" title="IP数据格式"></a>IP数据格式</h3><p>​    从传输层传来的TCP或UDP的段需要在网络层增加一个首部，然后在提交给数据链路层。网络层对数据作了些什么呢？首先网络层具有转发的功能，因此必须要知道数据的目的地，于是网络层对数据增加了目的地址，这个目的地址就IP地址，唯一地标识一台主机。网络层还会对超过MTU（Max Transfer Unit最大传输单元）的数据包进行分片。以太网的MTU是1500字节，这是经验的规定，因为如果MTU设置的太小，数据包被切成很多快，传输的错误率就会上升，不利于数据的传输；切的太大，又会增加传输的延迟。</p><p>​    IP数据报的结构如下：</p><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/IP数据报.png" alt></p><ol><li><p><strong>版本 4bit</strong> 指 IP 协议的版本。目前广泛使用的 IP 协议版本号为 4 ，IPv6，版本号为 6 。</p></li><li><p><strong>首部长度</strong> <strong>4bit</strong> 单位是 4 个字节( 32bit 也就是上面的一行。因为 4bit 最大描述的数值是15，首部长度最短也需要20字节，不够描述的，所以单位改成 4 字节)，那这里的值一般为 5 。首部长度也就是 20 字节。首部长度大小取值范围 20 字节到 60 （4*15）字节，首部长度一般都是 20 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在4字节的整数倍开始。</p></li><li><p><strong>区分服务</strong> <strong>8bit</strong> 目前几乎不使用，若要支持区分服务，需要中间所有的路由器都支持区分服务，但是目前的绝大多数路由器都不支持，所以区分服务几乎不使用了。</p></li><li><p><strong>总长度 16bit</strong> 首部长度 + 数据长度，单位是字节。数据报的最大长度为 2^16-1 = 65535 字节。但由于数据链路层的最大传送单元 MTU &lt; 65535，所与当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的MTU值，若超过则需要分片(因此有上图的第二行，用于切片)。</p></li><li><p><strong>标识 16bit</strong> 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为 IP 是无连接服务，数据报不存在按序接收的问题。<strong>当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。<font color="red">相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报</font></strong>。</p></li><li><p><strong>标志 3bit</strong> 目前只有2位有意义。标志字段中间的一位记为 DF (Don’t Fragment)，意思是“不能分片”。只有当DF=0时才允许分片，若为 1 则不分片。标志字段中的最低位记为 MF (More Fragment)。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。 </p></li><li><p><strong>片偏移 13bit</strong> 当一个较长的 IP 数据报在分片后，分片后的某一片的第一个 bit 在原分组中的相对位置。也就是说，相对传输层数据报的数据部分的起点，该片从何处截断的。片偏移以 8 个字节为偏移单位。这就表明，每个分片的长度也一定是 8 字节（ 64位 ）的整数倍。那为什么 ipv4 片偏移量以 8 字节位单位呢？如果直接用字节为单位，总长度是 16bit 而片偏移量只有 13 bit，就会出现不够描述的。 所以偏移量就按 8 字节为单位的来规定了。</p></li><li><p><strong>生存时间 8bit</strong> TTL( Time To Live ) 就是说 IP 数据报最大能经过多少个路由器跳转(每经过一个路由器，TTL减1)。<strong>防止数据报在网络中因为某些错误导致无限循环，浪费网络资源</strong>。那么可以知道，路由器在转发时会将这个字段的值减 1，并重新计算首部校验和。</p></li><li><p><strong>协议 8bit</strong> 标志此数据报携带的数据是使用协议类型( 例如TCP、UDP等 )，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。</p></li><li><p><strong>首部检验和</strong> <strong>16bit</strong> 注意这个字段只检验数据报的首部，不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（因为生存时间、标志、片偏移都可能发生变化，就是说在中间路由被重新分片时会出现变化。），不检验数据部分可减少计算量。</p></li><li><p><strong>源IP地址</strong>　占32位。</p></li><li><p><strong>目的IP地址</strong>　占32位。</p></li></ol><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>​    我们自己电脑的IP地址有两种方式，第一种是直接设置一个固定的IP地址，需要配置一系列信息，比如子网掩码和DNS服务器地址等等；第二种是自动获取IP地址，这就是DHCP（动态主机配置协议）。通过本网络中的DHCP服务器发出请求，DHCP看看自己还有哪些IP地址没有分发出去，随机挑选一个给你用，返回给你的数据包中不仅包含了IP地址，还有子网掩码，默认网关地址以及DNS服务器地址。</p><p>​    DHCP的好处就是方便，以及节省资源，插上网线就能用，不用了之后，这个IP就给别人用。</p><h3 id="DHCP索要IP地址的流程"><a href="#DHCP索要IP地址的流程" class="headerlink" title="DHCP索要IP地址的流程"></a>DHCP索要IP地址的流程</h3><ol><li>想上网的设备要先在本网络中广播一个DHCP的报文，看谁回应，谁就就是DHCP服务器。这个过程称之为发现报文。</li><li>DHCP服务器在自己身体里找一个合适的IP地址，向全体广播提供一个<strong>提供报文</strong>。</li><li>上网的设备收到IP地址后会发一个请求报文，告诉DHCP服务器收到了IP地址。</li><li>随后DHCP服务器发送一个确认报文，并更新自己的数据库。</li></ol><p>​    这样做的原因是因为网络中可能有很多的DHCP服务器，这些服务器接收到了设备的DHCP报文，都会提供一个包含IP地址的报文，但是设备自己只能接收一个IP地址，所以要设备要发送一个请求报文来与告知其中某一个DHCP服务器“我用了你的IP”，这样这台DHCP服务器才会更新其数据库，其他的DHCP服务则会收回其分发的IP地址。</p><p>​    具体通信过程如下：</p><ol><li>DHCP服务其的默认端口是67</li><li>联网设备发送 DHCP 报文的默认端口是 68</li><li>发现报文：源 IP 0.0.0.0：68 目的 IP 255.255.255.255：67 双方都不知道彼此的 IP 地址 所以都是广播通信</li><li>提供报文：源 IP x.x.x.x：67 目的IP 255.255.255.255：67</li><li>下面就是再发一个请求报文和确认报文了</li></ol><h3 id="DHCP特点"><a href="#DHCP特点" class="headerlink" title="DHCP特点"></a>DHCP特点</h3><ol><li>在应用层实现，通过应用进程实现</li><li>使用 UDP</li><li>使用了 IP 广播</li></ol><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>与 IP 息息相关。它的主要功能有差错报告和网络探测俩种。差错报告就是数据在网络中进行转发时，可能会出现一些错误，比如，数据报经过路由器时发现 TTL=0，那么路由器就会丢弃该报文，然后向发送端发送一个 ICMP 报文。而网络探测的功能，最常用的就是 ping 工具呢，这个 ping 工具基于的就是 ICMP 的回声请求应答报文，属于 ICMP 中的一种报文格式。具体的就不细说了。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://juejin.im/post/6844903518365564936#heading-11" target="_blank" rel="noopener">计算机网络知识解析</a></li><li><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">CS-NOTE</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文旨在介绍计网的相关基础知识，只介绍到网络层之上&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算机网络概述&lt;/li&gt;
&lt;li&gt;应用层&lt;/li&gt;
&lt;li&gt;Socket&lt;/li&gt;
&lt;li&gt;传输层&lt;/li&gt;
&lt;li&gt;网络层&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="计算机网络基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Reids和Memcached对比</title>
    <link href="http://yoursite.com/2020/09/15/Reids%E5%92%8CMemcached/"/>
    <id>http://yoursite.com/2020/09/15/Reids%E5%92%8CMemcached/</id>
    <published>2020-09-15T03:19:09.000Z</published>
    <updated>2020-11-02T09:24:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reids和Memcached对比"><a href="#Reids和Memcached对比" class="headerlink" title="Reids和Memcached对比"></a>Reids和Memcached对比</h1><blockquote><p>本文简单介绍了Redis和Memcached的区别</p></blockquote><a id="more"></a><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ol><li>数据类型<ul><li>Redis支持String、hash等5种类型</li><li>Memcached只支持hash</li></ul></li><li>单线程和多线程<ul><li>Redis是单线程请求，所有命令串行执行，并发情况下数据是一致的；但是性能受限于CPU，单实例的QPS在4-6w</li><li>Memcached是多线程，在单实例的情况下，可以达到写入60-80w qps，读80-100w</li></ul></li><li>持久化<ul><li>Redis支持持久化，使用AOF或者RDB</li><li>Memcached不支持持久化</li></ul></li><li>对热点、bigkey的支持<ul><li>QPS较高的情况下容易造成redis阻塞：单线程CPU饱和</li><li>memcached多线程，支持较好</li></ul></li><li>高可用/HA<ul><li>Redis哨兵模式master-slave，支持多级复制和增量复制</li><li>Memcached无法高可用</li></ul></li><li><b>发布订阅</b><ul><li>Redis支持pub/sub，可以用来订阅和通知</li><li>Memcached没有订阅</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Memcached可以提供更高的QPS，在请求量巨大的时候可以使用Memcached</li><li>Memcached无法持久化且可用性不高，在承载巨大的并发请求时，应采用多活结构来提高可用性</li><li>可以一台服务器部署多个Memcached实例，减少单实例的压力</li><li>大部分情况应使用Redis，毕竟Redis可用性高，支持持久化</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Reids和Memcached对比&quot;&gt;&lt;a href=&quot;#Reids和Memcached对比&quot; class=&quot;headerlink&quot; title=&quot;Reids和Memcached对比&quot;&gt;&lt;/a&gt;Reids和Memcached对比&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文简单介绍了Redis和Memcached的区别&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="Memcached" scheme="http://yoursite.com/tags/Memcached/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解:39,41,42</title>
    <link href="http://yoursite.com/2020/06/27/LeetCode%E9%A2%98%E8%A7%A3-39-41-42/"/>
    <id>http://yoursite.com/2020/06/27/LeetCode%E9%A2%98%E8%A7%A3-39-41-42/</id>
    <published>2020-06-27T10:31:15.000Z</published>
    <updated>2020-06-27T13:45:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><blockquote><p>第39题：<a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">组合总和(中等)</a></p><p>第41题：<a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">缺失的第一个正数(困难)</a></p><p>第42题：<a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水(困难)</a></p><p>补充：个人项的题解，没有图解，没有视频。</p></blockquote><a id="more"></a><hr><h1 id="第39题：组合总和"><a href="#第39题：组合总和" class="headerlink" title=" 第39题：组合总和 "></a><font color="red"> 第39题：组合总和 </font></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个无重复元素的数组<code>candidates</code> 和一个目标数<code>target</code> ，找出<code>candidates</code> 中所有可以使数字和为<code>target</code>的组合。<code>candidates</code> 中的数字可以无限制重复被选取。数组中所有元素都是正数，解集不能重复。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这种题型，只有回溯这一种解法，涉及到回溯，所谓回溯，就是稍微有一点技巧的穷举法，穷举法一般意味着高空间利用率和时间利用率，因此只要涉及到回溯，就要考虑剪枝。其次，遇到无序数组，如果题目没有要求时间复杂度必须在O(n)，一般情况下都可以去排序，而本题在排序后可以达到剪枝的效果。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(candidates, target, ans, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, </span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> target, </span></span></span><br><span class="line"><span class="function"><span class="params">                    List&lt;List&lt;Integer&gt;&gt; ans, </span></span></span><br><span class="line"><span class="function"><span class="params">                    Deque&lt;Integer&gt; path,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> begin)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt; candidates.length; i++)&#123;</span><br><span class="line">          <span class="comment">// 这一步是剪枝操作，很好理解</span></span><br><span class="line">            <span class="keyword">if</span>(candidates[i] &gt; target) <span class="keyword">return</span>;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates, target - candidates[i], ans, path, i);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="第41题：缺失的第一个正数"><a href="#第41题：缺失的第一个正数" class="headerlink" title=" 第41题：缺失的第一个正数 "></a><font color="red"> 第41题：缺失的第一个正数 </font></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p><blockquote><p>时间复杂度: $O(n)$</p><p>空间复杂度: $O(1)$</p></blockquote><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,0]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>时间复杂度O(n)：只能进行遍历的操作</li><li>空间复杂度O(1)：所有操作必须是原地的</li></ol><p>这两点带来的局限性，导致了本题必须要抓住一个关键点：<strong>一个长度为n的数组nums，其序列中如果没有缺失的正数，则$nums[i] == i$</strong>，也就是说，如果在这个数组的<code>idx</code>位置其值不是<code>idx+1</code>，则这个位置的数就是缺失的。因此，这道题的解题思路就确定了：使数组<code>idx</code>位置的值可判断，不一定非要$nums[idx] == idx + 1$，也可以使<code>idx</code>位置的值为负(<a href="https://leetcode-cn.com/problems/first-missing-positive/solution/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/" target="_blank" rel="noopener">题解</a>) 。本题将$nums[idx] == idx +１$。</p><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            exchange(nums, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i+<span class="number">1</span>) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 递归出口：位置上的值是正确的值，或者超出了范围</span></span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span> || num &gt; nums.length || nums[num - <span class="number">1</span>] == num) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[num - <span class="number">1</span>];</span><br><span class="line">            nums[num - <span class="number">1</span>] = num;</span><br><span class="line">            exchange(nums, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="第42题：接雨水"><a href="#第42题：接雨水" class="headerlink" title=" 第42题：接雨水 "></a><font color="red"> 第42题：接雨水 </font></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="/2020/06/27/LeetCode%E9%A2%98%E8%A7%A3-39-41-42/getRain.png" alt="接雨水示意图"></p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题比较难，我的第一反应特别蠢：从底向上一层层遍历，看每一层最多能接收多少雨水。这样的时间复杂度是$O(MN)$，LC直接通过不了。实际上这道题是有好的思路的，核心想法就是：<strong>确定每个<code>idx</code>位置上能装多少雨水。</strong>而每个<code>idx</code>上装雨水的量，取决于在这个位置左右两端最高的那堵墙，因此如果我们知道每个位置上左右两端的最高位置，则可以完成计算：$res = Math.min(leftMax[idx], rightMax[idx]) - height[idx]$</p><h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.length, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span> || len == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        rightMax[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            leftMax[i] = Math.max(leftMax[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 这一步有点技巧，确定右边最大的值需要从右到左遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            rightMax[i] = Math.max(rightMax[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            ans += Math.min(leftMax[i], rightMax[i]) - height[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：$O(n)$，只进行了遍历操作</li><li>空间复杂度：$O(n)$，保存了每个<code>idx</code>位置左右两端的最大值</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>这道题其实还有更好的解法：<a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/" target="_blank" rel="noopener">双指针法</a>，空间复杂度降到了$O(1)$，这种方法特别巧妙，利用了从左到右和从右到左两种不同的状态来计算在<code>idx</code>位置上可以存的雨水。但是这种方法在面试时是很难想出来的，因此这里就不赘述了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目名称&quot;&gt;&lt;a href=&quot;#题目名称&quot; class=&quot;headerlink&quot; title=&quot;题目名称&quot;&gt;&lt;/a&gt;题目名称&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;第39题：&lt;a href=&quot;https://leetcode-cn.com/problems/combination-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;组合总和(中等)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第41题：&lt;a href=&quot;https://leetcode-cn.com/problems/first-missing-positive/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;缺失的第一个正数(困难)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第42题：&lt;a href=&quot;https://leetcode-cn.com/problems/trapping-rain-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;接雨水(困难)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;补充：个人项的题解，没有图解，没有视频。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Integer</title>
    <link href="http://yoursite.com/2020/03/13/%E6%B5%85%E8%B0%88Integer/"/>
    <id>http://yoursite.com/2020/03/13/%E6%B5%85%E8%B0%88Integer/</id>
    <published>2020-03-13T12:55:58.000Z</published>
    <updated>2020-03-13T14:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本博客主要涉及以下几个内容：</p><ol><li>装箱与拆箱</li><li>装箱生成的Integer在哪里</li><li>案例</li></ol></blockquote><a id="more"></a><h1 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h1><p>　　Java中有八种基本数据类型: byte, short, int, long, float, double, char, boolean。这八种基本数据类型对应着八个包装类，<strong>基本数据类型</strong>转换为<strong>包装类</strong>叫做装箱，反之叫做拆箱。</p><h2 id="为什么要进行装箱和拆箱？"><a href="#为什么要进行装箱和拆箱？" class="headerlink" title="为什么要进行装箱和拆箱？"></a>为什么要进行装箱和拆箱？</h2><p>　　Java中最主要有三类存储空间: 栈，堆，方法区。栈中存基本数据类型和堆中对象的引用；堆中一般存放运行时的动态数据，最主要有<code>new</code>出来的对象;方法区中存储的数据不是本文的重点，就不细说了，本文只涉及方法区中的常量池，常量池中存储的是常量。<br>　　基本数据类型因为经常被使用，所以为了提高效率，都放在栈中进行运算；但是栈中的数据并不具备持久性，对于Java中同样经常使用的容器，栈中的数据显然不具备放入容器中的资格，因此才有了装箱和拆箱的步骤。JDK5后，Java实现了自动装箱和拆箱。</p><h2 id="如何进行装箱和拆箱"><a href="#如何进行装箱和拆箱" class="headerlink" title="如何进行装箱和拆箱"></a>如何进行装箱和拆箱</h2><p>　　这里不放java反编译后的结果了，直接说结论。只给出<code>int</code>和<code>Integer</code>之间的转换。</p><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer in = <span class="number">9</span>; <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> i = in; <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><ul><li>装箱调用：<code>Integer in = Integer.valueOf(9)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>拆箱调用：<code>int i = in.intValue()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="装箱生成的Integer去了哪里？"><a href="#装箱生成的Integer去了哪里？" class="headerlink" title="装箱生成的Integer去了哪里？"></a>装箱生成的Integer去了哪里？</h1><p>　　上面的源码引出了一个新的类<code>IntegerCache</code>, 这个类是<code>Integer</code>类的静态内部类，内部存在三个常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br></pre></td></tr></table></figure><p>　　常量<code>high</code>会在类中的静态代码块中被赋值为<code>127</code>，<code>cache[]</code>中存储了<code>value</code>为<code>-128 ~ 127</code>的<code>Integer</code>包装类。<br>　　由源码可知：当装箱的<code>int</code>值在<code>-128 ~ 127</code>中时，<code>Integer</code>会直接返回常量池中的对象，而这些对象，在<code>Integer</code>类加载的时候就被创建了，因此不会再开辟多余的空间。而当<code>int</code>的值超过范围，则会在堆中重新开辟<code>Integer</code>对象的空间。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">128</span>;</span><br><span class="line">Integer A = a;</span><br><span class="line">Integer AA = <span class="number">99</span>;</span><br><span class="line">Integer B = b;</span><br><span class="line">Integer BB = <span class="number">128</span>;</span><br><span class="line">System.out.println(AA == A); <span class="comment">// true</span></span><br><span class="line">System.out.println(BB == B); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>解释：</p><ol><li><code>A</code>和<code>AA</code>都指向常量池中的<code>Integer</code>对象</li><li><code>B</code>和<code>BB</code>都是在执行装箱操作后<code>new</code>出来的<code>Integer</code>对象，因此地址不同</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本博客主要涉及以下几个内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;装箱与拆箱&lt;/li&gt;
&lt;li&gt;装箱生成的Integer在哪里&lt;/li&gt;
&lt;li&gt;案例&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解(一):10, 15, 57, 59</title>
    <link href="http://yoursite.com/2020/03/07/LeetCode%E9%A2%98%E8%A7%A3-%E4%B8%80-10-15-57-59/"/>
    <id>http://yoursite.com/2020/03/07/LeetCode%E9%A2%98%E8%A7%A3-%E4%B8%80-10-15-57-59/</id>
    <published>2020-03-07T12:30:14.000Z</published>
    <updated>2020-03-08T03:48:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><blockquote><p>第10题：正则表达式匹配(困难)<br>第15题：三数之和(中等)<br>第57题：和为s的连续正数序列(简单)<br>第59题：II.队列的最大值(中等)</p></blockquote><a id="more"></a><hr><h1 id="第10题：正则表达式匹配"><a href="#第10题：正则表达式匹配" class="headerlink" title="第10题：正则表达式匹配"></a><font color="red">第10题：正则表达式匹配</font></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 <code>&#39;.&#39;</code>和 <code>&#39;*&#39;</code>的正则表达式匹配。</p><blockquote><p><code>&#39;.&#39;</code>匹配任意单个字符<br><code>&#39;*&#39;</code>匹配零个或多个前面的那个元素</p></blockquote><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>s 可能为空，且只包含从 a-z 的小写字母</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符<code>&#39;.&#39;</code>和 <code>&#39;*&#39;</code></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　见到字符串匹配，字符串操作的题，第一反应就是DP。而且DP数组中的下标如<code>i</code>一般都代表匹配字符串的<code>0: i - 1</code>或者<code>i: len - 1</code>。<br>　　很显然，这道题可以用DP求解，<code>dp[i][j]</code>表示<code>p[0: j-1]</code>可以和<code>s[0: i - 1]</code>匹配。</p><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><ul><li><code>dp[0][0] = true</code>: 因为<code>null</code>匹配<code>null</code></li><li><code>dp[0&lt; i &lt;= slen][0] = false</code>: p为<code>null</code>， 无法匹配任何值</li><li><code>dp[0][0&lt; j＜= plen]</code>: 这个初始化稍微复杂一点，因为例如<code>a*</code>或者<code>a*b*</code>这种都是可以匹配<code>null</code>的，因此我们用一个循环来初始化这种状态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>　　这题最难的地方在状态转移方程的求解，即如何求得<code>dp[i][j]</code>？</p><ol><li>第一种情况: <code>s[i - 1] == p[j - 1] ||　ｐ[j - 1] == &#39;.&#39;</code>，此时<code>dp[i][j] = dp[i - 1][j - 1]</code></li><li>第二种情况: <code>p[j - 1] == &#39;*&#39;</code>，分别有两种可能需要考虑: <ul><li><code>s[i - 1] == p[j - 2] || p[j - 2] == &#39;.&#39;</code>，此时又有三种情况，只要一种成立即可:<ul><li><code>*</code> 匹配0次: <code>dp[i][j] = dp[i][j - 2]</code>, 因为匹配0次的话，<code>p[0: j]</code>的作用等同于<code>p[0: j - 2]</code></li><li><code>*</code> 匹配1次: <code>dp[i][j] = dp[i][j - 1]</code>, 这个很容易理解</li><li><code>*</code> 匹配多次: <code>dp[i][j] = dp[i - 1][j]</code>, 这是最难理解的，因为如果<code>*</code>匹配了多次，则s字符串增加一个与<code>p[j - 2]</code>相同的数并无影响</li></ul></li><li><code>s[i - 1] != p[j - 2] || p[j - 2] != &#39;.&#39;</code>，此时只可能有一种情况:<ul><li><code>*</code> 只能匹配0次: <code>dp[i][j] = dp[i][j - 2]</code></li></ul></li></ul></li><li>其他情况: <code>dp[i][j] = false</code></li></ol><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slen = s.length(), plen = p.length();</span><br><span class="line">        <span class="comment">// dq[i][j] means p[0 : j] matches s[0 : i]</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[slen + <span class="number">1</span>][plen + <span class="number">1</span>]; </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= slen; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'.'</span>)</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p.charAt(j - <span class="number">2</span>) == <span class="string">'.'</span> || p.charAt(j - <span class="number">2</span>) == s.charAt(i - <span class="number">1</span>))&#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">2</span>] || dp[i][j - <span class="number">1</span>]; </span><br><span class="line">                    &#125;<span class="keyword">else</span> dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[slen][plen];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: <script type="math/tex">O(MN)</script> </li><li>空间复杂度: <script type="math/tex">O(MN)</script></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>　　本题还可以用回溯法做，但是笔者特别讨厌用递归，虽然递归用起来很简洁，但是空间利用率实在是太感人了，计算起来也十分麻烦。笔者曾经用递归写过一个项目的方法，出现堆栈溢出问题的时候简直崩溃，因此立下flag：能不用递归就不用递归。因此回溯的算法就不写了。<br><strong>回溯法思路：</strong></p><ul><li>首字符匹配，且p的后一字符不是<code>*</code> : 匹配<code>(s.substring(1), p.substring(1))</code></li><li>首字符匹配，且p的后一字符是<code>*</code> : 匹配<code>(s, p.substring(2)) ||　(ｓ.substring(1), p)</code></li><li>首字符不匹配，且p的后一字符是<code>*</code> : 匹配<code>(s, p.substring(2))</code></li><li>递归出口:  <ul><li>首字符不匹配，且p的后一字符不是<code>*</code> : <code>return false</code></li><li>p为空: <code>return s为空</code></li><li>这里注意一下，s为空并不作为出口，而作为(首字符不匹配)的情况</li></ul></li></ul><h3 id="遇到过的问题"><a href="#遇到过的问题" class="headerlink" title="遇到过的问题"></a>遇到过的问题</h3><ul><li>将<code>*</code>看成了匹配零次或无数次任意字符，导致直接做错</li><li>匹配多次的方程没想出来</li></ul><hr><p>　</p><h1 id="第15题：三数之和"><a href="#第15题：三数之和" class="headerlink" title="第15题：三数之和"></a><font color="red">第15题：三数之和</font></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意:</strong> 答案中不可以包含重复的三元组。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　这道题最主要的就是要想到用双指针的方法去求解twoSum，想到了就很简单。写博客的时候不小心写上了，改名字有点费事，所以就贴个代码上去。暴力求解这种基本谁都能想到，但是如果用暴力去做算法题的话，就失去了做算法题的意义，不是吗？</p><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// O(nlgn)</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// O(n^2)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[i], left = i+<span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">int</span> twoSum = nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(twoSum == target)&#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="keyword">while</span>(left + <span class="number">1</span> &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(right - <span class="number">1</span> &gt; i + <span class="number">1</span> &amp;&amp; nums[right] == nums[right-<span class="number">1</span>]) right--;</span><br><span class="line">                    left++;right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(twoSum &gt; target) right--;</span><br><span class="line">                <span class="keyword">else</span> left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: <script type="math/tex">O(N^2)</script></li><li>空间复杂度: <script type="math/tex">O(1)</script></li></ul><hr><h1 id="第57题-和为s的连续正数序列"><a href="#第57题-和为s的连续正数序列" class="headerlink" title="第57题: 和为s的连续正数序列"></a><font color="red">第57题: 和为s的连续正数序列</font></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　这道题比较简单，采用滑动窗口法进行计算即可。笔者不擅长解答除了找规律外的数学问题，所以数学解法就不考虑了。数学解法固然巧妙，但是我为了找工作而刷题，就不需要整这些花里胡哨的了，只需要保证时间空间复杂度尽可能少一些就ok。</p><h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">2</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>) ans.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; right &lt;= target / <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (left + right) * (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++) temp[i - left] = i;</span><br><span class="line">                ans.add(temp);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) left++;</span><br><span class="line">            <span class="keyword">else</span> right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>[][]) ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: <script type="math/tex">O(N)</script></li><li>空间复杂度: <script type="math/tex">O(N)</script>: 使用了一个数组来临时存储序列</li></ul><h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><p>　　这道题很简单，但是笔者一开始并没有想到用滑动窗口法去解决问题，我第一反应是先固定左端的数，然后用二分查找的算法去找右边的数。算法是没错的，时间复杂度<code>O(NlgN)</code>也算马马虎虎，但是死活提交不过。后来Debug才发现，原来是计算的<code>sum</code>越界了，<code>int</code>最大能取到<font color="brown">$ 2^{31} - 1 = 2147483647 = 0x7fffffff $</font>, 如果再加1，就会变最小负值，然后就一直是负数了，除非再加一次最大值。随便举个例子: 计算<code>1, 2, 3,..., 8000000</code>就越界了。</p><hr><h1 id="第59题：II-队列的最大值"><a href="#第59题：II-队列的最大值" class="headerlink" title="第59题：II.队列的最大值"></a><font color="red">第59题：II.队列的最大值</font></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　这道题卡了我很久，原因是我忽略了<strong>均摊时间复杂度的含义</strong>: 进行N次操作，其每次操作的平均复杂度为O(1)。<br>　　要解决这道题有两个很重要的点: </p><ol><li>只要插入了一个最大值，在前面的值<code>pop_front</code>前，这个最大值就不会改变。</li><li>如何保证最大值被<code>pop</code>掉后，我们可以找到次大值？: 只需要将正常入队的序列进行某些操作后保存为一个<strong>非递增的辅助序列</strong>即可。<ul><li>解释：假设我们有序列<code>xAyBzC</code>，其中<code>A &gt; x; B &gt; y; C &gt; z; A &gt; B &gt; C</code>，那么辅助序列<code>ABC</code>就是在进行<code>max_value()</code>操作中只可能出现的三个最大值，因为有了<code>A</code>，前面的<code>x</code>就失去了价值，而<code>A</code>一旦被<code>pop</code>后，<code>A</code>前面的数就不会在序列里了，子序列<code>yBzC</code>中最大的就是<code>B</code>，以此类推。因此这是一个线性问题。</li></ul></li></ol><h2 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; aux;</span><br><span class="line">    Deque&lt;Integer&gt; dq;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aux = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.dq = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aux.size() == <span class="number">0</span> ? -<span class="number">1</span> : aux.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        dq.addLast(value);</span><br><span class="line">        <span class="keyword">while</span>(aux.peekLast() != <span class="keyword">null</span> &amp;&amp; aux.peekLast() &lt; value) aux.pollLast();</span><br><span class="line">        aux.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dq.size() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Integer 没进入常量池，不能用 == 来判断</span></span><br><span class="line">        <span class="keyword">if</span>(dq.peek().equals(aux.peek())) aux.pollFirst();</span><br><span class="line">        <span class="keyword">return</span> dq.pollFirst();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="踩过的坑-1"><a href="#踩过的坑-1" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><ol><li>没理解均摊复杂度</li><li>没想到用非递增的辅助序列</li><li>两个没有拆箱的<code>Integer</code>对象，不能用<code>==</code>来判断其<code>value</code>是否相等。(基于这点，笔者想要写一篇文章来详细解析一下这种包装类，届时会放链接)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目名称&quot;&gt;&lt;a href=&quot;#题目名称&quot; class=&quot;headerlink&quot; title=&quot;题目名称&quot;&gt;&lt;/a&gt;题目名称&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;第10题：正则表达式匹配(困难)&lt;br&gt;第15题：三数之和(中等)&lt;br&gt;第57题：和为s的连续正数序列(简单)&lt;br&gt;第59题：II.队列的最大值(中等)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java中的HashMap以及红黑树</title>
    <link href="http://yoursite.com/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://yoursite.com/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2019-12-15T13:21:42.000Z</published>
    <updated>2020-03-07T12:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇博客涉及以下几个内容：</p><ol><li>HashMap的部分源码讲解</li><li>红黑树的数据结构</li></ol></blockquote><a id="more"></a><h1 id="HashMap的结构和源码"><a href="#HashMap的结构和源码" class="headerlink" title="HashMap的结构和源码"></a>HashMap的结构和源码</h1><p>　Java中集合一共可以分为两类，一类是Collection，代表是ArrayList；一类是Map，代表是HashMap。而HashMap存储结构是<strong>哈希表</strong>。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>　哈希表的本质是一个数组，但是性能比数组高很多，因为动态数组的插入和删除操作对应的时间复杂度是O(n)，而哈希表的增删改查操作时间复杂度均为O(1)。<br>　为什么快？<br>　哈希表利用函数映射的方式来将数据映射到其维护的数组上，这样执行增删改查操作时只需要通过这个函数就能找到数组的下标，从而实现快速定位。相比数组的顺序存储，哈希表是无序的，因此在执行删除操作时，并不需要移动其他下标的元素。<strong>用来执行元素映射的函数叫做哈希函数：hashcode()。</strong><br>　存储方式如下图：<br>  <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/hashtable.png" alt="哈希表"></p><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>　由上述的存储方式可知，<strong>如果两个不同元素通过哈希函数的值相同，则单纯用数组存储就会有冲突。</strong>这种方法最直接的解决办法就是设计优秀的哈希函数，把冲突的可能性降至最低，但是再优秀的哈希函数，都会有可能发生冲突。因此，需要有一种方法来解决冲突问题。<br>　常见的方法有：</p><ol><li>线性探测法，发生冲突后顺序找下一块空的地址。（运气差的话增删改查都会变O(n)）</li><li>对冲突的地址使用另一个Hash函数</li><li>链地址法：数组的每个位置都存一个链表。（运气差的话，查找会变O(n)）</li></ol><p>　HashMap解决冲突的办法就是<strong>链地址法</strong>，数组的每个位置我们称之为桶。如果运气不好的话，所有的数字都在一个桶里，那么查找一个链表的时间复杂度是O(n)，这很低效。<strong>所以JDK8之后，当一个桶里存放的元素超过8个时，则这个桶里会自动变成红黑树，这样查找的效率就成了O(logn)。</strong></p><h2 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h2><h3 id="HashMap主干数组"><a href="#HashMap主干数组" class="headerlink" title="HashMap主干数组"></a>HashMap主干数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是HashMap内部维护的一个数组，这个数组初始值为空，主干长度是2的次幂</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p><code>Node&lt;K,V&gt;</code>是HashMap的一个静态内部类(<strong>使用静态内部类是为了方便继承，TreeNode就继承了这个Node类</strong>)，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map.Entry是一个接口</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//此Node的hash值</span></span><br><span class="line">       <span class="keyword">final</span> K key; <span class="comment">// 此Node的key</span></span><br><span class="line">       V value; <span class="comment">// 此Node的value</span></span><br><span class="line">       Node&lt;K,V&gt; next; <span class="comment">//指向下一个Node</span></span><br><span class="line">       </span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line"> <span class="comment">/* ------- 以上是重点 ---------*/</span>      </span><br><span class="line"> <span class="comment">// get,set,toString,hashcode,equels</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　其存储结构如下图：<br><img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/hashmapNode.png" alt="Node存储结构"></p><p>　当数组中某个桶存储的元素超过一定的数量后(默认是8个)，则Node会被转化为TreeNode进行存储，TreeNode继承自<code>LinkedHashMap.Entry&lt;K,V&gt;</code>，关于<code>LinkedHashMap</code>可以移步我的博客：<a href>浅谈Java中LinkedHashMap</a>，<code>TreeNode</code>的解析将在下文的红黑树种讲解。</p><h3 id="几个重要字段"><a href="#几个重要字段" class="headerlink" title="几个重要字段"></a>几个重要字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认字段值：</span></span><br><span class="line"><span class="comment">//1.数组的默认初始容量是16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//2.数组的最大容量为2的30次方(int最大是 2^31-1)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//3.当数组中存储的值超过目前容量的75%，执行数组的扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//4.当数组中一个桶存储的元素超过8个时，list将会转化为tree</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//5.红黑树的最小容量为64</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//6.执行扩容操作时会将小于元素小于6的数还原</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重要字段：</span></span><br><span class="line"><span class="comment">//1.HashMap中实际存储的'key-value'数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//2.数组负载因子，默认是75%</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//3.数组存储阈值，如果key-value的数量大于该阈值，则进行数组扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">/** 4.被修改次数，由于HashMap线程不安全，如果对HashMap进行迭代的时候，其他线程改变了HashMap的结构(增、删、改)，则就会抛出ConcurrentModificationException异常 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><h3 id="HashMap构造器"><a href="#HashMap构造器" class="headerlink" title="HashMap构造器"></a>HashMap构造器</h3><p>　HashMap一共四种初始化的方式</p><ul><li>我们最常用的构造器是无参构造器：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个构造器不初始化table，为table分配空间会在内部的resize()函数中进行，下文会讲。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>HashMap也可以指定容量和负载因子进行初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span>+</span><br><span class="line">                                               loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//此步将initalCapacity规范成2的次幂</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>剩余两种构造器比较容易</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个不讲了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过一个Map实例化HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">//相当于一个拷贝工作，这个false我目前不是很理解，如果为true的话，在内部会执行afterNodeInserction函数，但是我看这个函数是空的，所以不是很理解。</span></span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put函数"><a href="#put函数" class="headerlink" title="put函数"></a>put函数</h3><p>　上面我们看到，如果使用缺省的构造器，我们是不会初始化table的，而真正初始化table需要等到我们第一次使用put操作。这是一种懒加载的机制，用来节约内存资源。<br>　以下是源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*定义一个数组tab，一个链表p表示桶里的链表情况，n表示数组长度，i表示key在数组中的索引*/</span></span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">      <span class="comment">/*如果table没有初始化，则resize()，下文会讲*/</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line">      <span class="comment">/*如果key所在桶里为空，则为这个key-value新建一个Node存放*/</span></span><br><span class="line">      <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*如果桶里不为空，则新建一个节点e用来寻找新插入或者修改的Node的位置*/</span></span><br><span class="line">          Node&lt;K,V&gt; e; K k;</span><br><span class="line">          <span class="comment">/*如果key相等，则不插入新节点，e指向要修改val的位置*/</span></span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              e = p;</span><br><span class="line">          <span class="comment">/*如果桶里是红黑树，则执行红黑树的插入操作*/</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">              e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">/*若桶里只是链表，则遍历这个链表*/</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">              <span class="comment">/*在表尾插入新的节点*/</span></span><br><span class="line">                  <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                      <span class="comment">/*如果链表的长度大于阈值，将链表转换成红黑树*/</span></span><br><span class="line">                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                          treeifyBin(tab, hash);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">/*若在遍历链表时，发现有Node的key与插入的key相等，则退出遍历*/</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  <span class="comment">/*p指向的Node沿着链表一直向后*/</span></span><br><span class="line">                  p = e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/*如果e不为null，则e指向要修改val的Node*/</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">              V oldValue = e.value;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                  e.value = value;</span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*新插入节点后增加HashMap的修改次数，*/</span></span><br><span class="line">      ++modCount;</span><br><span class="line">      <span class="comment">/*key-value的数量大于阈值后对数组进行扩容*/</span></span><br><span class="line">      <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">          resize();</span><br><span class="line">      afterNodeInsertion(evict);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>　我看了一下网上的流程图都不是很准确，我这里用文字表示一下，最近实在是太累了，等我写LinkedHashMap的时候把图补上。<br>　<strong>HashMap中put的流程如下：</strong></p><ol><li>判断table是否为空，为空则进行resize()初始化table</li><li>计算插入的Key的在table中的索引i</li><li>若table[i]中没有值，则新建一个Node插入该位置</li><li>若有值，则判断插入的key是否与table[i]中首节点的key相等，若相等则直接替换val</li><li>若key不等，则判断table[i]存放的是否为红黑树，若为红黑树，则进行红黑树的插入操作<ol><li>红黑树中也会进行key值的比较，若相等则直接修改val，若不等则插入新节点</li></ol></li><li>若table[i]中存放的是链表，则遍历链表<ol><li>若遍历过程中发现有key相等，则直接替换</li><li>若遍历到链表的结尾，则在结尾插入新的Node<ol><li>若此时table[i]内存放的元素大于8，则将链表转化成红黑树，并对红黑树进行扩容</li></ol></li></ol></li><li>插入成功后，若数组中存放的key-value数值大于数组阈值后，则进行resize()扩容操作。</li></ol><h3 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h3><p>　有put就有get，这是HashMap最常用的两个函数，其主要的难点在于红黑树的查找，这在下文会讲。<br>　以下是源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt; e;</span><br><span class="line">     <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line"> <span class="comment">/*定义数组，链表和待查找的节点，n表示数组的长度，k表示遍历节点的key*/</span></span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">     <span class="comment">/*若不满足查找条件比如数组不存在，桶里没值，返回null*/</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">/*检查第一个节点，若想等则返回*/</span></span><br><span class="line">         <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">             ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             <span class="keyword">return</span> first;</span><br><span class="line">         <span class="comment">/*若不等，则看其下一个有没有值，没有则返回null，TreeNode继承的爷爷辈是Node，因此可以调用父类对象的next，即使其已经是TreeNode了*/</span></span><br><span class="line">         <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">/*若有值则寻找，红黑树查找或列表遍历*/</span></span><br><span class="line">             <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                 <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">return</span> e;</span><br><span class="line">             &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h3><p>　最后一项删操作，如果增和查的操作都了解的话，删操作也就通俗易懂。其大体的思路就是：查到需要删除的节点，然后执行红黑树的删除或者链表的删除。<br>　源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.remove and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to match if matchValue, else ignored</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue if true only remove if value is equal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*定义一个数组，一个链表，n表示数组的长度，index表示要删除的数组索引位置*/</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">/*table为空或者桶内没有数据，无法执行删除，返回null*/</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*找到要删除的节点，用node指向它*/</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*删除node*/</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resize函数"><a href="#resize函数" class="headerlink" title="resize函数"></a>resize函数</h3><p>　在我们进行HashMap操作的时候会经常会有扩容的需求，因此了解扩容的机制十分重要。<br>　源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*此方法不能被重写*/</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">   <span class="comment">/*保存旧的table，并保存旧的阈值和容量*/</span></span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">/*若超过最大容量，则将阈值设置成2^31-1*/</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">/*若当前容量在最小值和最大值之间，则把新容量和新阈值扩大一倍*/</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*若阈值不为0，但数组容量为0，将容量扩展成阈值大小*/</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="comment">/*第一次初始化table，设置容量为16，阈值为16*0.75*/</span></span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*通过新容量设置新阈值，如果新容量比最大容量小，则为'新容量*负载因子' */</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="comment">/*执行扩容，对里面每个元素进行重新排放*/</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="红黑树讲解"><a href="#红黑树讲解" class="headerlink" title="红黑树讲解"></a>红黑树讲解</h1><p>　JDK8之后，HashMap引入了红黑树，红黑树是一种自平衡二叉查找树。本节将通过数据《算法》和HashMap的部分源码来解析红黑树的结构。</p><h2 id="2-3平衡树"><a href="#2-3平衡树" class="headerlink" title="2-3平衡树"></a>2-3平衡树</h2><p>　理解红黑树的平衡是一件比较抽象的事情，很多博客并不讲红黑树是如何实现平衡的。本文通过2-3平衡树来讲解一下”平衡”的概念。</p><h3 id="完美平衡"><a href="#完美平衡" class="headerlink" title="完美平衡"></a>完美平衡</h3><p>　完美平衡是指，所有空结点到根结点的的距离相等，比如下图就是一个完美平衡的二叉树:<br><img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/BinaryTree.png" alt="完美平衡树"><br>　很明显可以看出来，如果一颗普通的二叉树要达到完美平衡，其对于结点的数量是有要求的: $ n  = 2^{k} - 1  $ , 如果结点数量不满足这个等式, 那么一颗二叉树始终不可能是平衡的。<br>　<font color="red"><strong>那么如何使一棵树不管有几个结点都能保持平衡呢?</strong></font><br>　这里设想一下, 左右子树在最理想的情况下高度差是多少? 答案很明显是1, 因为任意数都可以在$ 2^{k} $和$ 2^{k+1} $之间。因此如果我们把高的子树的高度减一, 那么这棵树就实现了完美平衡。</p><h3 id="2-3树的基本结构"><a href="#2-3树的基本结构" class="headerlink" title="2-3树的基本结构"></a>2-3树的基本结构</h3><p>　如何实现高度减一呢? 有一个特别简单的办法, 那就是新定义一个结点:3-结点。我们将普通二叉树的结点定义为：2-结点。2-结点存储一个key，并且有左右两个子树; 3-结点存储两个key, 并且有左中右三个子树。2-3树就是由2-结点和3-结点组成的树, 二叉树也是2-3树的一种。下面是一个2-3树示例:<br><img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/2-3Tree.png" alt="2-3平衡树"></p><h3 id="实现完美平衡"><a href="#实现完美平衡" class="headerlink" title="实现完美平衡"></a>实现完美平衡</h3><p>　2-3树可以始终保持完美平衡, 因为在2-3树中插入新值不会破坏其平衡性, 下面我们仔细讲一讲如何实现2-3树的插入操作。<br>　一个树在第一次生成的时候一定是平衡的, 因为只有一个2-结点, 当我们在一个平衡的树的底部插入新结点的时候会破坏其平衡性。因此, 我们在讲解2-3树的插入操作前, 必须有一个前提: <strong>2-3树在插入前是平衡的</strong>。<br>　当我们插入一个新结点时，会遇到以下的几种情况: </p><ul><li>在一个2-结点的底部插入新键: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/insert1.png" alt="2-结点插入"></li><li>在一个没有父节点的3-结点底部插入新键: 临时构建一个4-结点。<img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/insert2.png" alt="3-结点插入"></li><li>在一个父节点是2-结点的3-结点底部插入新键: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/insert3.png" alt="3-结点插入2"></li><li>在一个父节点是3-结点的3-结点底部插入新键: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/insert4.png" alt="3-结点插入3"> </li></ul><p>　可以看到, 2-3树之所以能保持平衡性, 是因为其在插入的过程中, 不会在底部增加高度, 而是自下而上去寻找一个2-结点能够吸收这个高度变化, 如果没有寻找到这个2-结点, 则会通过把遇到的3-结点创建为临时4-结点并分解的方式使左右子树的高度均增加1, 以保证树的平衡。(这里稍微再说一下, 如果这个3-结点不是根结点, 则增加的高度也不会破坏其平衡性, 因为分解4-结点的操作会在顶部生成一个2-结点, 而这个增加的2-结点相当于对3-结点的父结点进行一次插入操作)</p><h3 id="查找和插入操作的复杂度"><a href="#查找和插入操作的复杂度" class="headerlink" title="查找和插入操作的复杂度"></a>查找和插入操作的复杂度</h3><p>　要理解2-3树的操作复杂度, 需要知道树的高度。因为其平衡特性, 2-3树的高度在 $ log_{2}N $ (全是2-结点)和$ log_{3}N $ (全是3-结点)之间。因此, 其查找的复杂度在 $ O(logN) $; 其插入操作需要先查找, 然后进行结点的变换。单个结点变换的复杂度为$ O(1) $, 平均要进行$logN$次变换(最少变换一次: 父结点是2-结点; 最坏变换树的高度: 一路上去全是3-结点, 最后到根结点), 因此插入的复杂度是: $O(logN)+O(logN) = O(logN)$。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>　理解了2-3平衡树后, 红黑树就好理解了。 红黑二叉树的基本思想是用标准的二叉树(全是2-结点)以及一些额外的信息(替换3-结点)来表示2-3平衡树。这个额外的信息是: 红链接将两个2-结点组成一个3-结点, 黑链接表示2-3树的普通链接。红链接指向的结点我们会标记为红色结点。关于一个3-结点和红链接的表示如下图： <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/RBTree.png" alt="红黑树结点"> </p><h3 id="等价定义"><a href="#等价定义" class="headerlink" title="等价定义"></a>等价定义</h3><p>　红黑树可以说是2-3树的变种, 任意的2-3树都能转换成红黑树, 我们可以用一种等价的定义来描述红黑树(和网络上一般讲解的不太一样, 但是都是对的): 红黑树是满足下列条件的二叉查找树:</p><ul><li>红链接均为左链接(即所有的红色结点都是左结点, 根结点必然是黑色);</li><li>没有任何一个结点同时与两条红链接相连;</li><li>该树是完美黑色平衡的</li></ul><p>　满足上述定义的红黑树与相应的2-3树必然是一一对应的。完美黑色平衡是非常直观的，因为红结点不能单独作为2-结点，我们把红链接放平，就是一颗完美平衡的2-3树, 下面是一个简单的示例: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/RedFlat.png" alt="红黑树结点"> </p><h3 id="简单的红黑树结点"><a href="#简单的红黑树结点" class="headerlink" title="简单的红黑树结点"></a>简单的红黑树结点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">Key key;</span><br><span class="line">Value val;</span><br><span class="line">TreeNode left, right; <span class="comment">// 只有左子树和右子树, HashMap中有所不同, 下面再讲</span></span><br><span class="line"><span class="keyword">int</span> N; <span class="comment">//这颗子树中的结点总数</span></span><br><span class="line"><span class="keyword">boolean</span> color; <span class="comment">// 表示从父结点指向它的链接的颜色</span></span><br><span class="line"></span><br><span class="line">TreeNode(Key key, Value val, <span class="keyword">int</span> N, <span class="keyword">boolean</span> color)&#123;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line"><span class="keyword">this</span>.N = N;</span><br><span class="line"><span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面是几个需要用到的简单函数:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(TreeNode x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> x.color == RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(TreeNode x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> x.N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="旋转和颜色变换"><a href="#旋转和颜色变换" class="headerlink" title="旋转和颜色变换"></a>旋转和颜色变换</h3><p>　进行插入的过程中可能会破坏上述性质:  出现红色右链接和两条连续的红链接。这些情况可以通过简单的旋转和颜色变换进行修复。其中旋转是一次进行链接变换的简单操作。</p><ul><li>左旋转: 把一条右红链接转换为左链接, 如图: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/rotateLeft.png" alt="红黑树结点"> </li><li>右旋转: 把一条左红链接转换为右链接, 如图: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/rotateRight.png" alt="红黑树结点"> </li><li>颜色变换: 当左右链接均为红色, 则把两条链接都变黑, 并把根结点变红, 如图: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/flipColor.png" alt="红黑树结点"></li></ul><p>　我们可以利用旋转操作帮我们保证红黑树和2-3树的一一对应, 因此我们无需担心树的平衡性。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li>左旋转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">rotateLeft</span><span class="params">(TreeNode h)</span></span>&#123;</span><br><span class="line">TreeNode x = h.right;</span><br><span class="line">h.right = x.right;</span><br><span class="line">x.left = h;</span><br><span class="line">x.color = h.color;</span><br><span class="line">h.color = RED;</span><br><span class="line">x.N = h.N;</span><br><span class="line">h.N = <span class="number">1</span> + size(h.left) +size(h.right);</span><br><span class="line">retrurn x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>右旋转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">rotateRight</span><span class="params">(TreeNode h)</span></span>&#123;</span><br><span class="line">TreeNode x = h.left;</span><br><span class="line">h.left = x.right;</span><br><span class="line">x.right = h;</span><br><span class="line">x.color = h.color;</span><br><span class="line">h.color = RED;</span><br><span class="line">x.N = h.N;</span><br><span class="line">h.N = <span class="number">1</span> + size(h.left) + size(h.right);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>颜色变换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">filpColors</span><span class="params">(TreeNode h)</span></span>&#123;</span><br><span class="line">h.left.color = BLACK;</span><br><span class="line">h.right.color = BLACK;</span><br><span class="line">h.color = RED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇博客涉及以下几个内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HashMap的部分源码讲解&lt;/li&gt;
&lt;li&gt;红黑树的数据结构&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
