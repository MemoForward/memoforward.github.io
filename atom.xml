<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MemoForward&#39;s Blog</title>
  
  <subtitle>阿星的学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-07-22T05:56:34.974Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>MemoForward</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>正则表达式笔记</title>
    <link href="http://yoursite.com/2021/07/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/07/22/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-22T00:39:38.000Z</published>
    <updated>2021-07-22T05:56:34.974Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要对正则表达式的一些语法进行了一些记录，有机会长期补充一下：</p><blockquote><p>正则表达式基础语法</p></blockquote><a id="more"></a><h1 id="正则基础语法"><a href="#正则基础语法" class="headerlink" title="正则基础语法"></a>正则基础语法</h1><h2 id="元字符"><a href="#元字符" class="headerlink" title="元字符"></a>元字符</h2><p>　　元字符用来对字符串进行简单的匹配。</p><div class="table-container"><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>.</code></td><td style="text-align:center">匹配除换行符以外的任意字符</td></tr><tr><td style="text-align:center"><code>\w</code></td><td style="text-align:center">匹配 字母、数字、下划线或汉汉字</td></tr><tr><td style="text-align:center"><code>\s</code></td><td style="text-align:center">匹配任意空白符</td></tr><tr><td style="text-align:center"><code>\d</code></td><td style="text-align:center">匹配数字</td></tr><tr><td style="text-align:center"><code>\b</code></td><td style="text-align:center">匹配单词的开始或结束</td></tr><tr><td style="text-align:center"><code>^</code></td><td style="text-align:center">匹配字符串的开始</td></tr><tr><td style="text-align:center"><code>$</code></td><td style="text-align:center">匹配字符串的结束</td></tr></tbody></table></div><p>　　例子：</p><ol><li>匹配有abc开头的字符串</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\babc或^abc</span><br></pre></td></tr></table></figure><ol><li>匹配3位数字</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^\d\d\d$</span><br></pre></td></tr></table></figure><ol><li>配7开头的3位数字</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^<span class="number">7</span>\d\d$</span><br></pre></td></tr></table></figure><h2 id="重复限定符"><a href="#重复限定符" class="headerlink" title="重复限定符"></a>重复限定符</h2><p>　　元字符规则匹配的一般是单个或固定多个字符的情况，这很笨重，有时候多个字符匹配的规则是一样的，这时候就需要用重重复限定符去进行一个匹配。</p><div class="table-container"><table><thead><tr><th style="text-align:center">重复限定符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>*</code></td><td style="text-align:center">重复任意次数，包括0次</td></tr><tr><td style="text-align:center"><code>+</code></td><td style="text-align:center">重复1次以上</td></tr><tr><td style="text-align:center"><code>?</code></td><td style="text-align:center">重复0次或1次</td></tr><tr><td style="text-align:center"><code>{n}</code></td><td style="text-align:center">重复n次</td></tr><tr><td style="text-align:center"><code>{n,}</code></td><td style="text-align:center">重复n次即以上</td></tr><tr><td style="text-align:center"><code>{n, m}</code></td><td style="text-align:center">重复n到m次之间都匹配</td></tr></tbody></table></div><p>　　用了重复限定符之后会优雅很多。</p><ol><li>匹配11位手机号，必须以1开头</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^<span class="number">1</span>\d&#123;<span class="number">10</span>&#125;$</span><br></pre></td></tr></table></figure><ol><li>匹配a开头，x结尾，中间是12-18位数字的字符串</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^a\d&#123;<span class="number">12</span>-<span class="number">18</span>&#125;x$</span><br></pre></td></tr></table></figure><ol><li>匹配a开头，0个或多个b结尾的字符串</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^ab*$</span><br></pre></td></tr></table></figure><h1 id="分组"><a href="#分组" class="headerlink" title="分组"></a>分组</h1><p>　　使用括号来对一组字符进行匹配。</p><ol><li>匹配xy开头的任意数量的字符</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">^(xy)*$</span><br></pre></td></tr></table></figure><h1 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h1><p>　　防止正则符号和字符符号冲突。</p><ol><li>匹配任意数量(ab)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(\(ab\)*</span><br></pre></td></tr></table></figure><h1 id="条件或和区间"><a href="#条件或和区间" class="headerlink" title="条件或和区间"></a>条件或和区间</h1><p>　　用<code>|</code>表示或，[]表示区间（[0-9][a-z][A-Z][156]等，<strong>[]只能匹配一个字符</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">^((<span class="number">13</span>[<span class="number">0</span>-<span class="number">2</span>])|(<span class="number">15</span>[<span class="number">56</span>])|(<span class="number">18</span>[<span class="number">5</span>-<span class="number">6</span>])|<span class="number">145</span>|<span class="number">176</span>)\d&#123;<span class="number">8</span>&#125;$</span><br><span class="line">^(<span class="number">130</span>|<span class="number">131</span>|<span class="number">132</span>|<span class="number">155</span>|<span class="number">156</span>|<span class="number">185</span>|<span class="number">186</span>|<span class="number">145</span>|<span class="number">176</span>)\d&#123;<span class="number">8</span>&#125;$ <span class="comment">// 等价</span></span><br></pre></td></tr></table></figure><h1 id="前断言和后断言"><a href="#前断言和后断言" class="headerlink" title="前断言和后断言"></a>前断言和后断言</h1><p>　　先不写了，有点事，以后再说。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;本文主要对正则表达式的一些语法进行了一些记录，有机会长期补充一下：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;正则表达式基础语法&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="工具" scheme="http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"/>
    
    
      <category term="工具" scheme="http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>Java中的继承</title>
    <link href="http://yoursite.com/2021/07/19/Java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/"/>
    <id>http://yoursite.com/2021/07/19/Java%E4%B8%AD%E7%9A%84%E7%BB%A7%E6%89%BF/</id>
    <published>2021-07-19T10:35:19.000Z</published>
    <updated>2021-07-20T03:50:14.899Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文主要针对一些比较模糊的问题进行总结：</p><ol><li>引用是父类，实例是子类</li><li>super和this</li></ol></blockquote><a id="more"></a><h1 id="父类和子类的引用情况"><a href="#父类和子类的引用情况" class="headerlink" title="父类和子类的引用情况"></a>父类和子类的引用情况</h1><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>　　父类的引用可以指向子类的对象（向上转型），子类引用不能指向父类对象。这个很好理解，子类实例化会执行父类的构造器，此时父类的属性已经在内存中了，使用父类的引用可以访问到父类的属性信息；但是父类实例化不会执行子类的构造器，因此内存中不会有子类的属性信息，使用子类的引用无法访问到子类的成员信息。这里有个口诀对于对象的类型：<strong>编译看左边，运行看右边，静态全看左</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Father f = <span class="keyword">new</span> Son(); <span class="comment">// ok</span></span><br><span class="line">Son s = <span class="keyword">new</span> Father(); <span class="comment">// 编译不通过</span></span><br><span class="line">Son ss = (Son)<span class="keyword">new</span> Father(); <span class="comment">// 编译通过，运行时抛出ClassCastException（类型转换异常）</span></span><br></pre></td></tr></table></figure><p>　　这里比较特殊的是，父类引用指向子类的对象，该引用<strong>只能</strong>调用父类定义的成员变量和成员方法（因为编译看左边），<font color="red"><strong>而在运行中，调用同名的成员变量会调用父类的成员变量，如果调用同名的成员方法（即重写的方法），则会调用子类的方法</strong></font>。这里很奇怪，既然运行看右边，为什么我访问的不是子类对象中同名的成员变量呢？</p><p>　　这和Java的运行机制有关，<font color="brown">Java中的<strong>成员变量、静态成员方法、private以及final方法都是静态绑定的</strong>，所谓静态绑定是指在编译期绑定，这时候引用<code>f</code>已经和父类的成员变量绑定了；而<strong>普通的成员方法是动态绑定的</strong>，也就是运行时绑定，此时引用<code>f</code>在调用方法的时候是访问的是子类方法表的地址</font>。也就是说，Java的多态是指在运行时多态，只是指普通成员方法的多态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">"父亲"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String name = <span class="string">"儿子"</span>;</span><br><span class="line">    <span class="keyword">public</span> String name2 = <span class="string">"儿子小名"</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Father f = <span class="keyword">new</span> Son();</span><br><span class="line">    System.out.println(f.name); <span class="comment">// 父亲</span></span><br><span class="line">    System.out.println(f.getName()); <span class="comment">//儿子</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>　　这里补充一下：虽然引用<code>f</code>无法直接调用子类的成员变量和父类没有的成员方法，但是在运行时，这些属性仍然是开辟了空间的，但是无法访问（主要是因为编译不过）。这里给出一个验证，我们知道反射是典型的在运行时可以操作对象的方式，这里通过反射在运行时强行去找<code>f</code>的成员变量，可以看到实际上<code>f</code>在运行时是一个子类的实例对象，通过反射可以访问到父类没有的变量或者方法（代码只写了变量），但是因为静态绑定了，所以直接通过<code>f.name</code>显示的是父亲的<code>name</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Father f = <span class="keyword">new</span> Son();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field field = f.getClass().getField(<span class="string">"name"</span>);</span><br><span class="line">        Field field2 = f.getClass().getField(<span class="string">"name2"</span>);</span><br><span class="line">        System.out.println(f.name); <span class="comment">// 父亲</span></span><br><span class="line">        System.out.println(f.getName()); <span class="comment">// 儿子</span></span><br><span class="line">        String name = (String)field.get(f); <span class="comment">// 儿子</span></span><br><span class="line">        String name2 = (String)field2.get(f); <span class="comment">// 儿子小名</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Super和This"><a href="#Super和This" class="headerlink" title="Super和This"></a>Super和This</h1><p>　　大家都知道两点：</p><ol><li>子类初始化会调用父类的构造器</li><li>子类中使用super可以调用父类的变量和方法（除了<code>private</code>修饰的）</li></ol><p>　　但是这里要强调一下，<font color="red"><strong>子类实例化不会创建父类的实例</strong></font>，调用父类的构造器只是在内存中开辟了父类属性的空间，也就是说和<code>this</code>不同，<code>super</code>并不指代一个对象。如果调用<code>super.hashcode()</code>就会发现结果和<code>this.hashcode()</code>的值一样，因为根本就没有父类对象，调用父类的<code>hashcode</code>和子类的<code>hashcode</code>得到的都是子类的<code>hashcode</code>，从这可以推导得出，就算是在父类的构造器中调用<code>this.hashcode()</code>得到的也是子类的<code>hashcode</code>。</p><p>　　<strong>总结一下</strong>就是：<code>super</code>只是一个标志，不指向任何对象，它能调用父类的构造器和方法，并不是说指向了父类对象，因为根本没有父类对象被创建。</p><p>　　另外，<code>hashcode</code>方法是运行时调用的，因此上述的结论和引用是不是子类类型并无关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重写Son和Father</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Father</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"父类this.hashcode(): "</span> + <span class="keyword">this</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Son</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"子类this.hashcode(): "</span> + <span class="keyword">this</span>.hashCode());</span><br><span class="line">        System.out.println(<span class="string">"子类super.hashcode(): "</span> + <span class="keyword">super</span>.hashCode());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 验证</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Son s = <span class="keyword">new</span> Son();</span><br><span class="line">    System.out.println(<span class="string">"==========="</span>);</span><br><span class="line">    Father f = <span class="keyword">new</span> Son();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 结果</span></span><br><span class="line">父类<span class="keyword">this</span>.hashcode(): <span class="number">1554874502</span></span><br><span class="line">子类<span class="keyword">this</span>.hashcode(): <span class="number">1554874502</span></span><br><span class="line">子类<span class="keyword">super</span>.hashcode(): <span class="number">1554874502</span></span><br><span class="line">===========</span><br><span class="line">父类<span class="keyword">this</span>.hashcode(): <span class="number">1846274136</span></span><br><span class="line">子类<span class="keyword">this</span>.hashcode(): <span class="number">1846274136</span></span><br><span class="line">子类<span class="keyword">super</span>.hashcode(): <span class="number">1846274136</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　　Java继承主要就是要处理两个问题：一、什么东西是静态绑定的；二、子类实例化，会不会实例化一个父类对象？懂了这两个问题，所有问题都能推导出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文主要针对一些比较模糊的问题进行总结：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;引用是父类，实例是子类&lt;/li&gt;
&lt;li&gt;super和this&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java8特性lambda表达式笔记</title>
    <link href="http://yoursite.com/2021/07/19/Java8%E7%89%B9%E6%80%A7lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2021/07/19/Java8%E7%89%B9%E6%80%A7lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/</id>
    <published>2021-07-19T00:38:48.000Z</published>
    <updated>2021-07-23T10:22:30.034Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文涉及以下知识：</p><ol><li>Lambda表达式基本概念</li><li>Lambda表达式语法</li><li>Lambda表达式实战：java.util.function</li><li>Stream 流的概念</li><li>Stream实战</li></ol></blockquote><a id="more"></a><h1 id="Lambda基本概念"><a href="#Lambda基本概念" class="headerlink" title="Lambda基本概念"></a>Lambda基本概念</h1><p>　　Java8的一个新特性就是引入了函数式接口。通常我们的方法的入参都是基本数据类型，或者是实例对象的引用，这在一定程度上限制了方法的多样性，因此Java引入了函数式编程，即<font color="red"><strong>在声明（构造器或者方法）时把一个函数接口当成入参</strong></font>。一般这样的入参在实际使用时，会用一个实现了该接口的类对象来传入，这种对象我们一般会写成匿名的，如下所示（声明一个线程）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口Runnable作为声明时的入参，在使用时使用一个匿名类来传入</span></span><br><span class="line">Thread td = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"run"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>　　这种匿名函数写起来很笨重，<strong>因此引入了Lambda表达式来简化匿名函数的定义</strong>，如果用Lambda表达式来声明上述<code>td</code>对象，则可以写成如下形式（两种写法的作用是完全一致的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread td = <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"run"</span>));</span><br></pre></td></tr></table></figure><p>　　可以说，labmda表达式就是一种简洁的匿名类书写方式，用来增强代码的简洁性和可读性。</p><h1 id="Lambda表达式语法"><a href="#Lambda表达式语法" class="headerlink" title="Lambda表达式语法"></a>Lambda表达式语法</h1><h2 id="Lambda使用的条件"><a href="#Lambda使用的条件" class="headerlink" title="Lambda使用的条件"></a>Lambda使用的条件</h2><p>　　使用Lambda表达式来实现某个接口时，<strong>必须保证该接口只有一个抽象方法</strong>。如果该接口有两个或者两个以上的抽象方法，则无法使用Lambda。这里需要注意一点：因为Java8为接口加入了<code>default</code>和<code>static</code>方法，这两种方法不是抽象方法，是可以使用lambda的，如下例所示：</p><ul><li>可以使用Lambda的情况</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 只有一个抽象方法，可以用使用lambda</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterA</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">canUseLambda</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"log..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">perf</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"perf..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">InterA interA = () -&gt; System.out.println(<span class="string">"canUseLambda"</span>); <span class="comment">// 编译通过</span></span><br></pre></td></tr></table></figure><ul><li>不可以使用Lambda的情况</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterB</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">canUseLambda</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cantUseLambda</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>会报如下的错误：</p><p><img src="/2021/07/19/Java8%E7%89%B9%E6%80%A7lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AC%94%E8%AE%B0/mutiAbstarct.png" alt></p><h2 id="Lambda-语法"><a href="#Lambda-语法" class="headerlink" title="Lambda 语法"></a>Lambda 语法</h2><p>　　Lambda语法很简单，完整写法就是<code>(参数列表) -&gt; {具体实现代码(有返回类型可以写return)}</code>。举个例子，假设有一个<code>Rectangle</code>接口，里面有一个抽象方法，接收两个参数，返回一个<code>double</code>;同时也有一个<code>Circle</code>接口，里面有一个方法，接收一个参数，返回一个<code>double</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">double</span> y)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Circle</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> x)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>完整</strong>定义的方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Rectangle rect1 = (x, y) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Circle circle1 = (x) -&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>简化写法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当具体实现代码只有一行的时候，不需要写大括号，如果有return，则省去return</span></span><br><span class="line">Rectangle rect2 = (x, y) -&gt; x * y</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果入参只有一个，则入参的()也可以省略</span></span><br><span class="line">Circle circle2 = x -&gt; Math.sqrt(x);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果参数只有一个，而且调用的方法也只需要传入这个参数</span></span><br><span class="line"> Circle circle3 = Math::sqrt;</span><br></pre></td></tr></table></figure><ul><li>使用</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">rect1.cal(<span class="number">4.0</span>,<span class="number">5.0</span>); <span class="comment">// 20.0</span></span><br><span class="line">rect2.cal(<span class="number">4.0</span>, <span class="number">5.0</span>); <span class="comment">// 20.0</span></span><br><span class="line">circle1.cal(<span class="number">81.0</span>); <span class="comment">// 9.0</span></span><br><span class="line">circle2.cal(<span class="number">81.0</span>); <span class="comment">// 9.0</span></span><br><span class="line">circle3.cal(<span class="number">81.0</span>); <span class="comment">// 9.0</span></span><br></pre></td></tr></table></figure><h1 id="Lambda实战-java-util-function"><a href="#Lambda实战-java-util-function" class="headerlink" title="Lambda实战: java.util.function"></a>Lambda实战: java.util.function</h1><p>　　Lambda主要用在函数式编程里面，而Java8引入了一个新的包用来支持函数式编程，那就是<code>java.util.fuction</code>。</p><h2 id="java-util-function常用接口"><a href="#java-util-function常用接口" class="headerlink" title="java.util.function常用接口"></a>java.util.function常用接口</h2><p>接口文档可查看：<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="noopener">java.util.function接口文档</a></p><div class="table-container"><table><thead><tr><th style="text-align:center">接口</th><th style="text-align:center">方法</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:center"><code>Consumer&lt;T&gt;</code></td><td style="text-align:center"><code>void accept(T t)</code></td><td style="text-align:center">表示”消费者”，接收一个参数（一般用消费<code>t</code>来实现某个功能）</td></tr><tr><td style="text-align:center"><code>Supplier&lt;T&gt;</code></td><td style="text-align:center"><code>T get()</code></td><td style="text-align:center">表示”生产者”，不接收参数，返回一个值</td></tr><tr><td style="text-align:center"><code>Predicate&lt;T&gt;</code></td><td style="text-align:center"><code>bool test(T t)</code></td><td style="text-align:center">预测接口，提供一个参数，返回一个<code>bool</code>值</td></tr><tr><td style="text-align:center"><code>Function&lt;T, R&gt;</code></td><td style="text-align:center"><code>R apply(T t)</code></td><td style="text-align:center">接收一个参数<code>t</code>，返回一个值</td></tr></tbody></table></div><p>　　这里写个简单的例子，这些接口一般会经常用在<code>Stream</code>里，下一章会介绍这些方法的具体应用，这里写个简单的，方便理解。<font color="red"><strong>下列方法一个重要的理解方式就是：入参函数使用了另一个入参作为了参数，类方法又调用了入参函数。</strong></font></p><ul><li>定义一个类，使用上述接口作为参数</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoLambda</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">doSupply</span><span class="params">(Supplier&lt;T&gt; supplier)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> supplier.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">doConsumer</span><span class="params">(T t, Consumer&lt;T&gt; consumer)</span> </span>&#123;</span><br><span class="line">        consumer.accept(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">doPredicate</span><span class="params">(T t, Predicate&lt;T&gt; predicate)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> predicate.test(t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;T, R&gt; <span class="function">R <span class="title">doFunction</span><span class="params">(T t, Function&lt;T, R&gt; function)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> function.apply(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用这些方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    DoLambda d = <span class="keyword">new</span> DoLambda();</span><br><span class="line">    System.out.println(d.doSupply(() -&gt; <span class="string">"生产者提供的一个字符串"</span>));</span><br><span class="line">    d.doConsumer(<span class="string">"消费者要消费这个字符串"</span>, System.out::println);</span><br><span class="line">    d.doPredicate(<span class="string">"判断这个字符串的长度是否为10"</span>, x -&gt; x.length() == <span class="number">10</span>);</span><br><span class="line">    <span class="keyword">boolean</span> flag = d.doPredicate(<span class="string">"判断这个字符串的长度是否为10"</span>, x -&gt; x.length() == <span class="number">10</span>);</span><br><span class="line">    System.out.println(flag);</span><br><span class="line">    Double a = d.doFunction(<span class="number">53.4</span>, x -&gt; &#123;</span><br><span class="line">        System.out.print(<span class="string">"计算53.4的平方: "</span>);</span><br><span class="line">        <span class="keyword">return</span> Math.pow(x, <span class="number">2</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    System.out.println(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/******输出如下*******/</span></span><br><span class="line">生产者提供的一个字符串</span><br><span class="line">消费者要消费这个字符串</span><br><span class="line"><span class="keyword">false</span></span><br><span class="line">计算<span class="number">53.4</span>的平方: <span class="number">2851.56</span></span><br></pre></td></tr></table></figure><h1 id="Stream-API"><a href="#Stream-API" class="headerlink" title="Stream API"></a>Stream API</h1><p>　　StreamAPI也是Java8引入的新特性，可以实现<font color="red">集合</font>的<strong>串行或者并行的流操作</strong>。这是Java8最实用的功能。<strong>这里说一个重要的，流只是操作，不改变原集合。</strong></p><ul><li><div id="person">创建流</div></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Stream&lt;T&gt; stream1 = 集合&lt;T&gt;对象.stream() <span class="comment">// 串行流</span></span><br><span class="line">Stream&lt;T&gt; stream2 = 集合&lt;T&gt;对象.parallelStream() <span class="comment">// 并行流</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test04</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;Person&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"yi"</span>, <span class="number">45</span>)); <span class="comment">// name, age</span></span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"two"</span>, <span class="number">11</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"three"</span>, <span class="number">56</span>));</span><br><span class="line">        list.add(<span class="keyword">new</span> Person(<span class="string">"four"</span>, <span class="number">27</span>));</span><br><span class="line">        Stream&lt;Person&gt; stream = list.stream();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>部分流操作</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">流操作</th><th style="text-align:center">功能</th></tr></thead><tbody><tr><td style="text-align:center"><code>void forEach(Consumer&lt;? super T&gt; action)</code></td><td style="text-align:center">迭代这个集合中的每一个数据</td></tr><tr><td style="text-align:center"><code>Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper)</code></td><td style="text-align:center">把集合中的每一个T类型数据映射成R类型数据，<strong>返回一个R类型的流</strong></td></tr><tr><td style="text-align:center"><code>Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></td><td style="text-align:center">对集合中每一个数据进行筛选，筛出符合条件的数据(true)，并返回一个流</td></tr><tr><td style="text-align:center"><code>Stream&lt;T&gt; limit(long maxSize)</code></td><td style="text-align:center">获取指定数量的流，数量为maxSize（串行有序，并行无序）</td></tr><tr><td style="text-align:center"><code>Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator)</code></td><td style="text-align:center">累加器，两两相加，最后返回一个Optional容器（Optional是为了防止空指针，用<code>容器对象.get()</code>得到T，关于BinaryOperator去看<a href="https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html" target="_blank" rel="noopener">文档</a>）</td></tr><tr><td style="text-align:center"><code>T reduce(T identity, BinaryOperator&lt;T&gt; accumulator)</code></td><td style="text-align:center">有初始值的累加，因为有初始值，所以不会出现空指针，直接返回T</td></tr><tr><td style="text-align:center"><code>Stream&lt;T&gt; sorted(Comparator&lt;? super T&gt; comparator)</code></td><td style="text-align:center">对集合类进行排序，传入一个比较器，返回一个流对象</td></tr><tr><td style="text-align:center"><code>Object[] toArray() 和 collect(Collectors.toList())</code></td><td style="text-align:center">对流进行数组或集合类型的转化</td></tr></tbody></table></div><h1 id="Stream实战"><a href="#Stream实战" class="headerlink" title="Stream实战"></a>Stream实战</h1><p><a href="#person">以上</a>写了一个<code>Person</code>的列表，要求用流分别实现如下功能：</p><ol><li><p>将人的按照年龄大小排序并打印</p></li><li><p>筛选出年龄小于50的并打印</p></li><li><p>打印出总年龄</p></li><li><p>打印前3个人</p></li><li><p>把每个人的年龄加100，并打印</p></li><li><p>将所有的人映射到一个Map集合里面，key是名字，value是年龄</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="string">"====问题1===="</span>);</span><br><span class="line">list.stream().sorted((o1, o2) -&gt; o1.getAge() - o2.getAge()).forEach(Person::print);</span><br><span class="line">System.out.println(<span class="string">"====问题2===="</span>);</span><br><span class="line">list.stream().filter(p -&gt; p.getAge() &lt; <span class="number">50</span>).forEach(Person::print);</span><br><span class="line">System.out.println(<span class="string">"====问题3===="</span>);</span><br><span class="line">System.out.println(list.stream().mapToInt(Person::getAge).reduce(Integer::sum).orElse(-<span class="number">1</span>));</span><br><span class="line">System.out.println(<span class="string">"====问题4===="</span>);</span><br><span class="line">list.stream().limit(<span class="number">3</span>).forEach(Person::print);</span><br><span class="line">System.out.println(<span class="string">"====问题5===="</span>);</span><br><span class="line">list.forEach(p -&gt; p.setAge(p.getAge() + <span class="number">100</span>));</span><br><span class="line">list.forEach(Person::print);</span><br><span class="line">System.out.println(<span class="string">"====问题6===="</span>);</span><br><span class="line">Map&lt;String, Integer&gt; map = list.stream().collect(Collectors.toMap(Person::getName, Person::getAge));</span><br><span class="line"><span class="keyword">for</span>(String key: map.keySet()) &#123;</span><br><span class="line">    System.out.println(<span class="string">"姓名："</span> + key + <span class="string">"  年龄："</span> + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果</span></span><br><span class="line">====问题<span class="number">1</span>====</span><br><span class="line">姓名：two  年龄：<span class="number">11</span></span><br><span class="line">姓名：four  年龄：<span class="number">27</span></span><br><span class="line">姓名：yi  年龄：<span class="number">45</span></span><br><span class="line">姓名：three  年龄：<span class="number">56</span></span><br><span class="line">====问题<span class="number">2</span>====</span><br><span class="line">姓名：yi  年龄：<span class="number">45</span></span><br><span class="line">姓名：two  年龄：<span class="number">11</span></span><br><span class="line">姓名：four  年龄：<span class="number">27</span></span><br><span class="line">====问题<span class="number">3</span>====</span><br><span class="line"><span class="number">139</span></span><br><span class="line">====问题<span class="number">4</span>====</span><br><span class="line">姓名：yi  年龄：<span class="number">45</span></span><br><span class="line">姓名：two  年龄：<span class="number">11</span></span><br><span class="line">姓名：three  年龄：<span class="number">56</span></span><br><span class="line">====问题<span class="number">5</span>====</span><br><span class="line">姓名：yi  年龄：<span class="number">145</span></span><br><span class="line">姓名：two  年龄：<span class="number">111</span></span><br><span class="line">姓名：three  年龄：<span class="number">156</span></span><br><span class="line">姓名：four  年龄：<span class="number">127</span></span><br><span class="line">====问题<span class="number">6</span>====（顺序是随机的）</span><br><span class="line">姓名：yi  年龄：<span class="number">145</span></span><br><span class="line">姓名：four  年龄：<span class="number">127</span></span><br><span class="line">姓名：three  年龄：<span class="number">156</span></span><br><span class="line">姓名：two  年龄：<span class="number">111</span></span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>　　本章内容主要介绍了一下Lambda表达式，同时稍微介绍了一点StreamAPI的知识，这部分知识不难，主要难在架构设计，希望以后我忘记这部分内容的时候能够通过这篇文章回想起来。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文涉及以下知识：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Lambda表达式基本概念&lt;/li&gt;
&lt;li&gt;Lambda表达式语法&lt;/li&gt;
&lt;li&gt;Lambda表达式实战：java.util.function&lt;/li&gt;
&lt;li&gt;Stream 流的概念&lt;/li&gt;
&lt;li&gt;Stream实战&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>限流工具RateLimiter和Semaphore解析</title>
    <link href="http://yoursite.com/2020/10/30/%E9%99%90%E6%B5%81%E5%B7%A5%E5%85%B7RateLimiter%E5%92%8CSemaphore/"/>
    <id>http://yoursite.com/2020/10/30/%E9%99%90%E6%B5%81%E5%B7%A5%E5%85%B7RateLimiter%E5%92%8CSemaphore/</id>
    <published>2020-10-30T03:19:09.000Z</published>
    <updated>2020-11-02T08:34:31.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文主要介绍限流工具RateLimiter和Semaphore</p><ol><li>RateLimiter介绍</li><li>Semaphore</li><li>使用场景分析</li></ol></blockquote><a id="more"></a><h1 id="RateLimiter"><a href="#RateLimiter" class="headerlink" title="RateLimiter"></a>RateLimiter</h1><h2 id="RateLimiter原理简介"><a href="#RateLimiter原理简介" class="headerlink" title="RateLimiter原理简介"></a>RateLimiter原理简介</h2><p>　　RateLimiter是谷歌出品的一个限流工具，使用令牌桶策略进行限流。所谓令牌桶策略，直观上来看就是：规定桶里最多能放N个令牌，如果桶没满，则按照一定的速率（可以是匀速，也可以是变速）往桶里追加令牌，如果有线程打到了这个实例上，则会拿走一个或多个令牌，如果没有令牌可以拿，就会阻塞几秒，直到可以拿到令牌为止。</p><p>　　这种原理很好理解，有点类似小时候”浴缸一边加水一边放水“的感觉，但同时这个如果按照这个理解去实现这个RateLimiter的话，会出现很多的问题，比如”我们如何实现每秒钟往桶里放令牌呢？“，上面的思路实现就会是：这个类会始终启动一个线程无时无刻去放令牌。这种做法显然会造成极大的资源浪费。在下一小节，我将针对RateLimiter的部分源码来解释一下谷歌对于限流的实现。</p><h2 id="RateLimiter源码解析"><a href="#RateLimiter源码解析" class="headerlink" title="RateLimiter源码解析"></a>RateLimiter源码解析</h2><p>　　 先说结论：RateLimiter本身不会自启一个线程去往桶里放令牌，<strong>放令牌的数量是基于时间的</strong>，RateLimiter中会<font color="brown"><strong>记录下一个请求从何时（记为x）开始才能获取到令牌</strong></font>，根据当前请求的时间（y）和x作比较，如果x &lt; y，则一定可以获得令牌（可预支），然后根据其申请的令牌数计算下次可以获取到令牌的具体时间；如果x &gt; y，则说明目前是桶中是没有令牌的，则会计算出线程获得令牌需要等待的时间（t），同时也会进一步更新，线程将沉睡t时间后再去执行方法。</p><p><strong>这里有两点需要注意：</strong></p><ol><li><strong>线程获取令牌这个操作是串行的，不会出现两个线程同时争夺同一块令牌的情况;</strong></li><li><strong>同时，如果桶中只有10个令牌，我的请求需要20个令牌，我是可以立刻获取到这些令牌并执行方法的，但是下一个请求将会等待这多出来的生产10个令牌的时间。</strong>这里给出谷歌官方文档的原文: It is important to note that the number of permits requested <em>never</em> affects the throttling of the request itself (an invocation to <code>acquire(1)</code> and an invocation to <code>acquire(1000)</code> will result in exactly the same throttling, if any), but it affects the throttling of the <em>next</em> request. I.e., if an expensive task arrives at an idle RateLimiter, it will be granted immediately, but it is the <em>next</em> request that will experience extra throttling, thus paying for the cost of the expensive task.</li></ol><p>　　下面我先介绍一下<code>RateLimiter</code>类的一些基本概念。<code>RateLimiter</code>是一个抽象的基类，自身是不含有成员变量的，仅包含了一些通用的方法，具体参数的定义都放在了它的子类<code>SmoothRateLimiter</code>中，这个类又派生出了两个”限流桶“的实现内部类，分别是：<code>SmoothBursty</code>类和<code>SmoothWarmingUp</code>类。前者是恒定速率生产令牌的”限流桶“，后者是变速生产令牌的桶（类似于TCP的慢开始策略）。本文因为篇幅限制，仅介绍实现稍微简单一些的<code>SmoothBursty</code>类。</p><ul><li>上面讲到，”限流桶“其中一个实现类是SmoothBursty，下表列出了这个类的<strong>核心参数</strong>和含义。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">参数含义</th></tr></thead><tbody><tr><td style="text-align:center"><font color="orange">double </font><font color="purple">storedPermits</font></td><td style="text-align:center">当前存储的令牌数量</td></tr><tr><td style="text-align:center"><font color="orange">double </font> <font color="purple">maxPermits</font></td><td style="text-align:center">允许存储的最大令牌数量 =<font color="purple"> maxBurstSeconds * permitsPerSecond</font></td></tr><tr><td style="text-align:center"><font color="orange">double </font> <font color="purple">stableIntervalMicros</font></td><td style="text-align:center">稳定生产一个令牌所用的时间（微秒）</td></tr><tr><td style="text-align:center"><font color="orange">private long </font> <font color="purple">nextFreeTicketMicros</font></td><td style="text-align:center">下次可以获取到令牌的具体时间，如果当前时间小于这个时间，则不能获取</td></tr><tr><td style="text-align:center"><font color="orange">final double </font> <font color="purple">maxBurstSeconds</font></td><td style="text-align:center">桶中可以放几秒的限值（默认是一秒，可以用来应对突发的大流量）</td></tr></tbody></table></div><p>　　接下来，我将介绍一下RateLimiter类的几个核心方法：</p><ul><li><font color="green">RateLimiter.create(double permitsPerSecond)</font>这个方法会生成一个匀速产生令牌的”限流桶”：<font color="blue">SmoothBursty</font>。这个函数没什么好讲的，主要就是将以上的参数都给赋值，尤其是把 <font color="purple">storedPermits</font>给填满。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// created方法是RateLimiter类的方法，核心是setRate，限流器核心参数的赋值都是基于我们设置的permitsPerSecond</span></span><br><span class="line">  <span class="meta">@VisibleForTesting</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> RateLimiter <span class="title">create</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, SleepingStopwatch stopwatch)</span> </span>&#123;</span><br><span class="line">    RateLimiter rateLimiter = <span class="keyword">new</span> SmoothBursty(stopwatch, <span class="number">1.0</span> <span class="comment">/* maxBurstSeconds */</span>);</span><br><span class="line">    rateLimiter.setRate(permitsPerSecond);</span><br><span class="line">    <span class="keyword">return</span> rateLimiter;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// setRate方法在下层有两个操作，其中一个是用来给stableIntervalMicros赋值，另一个用来调整maxPermits和stroedPermits</span></span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 核心方法，根据时间来更新令牌数</span></span><br><span class="line">    resync(nowMicros);</span><br><span class="line">    <span class="comment">// 这个很好理解</span></span><br><span class="line">    <span class="keyword">double</span> stableIntervalMicros = SECONDS.toMicros(<span class="number">1L</span>) / permitsPerSecond;</span><br><span class="line">    <span class="keyword">this</span>.stableIntervalMicros = stableIntervalMicros;</span><br><span class="line">    doSetRate(permitsPerSecond, stableIntervalMicros);</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">doSetRate</span><span class="params">(<span class="keyword">double</span> permitsPerSecond, <span class="keyword">double</span> stableIntervalMicros)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> oldMaxPermits = <span class="keyword">this</span>.maxPermits;</span><br><span class="line">    maxPermits = maxBurstSeconds * permitsPerSecond;</span><br><span class="line">    <span class="keyword">if</span> (oldMaxPermits == Double.POSITIVE_INFINITY) &#123;</span><br><span class="line">      <span class="comment">// if we don't special-case this, we would get storedPermits == NaN, below</span></span><br><span class="line">      storedPermits = maxPermits;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 防止更新了桶的大小后，令牌数超标的情况</span></span><br><span class="line">      storedPermits =</span><br><span class="line">          (oldMaxPermits == <span class="number">0.0</span>)</span><br><span class="line">              ? <span class="number">0.0</span> <span class="comment">// initial state</span></span><br><span class="line">              : storedPermits * maxPermits / oldMaxPermits;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><ul><li>以上代码中有一个核心的方法：<font color="red">resync(nowMicros)</font>。这个方法将根据目前线程的请求时间和上一次请求所间隔的时间，来计算出这段时间中桶中生产了多少个令牌，并更新这个桶中的令牌数量，这个方法是RateLimiter实现添加加令牌操作的基础方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resync</span><span class="params">(<span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// if nextFreeTicket is in the past, resync to now</span></span><br><span class="line">  <span class="keyword">if</span> (nowMicros &gt; nextFreeTicketMicros) &#123;</span><br><span class="line">    <span class="comment">// 计算出这段时间内，一共可以生产多少令牌</span></span><br><span class="line">    <span class="comment">// coolDownIntervalMicros()对于SmoothBurst而言一直是stableIntervalMicros</span></span><br><span class="line">    <span class="keyword">double</span> newPermits = (nowMicros - nextFreeTicketMicros) / coolDownIntervalMicros();</span><br><span class="line">    <span class="comment">// 添加令牌, 如果桶空闲了，令牌数是可以填满的</span></span><br><span class="line">    storedPermits = min(maxPermits, storedPermits + newPermits);</span><br><span class="line">    <span class="comment">// 目前下一次获取令牌的时间是当前请求的时间，因为进到这个方法里表示请求一定可以拿到令牌（下面的方法会讲，RateLimiter可以预约令牌）</span></span><br><span class="line">    nextFreeTicketMicros = nowMicros;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><font color="green">RateLimiter.acquire(int permits)</font>：这个方法是从桶中拿走permits个令牌，入参可不写，默认拿走一个令牌，返回可以获得令牌等待了多长时间。如果不能够取得足够数量的令牌，则线程会阻塞一段时间，然后再尝试获取。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 核心方法，意思为”预定“，每个线程都会去申请这个令牌的获取，返回需要等待的时间</span></span><br><span class="line">  <span class="keyword">long</span> microsToWait = reserve(permits);</span><br><span class="line">  <span class="comment">// 线程根据等待的时间进行阻塞</span></span><br><span class="line">  stopwatch.sleepMicrosUninterruptibly(microsToWait);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">1.0</span> * microsToWait / SECONDS.toMicros(<span class="number">1L</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// reserve操作加了锁，保证线程不会争夺同一块令牌</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserve</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">  checkPermits(permits);</span><br><span class="line">  <span class="keyword">synchronized</span> (mutex()) &#123;</span><br><span class="line">    <span class="keyword">return</span> reserveAndGetWaitLength(permits, stopwatch.readMicros());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没什么好讲的，这个就是在计算需要等的时间</span></span><br><span class="line"><span class="comment">// reserveEarliestAvailable计算了当前请求能够拿到令牌的系统时间，如果是future就会阻塞，不是future就是0，表示立刻就能拿到</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveAndGetWaitLength</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> momentAvailable = reserveEarliestAvailable(permits, nowMicros);</span><br><span class="line">  <span class="keyword">return</span> max(momentAvailable - nowMicros, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 具体限流桶的方法，两种限流桶不太一样（主要是因为生成的速率不一样，思路是一样的）</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">reserveEarliestAvailable</span><span class="params">(<span class="keyword">int</span> requiredPermits, <span class="keyword">long</span> nowMicros)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据时间间隔计算桶中当前应该有多少令牌，更新一下stroedPermits，并把nextFreeTicketMicros和当前时间同步</span></span><br><span class="line">  resync(nowMicros);</span><br><span class="line">  <span class="comment">// 进到这个方法，不管桶中令牌够不够都不会阻塞，如果不够，多余的开销由下一次请求承担，所以直接直接返回当前的时间，表示线程不会阻塞</span></span><br><span class="line">  <span class="keyword">long</span> returnValue = nextFreeTicketMicros;</span><br><span class="line">  <span class="comment">// 计算需要至多能从桶中拿多少的令牌</span></span><br><span class="line">  <span class="keyword">double</span> storedPermitsToSpend = min(requiredPermits, <span class="keyword">this</span>.storedPermits);</span><br><span class="line">  <span class="comment">// 计算预支的令牌数</span></span><br><span class="line">  <span class="keyword">double</span> freshPermits = requiredPermits - storedPermitsToSpend;</span><br><span class="line">  <span class="comment">// 计算额外的开销</span></span><br><span class="line">  <span class="keyword">long</span> waitMicros =</span><br><span class="line">      storedPermitsToWaitTime(<span class="keyword">this</span>.storedPermits, storedPermitsToSpend)</span><br><span class="line">          + (<span class="keyword">long</span>) (freshPermits * stableIntervalMicros);</span><br><span class="line">  <span class="comment">// 额外的开销将会更新到”下次可以获取到令牌的具体时间“，如果额外开销很大</span></span><br><span class="line">  <span class="comment">// 这个时间就会是很遥远的future，下次请求阻塞的时间就越长</span></span><br><span class="line">  <span class="keyword">this</span>.nextFreeTicketMicros = LongMath.saturatedAdd(nextFreeTicketMicros, waitMicros);</span><br><span class="line">      <span class="comment">// 如果”预支“了，storedPermits就会清零</span></span><br><span class="line">  <span class="keyword">this</span>.storedPermits -= storedPermitsToSpend;</span><br><span class="line">  <span class="keyword">return</span> returnValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RateLimiter总结"><a href="#RateLimiter总结" class="headerlink" title="RateLimiter总结"></a>RateLimiter总结</h2><p>　　RateLimiter是用来进行QPS限流的，请求获取令牌但不释放令牌，同时线程在获取令牌时是串行的，保证了限流数量的一致性。当有操作量大的线程一下子获取了多余的令牌后，RateLimter会使用预支的方式保证这个请求能够顺利响应，同时也不会影响到限流的可靠性，因为多余的开销会由下一次请求承担。同时RateLimiter桶在空闲时会将令牌先塞满桶，这样当在QPS突然非常高的时候（从空闲状态突然变高），RateLimiter可以短时间处理高于限值的请求数，等桶中令牌消耗完了，QPS就会趋于限值并稳定下来。但是RateLimiter获取令牌的操作是用sychronize实现的，因此其无法保证公平性。</p><h1 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h1><h2 id="Semaphore简介"><a href="#Semaphore简介" class="headerlink" title="Semaphore简介"></a>Semaphore简介</h2><p>　　Semaphore是J.U.C提供的共享锁，名为”信号量”。这个策略比较直观，控制最大并发数，维护一个”信号量“记录当前可用并发量（同样用令牌数来表示信号量的数值），请求要执行操作需要获取<strong>一个</strong>令牌，方法执行结束后需要释放这个令牌。但信号量为0时（令牌数为0），则线程会进一个等待链表（<strong>head是个虚拟头结点，以下说的链表头都指head.next</strong>），进链表后这个线程机会阻塞，直到某个线程释放了令牌，这个释放了令牌的线程会唤醒处在链表头的线程，然后这个线程再去尝试获取令牌。　</p><h2 id="Semaphore源码解析"><a href="#Semaphore源码解析" class="headerlink" title="Semaphore源码解析"></a>Semaphore源码解析</h2><p>　　Semaphore主要是通过一个抽象的内部类Sync的两个子类：NonfairSync和FairSync（公平锁和非公平锁）来实现相关功能。这两个类的实现功能是一样的，就是线程获取令牌的公平性问题：进入等待的线程会形成一个链表，每个线程在忙循环中都会尝试去获取令牌，FairSync保证了只有链表头的线程才能够获取到最新的空闲令牌。</p><ul><li>Sync类继承了AbstractQueuedSynchronizer（AQS）类，这个类中有实现功能的核心参数</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">参数含义</th></tr></thead><tbody><tr><td style="text-align:center"><font color="orange">private volatile int</font> <font color="purple">state</font></td><td style="text-align:center">可用的令牌数量（设置的最大并发数），所有的操作都会基于这个值</td></tr><tr><td style="text-align:center"><font color="orange">static final</font> <font color="brown">class Node</font></td><td style="text-align:center">等待线程的链表</td></tr></tbody></table></div><div class="table-container"><table><thead><tr><th style="text-align:center">Node类核心参数</th><th style="text-align:center">参数含义</th></tr></thead><tbody><tr><td style="text-align:center"><font color="orange">volatile</font> <font color="brown">Thread thread</font></td><td style="text-align:center">每一个node与当前线程绑定</td></tr><tr><td style="text-align:center"><font color="orange">volatile int</font> <font color="purple">waitStatus</font></td><td style="text-align:center">记录这个Node的状态，比如cancelled</td></tr></tbody></table></div><p> Semaphore最核心的两个操作是acquire()和release()，下面将针对NonFairSync和FairSync详细介绍一下这两个方法。</p><ul><li>acquire()：这个方法会尝试获取一个令牌，对中断敏感，如果线程中断了，则会抛出异常（还有一个acquireUninterruptibly方法，对中断不敏感，这里不介绍了）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// 去获取一个令牌</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取令牌的具体实现</span></span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">// tryAcquireShared 尝试获取令牌，返回获取后剩余的令牌数量，&lt;0则表示无法获取令牌</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// NonfairSync版本tryAcquireShared</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这个循环是为了配合CAS</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 可用的令牌数</span></span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="comment">// 剩余令牌数</span></span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="comment">// 根据java特性，如果剩余令牌数 &lt; 0，就不会执行后面的CAS操作</span></span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">                <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// FaieSync版本tryAcquireShared</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">// 主要就是加了个这个判断，如果等待链表为空，或者当前线程在等待链表的开头（head.next），则可以获取</span></span><br><span class="line">            <span class="comment">// 这避免了新来的线程”插队“</span></span><br><span class="line">            <span class="comment">// 因为在多线程的情况下，即使有了等待队列，available也可能会大于0</span></span><br><span class="line">            <span class="comment">// 此时新来的线程在非公平的情况下，可能会绕过链表直接获取到令牌</span></span><br><span class="line">            <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> available = getState();</span><br><span class="line">            <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">            <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                compareAndSetState(available, remaining))</span><br><span class="line">               <span class="keyword">return</span> remaining;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 如果tryAcquire的值小于0了，则会执行doAcquireSharedInterruptibly方法来将执行忙循环</span></span><br><span class="line"><span class="comment">// 不停地去请求获取令牌,这个方法对于公不公平没有区分</span></span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">// 当前请求第一次进来会在等待链表后面添加一个node</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="comment">// 默认这个请求最终能获取令牌</span></span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 线程被唤醒后再次去尝试获取令牌，获取不到就继续被阻塞</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 查询这个node的prev</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 如果这个prev是head再去尝试获取令牌（</span></span><br><span class="line">                <span class="comment">// 等待列表是有序的，只有链表的头（head.next）才有资格去尝试获取令牌，也只有链表头会被唤醒）</span></span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="comment">// 公平锁可以保证这个线程一定可以获取到令牌，非公平锁不能保证</span></span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 重新设置链表头</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                 </span><br><span class="line">                <span class="comment">// shouldParkAfterFailedAcquire: 重组链表，清除无效节点</span></span><br><span class="line">                <span class="comment">// parkAndCheckInterrupt: 将当前线程挂起，同时检测中断</span></span><br><span class="line">                <span class="comment">// 如果中断则捕获异常（这里多嘴一句，内部用了LockSupport.park()来阻塞线程</span></span><br><span class="line">                <span class="comment">// 这个方法自己不能捕获中断，所以我们不能try..catch）</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                <span class="comment">// 放弃获取令牌，将node的状态置为cancelled</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// setHeadAndPropagate比想象中复杂</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        <span class="comment">// 重新设置链表头</span></span><br><span class="line">        setHead(node);</span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="comment">// 如果下一个节点为空，或者节点是共享模式（只有虚拟head是独占的，其他node都是共享模式），则尝试唤醒线程</span></span><br><span class="line">            <span class="comment">// s == null 的时候一定不会唤醒后继节点，感觉有点多余</span></span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                <span class="comment">// 尝试唤醒线程，在release方法里详细写</span></span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>这里注意一下，tryAcquireShared在AQS也有带有超时阻塞的重载方法tryAcquireSharedNanos(int arg, long nanosTimeout)，当线程请求超时，直接退出自旋，但是其在Semaphore中没有使用。</strong></p><ul><li>release()：释放令牌，这个操作没有特别大的学问。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 去释放一个令牌</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 释放的具体实现</span></span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试去释放令牌，tryReleaseShared已经增加了令牌数</span></span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// 释放成功，唤醒链表头的线程</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这个函数比较难懂，最主要的原因就是在共享模式下</span></span><br><span class="line"><span class="comment">// 线程获取令牌和释放令牌都会尝试去唤醒下一个线程，所以这个函数加了一些if判断防止线程被重复唤醒，却没有唤醒应该唤醒的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// SIGNAL表示下一个线程需要被唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 这个函数在唤醒线程</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp; <span class="comment">// 0表示dump状态，链表刚刚初始化</span></span><br><span class="line">                     <span class="comment">// PROPAGATE表示线程已经被唤醒，如果交换成功，则跳出if</span></span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE)) </span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果同时有线程获取和释放了锁，这里的head可能改变，需要重新唤醒后继线程</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore总结"><a href="#Semaphore总结" class="headerlink" title="Semaphore总结"></a>Semaphore总结</h2><p>　　Semaphore本质上一个基于AQS的共享锁，说到底还是一个锁的模式，如果锁没有释放，其他线程就得一直阻塞或者超时返回。一个非常直观的应用场景可以是数据库的连接，可以控制最大的并发数在1000，只要连接不断开，其他线程就无法访问数据库。</p><h1 id="Semaphore和RateLimiter的区别"><a href="#Semaphore和RateLimiter的区别" class="headerlink" title="Semaphore和RateLimiter的区别"></a>Semaphore和RateLimiter的区别</h1><h2 id="原理上的区别"><a href="#原理上的区别" class="headerlink" title="原理上的区别"></a>原理上的区别</h2><p>　　Semaphore限制了服务的最大并发量，并提供了等待队列来阻塞线程，当有令牌可用时会唤醒队列中的线程，队列中线程通过自旋的策略来保证自动获取令牌；而RateLimiter则是限制了QPS，本质上是对速率的一种控制。RateLimiter可能对服务器的CPU造成更大的压力，但也保证了很高的处理效率，因为其只控制在1秒内最多能有多少请求访问资源，但是不会管这个请求会占用资源多久：如果某个请求会占用这个服务2秒，我们限制了QPS为100，则这个服务最大并发量可能会有200。</p><h2 id="使用场景上的区别"><a href="#使用场景上的区别" class="headerlink" title="使用场景上的区别"></a>使用场景上的区别</h2><p>大多数场景下，限制QPS和限制并发量的场景都是互通的，限制的并发量。</p><ul><li>如果请求的平均响应时间是不确定的，那么建议控制并发量来保证服务器不会受到太大的压力；</li><li>其他情况建议使用限制QPS的限流器：<ul><li>从两种种工具的实现上来看，Semaphore通过阻塞唤醒机制来控制线程，默认情况下线程被唤醒后不一定能够获取到令牌，从而又会重新进入阻塞状态，同时每次自旋都会重新处理等待链表也比较消耗资源，而RateLimiter会计算线程阻塞的时间，到时间自动唤醒，没有自旋，也没有额外开销，比Semaphore开销小。</li><li>从应对突发请求来看，Semaphore没有机制来应对，突发的大流量可能直接使等待链表变得超级大，<strong>而RateLimiter可以通过”令牌空闲累积“以及“预支”的策略来保证1秒的内的实际请求量可能临时大于限值，等桶中令牌消耗完了就会趋于稳定，稳定在我们限制的QPS中</strong>，这样在一定程度上保证了服务的可用性<strong>。</strong></li></ul></li></ul><h1 id="关于并发数和QPS的思考"><a href="#关于并发数和QPS的思考" class="headerlink" title="关于并发数和QPS的思考"></a>关于并发数和QPS的思考</h1><p>　　  这里先明确一个概念，在实际的业务场景中，QPS是稳定的，影响服务器性能的主要是并发数，试想一下如果我们服务的响应时间特别短，在某一个时刻我们预期的并发数会很低，不会对服务器造成很大的压力，符合逻辑；如果时延很高，这就表示我们的服务链出了问题，这样系统在某个时刻的并发数就会很高，因为时延高会导致某些线程迟迟不释放系统资源。这也是符合逻辑的。</p><p> 　　根据以上逻辑，这套QPS和并发量的转换公式就是：$QPS = 1000 / t <em> C$。$t$表示服务的平均响应时延，$C$表示该服务在这个QPS下的最大并发量。在使用Semaphore中，我们将会进行单机的并发数限流，通过上面的公式，我们可以对并发数的控制有一个相应的预期，<em>*在控制并发数的前提下，服务的稳定性会影响QPS（默认在限流生效的情况下），</em></em>如果服务时延降低，QPS预期会提高，如果服务时延提高，对应的QPS就会下降；我建议对被限流的请求进行打点统计，因为在限制并发数的前提下，QPS的降低不一定是用户侧的问题，也可能是服务稳定性的问题，比如网络的波动也会导致QPS降低。</p><p>　　举个简单的例子：某个服务的QPS有15W，平均请求时延为40ms，部署了600个实例。</p><p>　　这就是说，我们平时对这个服务的QPS期望不超过15W，单机平均QPS为：$Q = 150000 / 600 = 250$; 此时如果用Semaphore限流，设置的最大并发数为: $C = 250 * 40 / 1000 = 10$。也就是说，如果服务的时延稳定在40ms，理论上最大设置10个并发就能满足15WQPS的需要。</p><p>　　日常使用的时候，用RateLimiter可能更加直观，但是RateLimiter有一个问题：在满额QPS在跑的时候，如果服务可用性下降，请求时延陡增，系统的并发数也会陡增，导致严重的后果。因此，如果使用RateLimiter，建议对服务的请求时延做一个监控，当时延超过一定的阈值的时候，对服务降级处理，防止对服务器产生过大的压力。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://guava.dev/releases/snapshot-jre/api/docs/" target="_blank" rel="noopener">Google Guava API DOCS</a></li><li><a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">Java8 API DOCS</a></li><li><a href="https://www.django-rest-framework.org/api-guide/throttling/" target="_blank" rel="noopener">DRF框架 Throttling API DOCS</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文主要介绍限流工具RateLimiter和Semaphore&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;RateLimiter介绍&lt;/li&gt;
&lt;li&gt;Semaphore&lt;/li&gt;
&lt;li&gt;使用场景分析&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="限流" scheme="http://yoursite.com/tags/%E9%99%90%E6%B5%81/"/>
    
  </entry>
  
  <entry>
    <title>HTTP详解</title>
    <link href="http://yoursite.com/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/</id>
    <published>2020-09-18T03:19:09.000Z</published>
    <updated>2020-09-22T12:33:02.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文主要梳理HTTP协议的知识体系</p><ol><li>HTTP基础</li><li>DNS</li><li>HTTP缓存策略</li><li>HTTPS</li><li>常见问题</li></ol></blockquote><a id="more"></a><h1 id="HTTP各版本之间的差异"><a href="#HTTP各版本之间的差异" class="headerlink" title="HTTP各版本之间的差异"></a>HTTP各版本之间的差异</h1><p>超文本传输协议。<strong>「HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范」</strong>。</p><h2 id="HTTP-0-9"><a href="#HTTP-0-9" class="headerlink" title="HTTP 0.9"></a>HTTP 0.9</h2><ul><li>只有一个GET请求，只支持纯文本，早已过时</li></ul><h2 id="HTTP-1-0"><a href="#HTTP-1-0" class="headerlink" title="HTTP 1.0"></a>HTTP 1.0</h2><ul><li>可以传送任何格式的文件，如图像、视频、文本等。</li><li>除了GET命令，还有POST和HEAD等。</li><li>HTTP的请求和回应的格式改变，除了数据部分，每次通信还必须包含头信息（HTTP header），用来描述一些元数据。</li><li>只使用header中<code>If-Modified-Since</code> 和<code>Expires</code>作为缓存失效的标准。</li><li>不支持断点续传，每次都会传送全部的页面和数据。</li><li>通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）</li><li><code>keep-alive</code>（默认关闭）</li></ul><h2 id="HTTP-1-1"><a href="#HTTP-1-1" class="headerlink" title="HTTP 1.1"></a>HTTP 1.1</h2><p>HTTP是当前最主流的http协议版本。</p><ul><li>支持持久连接（presistent connection），即TCP连接默认不关闭，可以被多个请求复用。长连接的连接时长由请求头中的<code>keep-alive</code>（默认开启）来设置。</li><li>引入了管道机制（pipeline），即在同一个TCP连接里，客户端可以同时发送多条请求，提高了HTTP协议的效率。</li><li>HTTP 1.1 中新增加了 <code>E-tag，If-Unmodified-Since, If-Match, If-None-Match</code>等缓存控制标头来控制缓存失效。</li><li>支持断点续传，通过使用请求头中的<code>Range</code>来实现。</li><li>使用了虚拟网络，在一台物理服务器上可以存在多个物理主机（Multi-homed Web Servers），并且它们共享一个ip地址。</li><li>新增方法：PUT、 PATCH、 OPTIONS、 DELETE。</li></ul><h2 id="HTTP-1-x-的版本问题"><a href="#HTTP-1-x-的版本问题" class="headerlink" title="HTTP 1.x 的版本问题"></a>HTTP 1.x 的版本问题</h2><ul><li>传输的数据都是明文，没有加密，客户端和服务端都无法验证对方的身份，很不安全。</li><li>HTTP/1.1默认允许复用TCP连接，但是在同一个TCP连接里，所有的数据都是有序传输的，服务器只有处理完一个回应后才会去处理下一个，因此如果前面有数据阻塞，后面的都无法传输，这就是<strong>队头阻塞</strong>。</li><li>HTTP/1.x 支持长连接，为了避免创建多次连接产生的延迟，但是这同样会给服务器带来压力。对于单文件的请求，在请求结束后还会保持不必要的连接。</li></ul><h3 id="聊一聊队头阻塞"><a href="#聊一聊队头阻塞" class="headerlink" title="聊一聊队头阻塞"></a>聊一聊队头阻塞</h3><p>　　对于每一个HTTP/1.x请求而言，这些任务是会被放入一个任务队列中串行执行的，一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是<code>HTTP队头阻塞</code>问题。可以通过如下方式解决：</p><ul><li>并发连接：增加多个TCP连接。</li><li>域名分片：把一个域名分成很多二级域名，相当于也是增加了多个连接</li></ul><h2 id="HTTP-2-0"><a href="#HTTP-2-0" class="headerlink" title="HTTP 2.0"></a>HTTP 2.0</h2><ul><li><strong>二进制分帧：</strong>将数据全部转为二进制，头信息和数据体都是二进制，统称为<strong>“帧”</strong>：头信息帧和数据帧。</li><li><strong>头部压缩：</strong>HTTP/1.x版本中可能会出现的<code>User-Agent、Cookie、Accept、Server、Range</code>等字段可能会占用几百甚至几千字节，而body部分可能才几十字节，导致头部偏重。HTTP 2.0 使用 <code>HPACK</code> 算法进行压缩。</li><li><strong>多路复用：</strong>复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求和回应，且不用按照顺序一一对应，这样就解决了队头阻塞的问题。</li><li><strong>服务器推送：</strong> 允许服务器未经请求，主动向客户端发送资源，即服务器推送。</li><li><strong>请求优先级：</strong> 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。</li></ul><h1 id="HTTP-2-0介绍"><a href="#HTTP-2-0介绍" class="headerlink" title="HTTP 2.0介绍"></a>HTTP 2.0介绍</h1><p>更加详细且权威的内容请参考：<a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-CN" target="_blank" rel="noopener">谷歌开发手册HTTP2.0</a>。</p><h2 id="头部压缩"><a href="#头部压缩" class="headerlink" title="头部压缩"></a>头部压缩</h2><p>　　上一节讲到HTTP/1.x的头部包含了太多的内容，导致头部偏重的问题。HTTP/2.0采用了HPACK算法进行了头部压缩。这一节主要介绍一下HPACK算法。官方文档：<a href="https://www.rfc-editor.org/rfc/rfc7541.txt" target="_blank" rel="noopener">RFC7541</a>。</p><h3 id="HPACK"><a href="#HPACK" class="headerlink" title="HPACK"></a>HPACK</h3><ul><li><p><strong>基本原理：</strong>HPACK 使用2个索引表(静态索引表和动态索引表)来把头部映射到索引值，并对不存在的头部使用哈夫曼编码，并动态缓存到索引，从而达到压缩头部的效果。</p><p>  <img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/hpack.png" alt></p><blockquote><p>从上面看，我们可以看到类似于索引表，每个索引表对应一个值，比如索引为2对应头部中的method头部信息，这样子的话，在传输的时候，不在是传输对应的头部信息了，而是传递索引，对于之前出现过的头部信息，只需要把<strong>「索引」</strong>(比如1，2，…)传给对方即可，对方拿到索引查表就行了。</p></blockquote></li><li><p>静态索引表：定义在RFC中的固定头部，当发送的值符合索引表时，只需要发送索引值就行。比如<code>2 :method GET</code>和<code>3 :method POST</code>是静态表中的两个字段，这样请求的方式如果是<code>GET</code>就可以只发送索引2。</p></li><li><p>动态索引表：动态表是一个由先进先出的队列维护的有空间限制的表，里面同样维护的是头部与对应的索引。<strong>每个动态表只针对一个TCP连接，也就是说每个TCP连接压缩解压缩的上下文中有且只有一个动态表。</strong>当一个头部没有出现过的时候，会把他插入动态表中，下次同名的值就可能会在表中查到到索引并替换掉头部。动态表初始为空。</p></li></ul><h2 id="多路复用"><a href="#多路复用" class="headerlink" title="多路复用"></a>多路复用</h2><p>HTTP/1.x中，如果想并发多个请求需要建立多个TCP连接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP连接请求限制。</p><p>HTTP/2.0：</p><ul><li><p>同域名的所有通信在单个连接上完成</p></li><li><p>单个通信可以承载任意数量的双向数据流</p></li><li><p>数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，根据帧首部的流标识重新组装，也就是<code>Stream ID</code>，这个标识符标志了这个帧是属于哪一条消息的，通过这个标识符，接收方就可以从乱序的二进制帧中选择ID相同的帧，按照顺序进行组装成一个报文。</p></li><li><p>这里要注意一下，TCP是字节有序的协议，所有报文之间必须顺序传送，<strong>同一个报文的帧也是顺序传送的</strong>，但是不同报文的帧可以交错，如下图：</p><p>  <img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/多路复用.png" alt></p></li></ul><h2 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h2><p>浏览器发送一个请求，服务器主动向浏览器推送与这个请求相关的资源（发送多个响应），这样浏览器就不用发起后续请求。</p><p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/服务器推送.png" alt></p><blockquote><p>HTTP/2 打破了严格的请求-响应语义，支持一对多和服务器发起的推送工作流，在浏览器内外开启了全新的互动可能性。 这是一项使能功能，对我们思考协议、协议用途和使用方式具有重要的长期影响。</p></blockquote><p>​        为什么在浏览器中需要一种此类机制呢？一个典型的网络应用包含多种资源，客户端需要检查服务器提供的文档才能逐个找到它们。 那为什么不让服务器提前推送这些资源，从而减少额外的延迟时间呢？ 服务器已经知道客户端下一步要请求什么资源，这时候服务器推送即可派上用场。</p><p><strong>优势：</strong></p><ul><li>推送资源可以由不同页面共享</li><li>服务器可以按照优先级推送资源</li><li>客户端可以缓存推送的资源</li><li>客户端可以拒收推送过来的资源</li></ul><h2 id="二进制分帧"><a href="#二进制分帧" class="headerlink" title="二进制分帧"></a>二进制分帧</h2><p>以前的版本都是明文传输，不利于计算机解析。HTTP/2.0采用二进制格式，全部传输01串，便于计算机解码。</p><p>这样子，一个报文就被拆分成一个个二进制帧，用<strong>Headers帧</strong>存放头部字段，<strong>Data帧</strong>存放请求体数据。</p><h3 id="数据流-消息-帧"><a href="#数据流-消息-帧" class="headerlink" title="数据流 消息 帧"></a>数据流 消息 帧</h3><p>这里简单解释一下数据流，消息和帧的概念：</p><ul><li>数据流：已建立的连接内的双向字节流，可以承载一条或多条消息。</li><li>消息：与逻辑请求或响应消息对应的完整的一系列帧。</li><li>帧：HTTP/2 通信的最小单位，每个帧都包含帧头，至少也会标识出当前帧所属的数据流。</li></ul><p>这些概念的总结如下：</p><ul><li>所有通信都在一个TCP连接上完成，此连接可以承载任意数量的双向字节流。</li><li>每个数据流都有唯一的标识符和可选的优先级信息，用于承载双向消息。</li><li>每条消息都是一条逻辑HTTP消息（请求或者响应），包含一个或多个帧</li><li>帧是最小的通信单位，承载着特定类型的数据，例如 HTTP 标头、消息负载等等。 来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装（所谓乱序）。</li></ul><h3 id="乱序帧的组装"><a href="#乱序帧的组装" class="headerlink" title="乱序帧的组装"></a>乱序帧的组装</h3><ul><li><strong>所谓的乱序，指的是不同ID的Stream是乱序的，对于同一个<code>Stream ID</code>的帧是按顺序传输的。</strong>（不厌其烦地再解释一遍）</li><li>接受方收到二进制帧之后，把相同<code>Stream ID</code>的帧组装成完整的请求报文或响应报文。</li><li>二进制帧中有一些字段，控制着<code>优先级</code>和<code>流量控制</code>等功能，这样子的话，就可以设置数据帧的优先级，让服务器处理重要资源，优化用户体验。</li></ul><h1 id="HTTP常见状态码"><a href="#HTTP常见状态码" class="headerlink" title="HTTP常见状态码"></a>HTTP常见状态码</h1><p>RFC定义了HTTP的状态码为三位数，第一个数字为响应的类别，一共分为五类。</p><ul><li><strong>1XX：</strong>代表请求已接受，需要后续处理</li><li><strong>2XX：</strong>表示成功</li><li><strong>3XX：</strong>重定向状态</li><li><strong>4XX：</strong>客户端错误</li><li><strong>5XX：</strong>服务端错误</li></ul><h2 id="2XX-成功"><a href="#2XX-成功" class="headerlink" title="2XX 成功"></a>2XX 成功</h2><ul><li><strong>200 OK</strong>：表示客户端的请求在服务端被正确请求。</li><li>204 No Content：表示请求成功，但是没有资源返回。</li><li>206 Paritial Content：表示客户端进行了范围请求，服务端成功执行了这部分的请求。响应报文中包含由<code>Content Range</code>指定范围的实体内容。</li></ul><h2 id="3XX-重定向"><a href="#3XX-重定向" class="headerlink" title="3XX 重定向"></a>3XX 重定向</h2><ul><li><strong>301 moved permanently：</strong>永久重定向，表示资源已被分配了新的URL，这时应该按 Location 首部字段提示的 URL 重新访问。</li><li><strong>302 found：</strong>临时重定向，表示资源被临时分配了新的URL。</li><li>303 see other：表示资源存在着另一个URL，应使用GET方法获取资源。</li><li>304 not modified，当协商缓存命中时会返回这个状态码。</li><li>307 temporary redirect，临时重定向，和302含义相同,不会改变method</li></ul><blockquote><ol><li><p>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成 GET，并删除请求报文内的主体，之后请求会自动再次发送</p></li><li><p>301、302 标准是禁止将 POST 方法改变成 GET 方法的，但实际使用时大家都会这么做</p></li></ol></blockquote><h2 id="4XX-客户端错误"><a href="#4XX-客户端错误" class="headerlink" title="4XX 客户端错误"></a>4XX 客户端错误</h2><ul><li><p>400 bad request：请求报文存在语法错误。</p></li><li><p>401 unauthorized：表示发送的请求需要有通过HTTP认证的认证信息。</p></li><li><p>403 forbidden：表示请求资源的请求被服务器拒绝。</p></li><li><p>404 not fond：表示在服务器上没有找到相应的资源。</p></li><li><p>405 Method Not Allowed：服务器禁止使用该方法，客户端可以通过options方法来查看服务器允许的访问方法，如下 ：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods →GET,HEAD,PUT,PATCH,POST,DELETE</span><br></pre></td></tr></table></figure></li></ul><h2 id="5XX-服务器错误"><a href="#5XX-服务器错误" class="headerlink" title="5XX 服务器错误"></a>5XX 服务器错误</h2><ul><li>500 internal sever error：表示服务端在执行请求时出现了错误。</li><li>502 Bad Gateway：服务器自身是正常的，访问的时候出了问题，具体啥错误我们不知道。</li><li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求。</li></ul><h1 id="HTTP缓存"><a href="#HTTP缓存" class="headerlink" title="HTTP缓存"></a>HTTP缓存</h1><h2 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h2><ul><li>缓解服务器的压力</li><li>降低客户端获取资源的速度：缓存一般存在在内存中，而且缓存服务器可能比源服务器更近一点（浏览器缓存）。</li></ul><h2 id="储存位置"><a href="#储存位置" class="headerlink" title="储存位置"></a>储存位置</h2><ul><li>代理服务器进行缓存</li><li>客户端浏览器进行缓存</li></ul><h2 id="强缓存"><a href="#强缓存" class="headerlink" title="强缓存"></a>强缓存</h2><p>浏览器在请求资源时会先判断有没有命中强缓存。HTTP/1.0 版本用<code>Expires</code>字段来控制强缓存，HTTP/1.1 版本使用<code>Cache-Control</code>来控制。</p><h3 id="Expires"><a href="#Expires" class="headerlink" title="Expires"></a>Expires</h3><p>　　设置缓存的过期时间，这个时间是针对服务器时间而言的，存在于服务器返回的响应头中，在这个过期时间内可以使用缓存，不需要再次请求。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Expires:Mon, 29 Jun 2029 11:10:23 GMT <span class="comment"># 过期时间为2029年06月29日</span></span><br></pre></td></tr></table></figure><p>　　可以注意到，浏览器的时间和服务器的时间可能不一致，因此在HTTP/1.1中用新的字段<code>Cache-Control</code></p><h3 id="Cache-Control"><a href="#Cache-Control" class="headerlink" title="Cache-Control"></a>Cache-Control</h3><p>　　<code>Cache-Control</code>通过设置<code>Max-Age</code>来设置缓存的过期时间。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cache-Control:max-age=6000 <span class="comment"># 6000秒后过期</span></span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ul><li><p>当<code>Expires</code>和<code>Cache-Control</code>同时存在时，优先考虑Cache-Control。</p></li><li><p>当然了，当缓存资源失效了，也就是没有命中强缓存，接下来就进入协商缓存</p></li></ul><h2 id="协商缓存"><a href="#协商缓存" class="headerlink" title="协商缓存"></a>协商缓存</h2><p> 　　强缓存失效后，浏览器在请求头中携带响应的<code>缓存Tag</code>来向服务器发送请求，服务器根据对应的tag，<strong>来决定是否使用缓存</strong>。Tag分为两种，<code>Last Modified</code>和<code>ETag</code>。如果两种方式都支持的话，服务器会优先考虑<code>ETag</code>。</p><h3 id="Last-Modified"><a href="#Last-Modified" class="headerlink" title="Last Modified"></a>Last Modified</h3><p>　　这个字段表示最后修改时间，当浏览器给服务器第一次发请求后，服务器会在响应头中加上这个字段。浏览器接收到这个请求后，如果<strong>再次发起请求</strong>，会在请求头中携带<code>IF-Modified-Since</code>字段，这个字段值就是服务器传来的最后修改时间。服务器拿到<code>IF-Modified-Since</code>字段后，<strong>会与服务器资源目前最新修改的时间最对比</strong>：</p><ul><li>如果<code>IF-Modified-Since</code>比最新修改的时间要小，也就是说服务器资源更新了，那么就会返回新的资源。</li><li>如果相等，则说明资源没有修改，那么返回304，告诉浏览器直接用缓存。</li></ul><h3 id="ETag"><a href="#ETag" class="headerlink" title="ETag"></a>ETag</h3><p>　　ETag是服务器根据当前文件的内容，对文件生成唯一的标识，比如MD5算法，只要里面的内容有改动，这个值就会修改，<strong>服务器通过把响应头把该字段给浏览器</strong>。浏览器接收到Tag值，会在下次请求中把这个值放到<code>IF-None-Match</code>字段里发个服务器。服务器拿到这个值后，和最新资源的ETag做对比：</p><ul><li>相等，返回304</li><li>否则，返回新的资源</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><ul><li><p>性能上，<code>Last-Modified</code>优于<code>ETag</code>，<code>Last-Modified</code>记录的是时间点，而<code>Etag</code>需要根据文件的MD5算法生成对应的hash值。</p></li><li><p>精度上，<code>ETag</code>优于<code>Last-Modified</code>。<code>ETag</code>按照内容给资源带上标识，能准确感知资源变化，<code>Last-Modified</code>在某些场景并不能准确感知变化，比如：</p><ul><li>编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。</li><li>Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。</li></ul></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li><p>首先检查<code>Cache-Control</code>， 看强缓存是否可用</p></li><li><p>如果可用的话，直接使用</p></li><li><p>否则进入协商缓存，发送HTTP请求，服务器通过请求头中的<code>If-Modified-Since</code>或者<code>If-None-Match</code>字段检查资源是否更新</p></li><li><p>资源更新，返回资源和200状态码。</p></li><li><p>否则，返回304，直接告诉浏览器直接从缓存中去资源。</p></li></ol><h1 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h1><h2 id="和HTTP的区别"><a href="#和HTTP的区别" class="headerlink" title="和HTTP的区别"></a>和HTTP的区别</h2><p>　　HTTPS相比HTTP就是多了一个安全性的概念，实际上，HTTPS并不是一个全新的应用层协议，它就是<code>HTTP + TLS/SSL</code>，而安全性就是<code>TLS/SSL</code>做的工作。</p><ul><li>SSL（Secure Sockets Layer）：安全套接层</li><li>TLS（Transport Layer Security）：传输层安全，目前使用的版本是1.2</li></ul><p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/HTTPS.png" alt></p><p>主要有如下区别：</p><ul><li>HTTP 是明文传输协议，HTTPS 协议是由 SSL+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全。</li><li>HTTPS比HTTP更加安全，对搜索引擎更友好，利于SEO,谷歌、百度优先索引HTTPS网页。</li><li>HTTPS标准端口443，HTTP标准端口80。</li><li>HTTPS需要用到SSL证书，而HTTP不用。</li></ul><p><strong>HTTPS有两点关键的作用：</strong></p><ul><li>建立信息安全的通道，保证数据传输的安全。</li><li>对网站服务其进行真实身份验证。</li></ul><h2 id="HTTPS工作原理"><a href="#HTTPS工作原理" class="headerlink" title="HTTPS工作原理"></a>HTTPS工作原理</h2><p>工作原理就是过了一层<code>SSL/TCL</code>连接。</p><blockquote><p>TLS/SSL 的功能实现主要依赖于三类基本算法：<code>散列函数</code> 、<code>对称加密</code>和<code>非对称加密</code>。</p><ul><li>非对称加密实现身份认证和密钥协商</li><li>对称加密算法采用协商的密钥对数据加密</li><li>散列函数验证信息的完整性。</li></ul></blockquote><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>　　对称加密就是指客户端和服务端使用同一个密钥来加密明文。</p><p>　　但是不同的客户端密钥肯定不同，服务器要和客户端拥有相同的密钥就需要把密钥从客户端通过HTTP传输过来，这样密钥就会被拦截，很不安全。但是如果这个密钥别人获取不到，那么就是安全的。</p><h3 id="非对称加密TLS-1-2"><a href="#非对称加密TLS-1-2" class="headerlink" title="非对称加密TLS 1.2"></a>非对称加密TLS 1.2</h3><p>　　采用的算法是RSA，所以在一些文章中也会看见<strong>传统RSA握手</strong>，基于现在TLS主流版本是1.2，所以接下来梳理的是<strong>TLS/1.2握手过程</strong>。非对称加密需要知道以下要点：</p><ul><li>有一堆密钥，公钥和私钥。</li><li>公钥加密的内容，只有私钥也可以解开，私钥加密的内容，只有公钥可以解开。</li><li>公钥发送给所有客户端，私钥只保存在服务端。</li></ul><h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/TLS1.2.PNG" alt></p><p><strong>步骤解释：</strong></p><ol><li><p>Client发送一个HTTPS请求，连接443端口。这个请求可以理解成是<strong>请求公钥</strong>。</p></li><li><p>Server端收到请求后通过第三方机构私钥加密，会把数字证书（公钥证书）发给Client。</p></li><li><p>浏览器验证公钥证书</p><ul><li><p>浏览器安装后会自动带一些权威第三方机构公钥，使用匹配的公钥对数字签名进行解密。</p></li><li><p>根据签名生成的规则对网站信息进行本地签名生成，然后两者比对。</p></li><li><p>通过比对两者签名，匹配则说明认证通过，不匹配则获取证书失败。</p></li></ul></li><li><p>在安全拿到<strong>服务器公钥</strong>后，客户端Client随机生成一个<strong>会话密钥</strong>（SessionID），使用<strong>服务器公钥</strong>（证书的公钥）加密这个<strong>对称密钥</strong>，发送给Server(服务器)。</p></li><li><p>Server端用私钥解密得到会话密钥，至此两端都有了一个相同的密钥作为<strong>对称密钥</strong>。</p></li><li><p>两端使用对称密钥对请求的数据进行加密和解密</p></li></ol><h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>　　在第二步的时候，我发给Client的公钥证书被劫持且篡改了怎么办？因为证书中有公钥，这个公钥是公开的，如果有中间人替换了这个公钥，Client是感知不到的。</p><p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/公钥劫持.png" alt></p><h2 id="第三方认证"><a href="#第三方认证" class="headerlink" title="第三方认证"></a>第三方认证</h2><p>如果只用非对称加密，一旦证书被劫持，Client感知不到。如果让Cilent可以感知呢？</p><h3 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h3><p>在HTTPS中，通过”<strong>证书 + 数字签名</strong>”来解决这个问题。</p><p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/数字签名.png" alt></p><p>　　可以看到，数字签名是单独加密的：<strong>使用第三方认证机构的私钥。</strong></p><p>　　如果证书再被劫持，把服务器的公钥替换成假的公钥，因为有数字签名的存在，客户端会发现数字签名不匹配。因为数字签名有第三方的私钥加密，这个私钥中间人是不知道的。<font color="red">数字签名用<strong>散列函数</strong>计算了<strong>公钥证书</strong>中部分信息</font>，如果中间人修改了公钥证书，客户端解开数字签名后，内容就会不匹配，这就保证了可靠性。</p><h3 id="客户端如果对比数字签名？"><a href="#客户端如果对比数字签名？" class="headerlink" title="客户端如果对比数字签名？"></a>客户端如果对比数字签名？</h3><ol><li>浏览器会去安装一些比较权威的第三方认证机构的公钥，比如VeriSign、Symantec以及GlobalSign等等。</li><li>验证数字签名的时候，会直接从本地拿到相应的第三方的公钥，对私钥加密后的数字签名进行解密得到真正的签名。</li><li>然后客户端利用签名生成规则（这里具体的规则就不讲了，散列函数只是一种）进行签名生成，看两个签名是否匹配，如果匹配认证通过，不匹配则获取证书失败。</li></ol><h2 id="SSL断开后如何恢复？"><a href="#SSL断开后如何恢复？" class="headerlink" title="SSL断开后如何恢复？"></a>SSL断开后如何恢复？</h2><p>　　可以看到，HTTPS建立连接十分麻烦，且十分耗时。有两种方式可以快速的恢复SSL连接，一种是使用SessionID，另一种是Session Ticket。</p><h3 id="SessionID"><a href="#SessionID" class="headerlink" title="SessionID"></a>SessionID</h3><p>　　使用 session ID 的方式，每一次的会话都有一个编号，当对话中断后，下一次重新连接时，只要客户端给出这个编号，服务器如果有这个编号的记录，那么双方就可以继续使用以前的秘钥，而不用重新生成一把。目前所有的浏览器都支持这一种方法。但是这种方法有一个缺点是，session ID 只能够存在一台服务器上，<strong>如果我们的请求通过负载平衡被转移到了其他的服务器上</strong>，那么就无法恢复对话。</p><h3 id="Session-Ticket"><a href="#Session-Ticket" class="headerlink" title="Session Ticket"></a>Session Ticket</h3><p>　　另一种方式是 session ticket 的方式，session ticket 是服务器在上一次对话中发送给客户的，这个 ticket 是加密的，只有服务器能够解密，里面包含了本次会话的信息，比如对话秘钥和加密方法等。这样不管我们的请求是否转移到其他的服务器上，当服务器将 ticket 解密以后，就能够获取上次对话的信息，就不用重新生成对话秘钥了。</p><h1 id="短轮询、长轮询和-WebSocket"><a href="#短轮询、长轮询和-WebSocket" class="headerlink" title="短轮询、长轮询和 WebSocket"></a>短轮询、长轮询和 WebSocket</h1><h2 id="短轮询"><a href="#短轮询" class="headerlink" title="短轮询"></a>短轮询</h2><p><strong>短轮询的基本思路:</strong></p><ul><li>浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行 响应。</li><li>这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。</li></ul><p><strong>优缺点：</strong></p><ul><li>优点是便于理解</li><li>缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</li></ul><h2 id="长轮询"><a href="#长轮询" class="headerlink" title="长轮询"></a>长轮询</h2><p><strong>长轮询的基本思路:</strong></p><ul><li>首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。</li><li>如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。</li></ul><p><strong>优缺点：</strong></p><ul><li>长轮询和短轮询比起来，它的优点是<strong>「明显减少了很多不必要的 http 请求次数」</strong>，相比之下节约了资源。</li><li>长轮询的缺点在于，连接挂起也会导致资源的浪费。</li></ul><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><ul><li><p>WebSocket 是 Html5 定义的一个新协议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。</p></li><li><p>使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息。</p></li></ul><h1 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h1><p>DNS协议提供了一种主机名到IP地址的转换服务，就是我们常说的域名系统。这是应用层的协议，通常该协议建立在UDP之上，这就要求域名解析器和域名服务器都必须自己处理超时和重传来确保可靠性，使用53端口号。有两种情况会建立TCP连接：</p><ul><li>返回的响应超过了512个字节（UDP最多传递512字节）</li><li>区域传送（主域名向辅助域名传送数据）</li></ul><h2 id="查询流程"><a href="#查询流程" class="headerlink" title="查询流程"></a>查询流程</h2><ol><li>客户端不会直接去请求本地DNS服务器，而是通过下图流程一步步查询：</li></ol><p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/客户端请求域名.png" alt></p><ol><li>本地DNS服务器查询IP的过程一般是<strong>递归查询</strong></li></ol><p><img src="/2020/09/18/HTTP%E8%AF%A6%E8%A7%A3/本地DNS迭代查询.png" alt></p><ol><li><strong>迭代查询：</strong>用户请求DNS服务器后，DNS服务器直接返回结果，如果没有找到域名，则由用户自己发送下一级请求。</li></ol><p>　　可以这么理解：本地服务器看起来自己的请求时递归的，因为我只需要发一次请求，但是本地DNS服务器的请求是迭代的，需要服务器一次次去查询。</p><h2 id="DNS缓存"><a href="#DNS缓存" class="headerlink" title="DNS缓存"></a>DNS缓存</h2><p>　　在一个请求中，当某个DNS服务器收到一个DNS回答后，他能够将回答中的信息存储到本地储存器中。返回资源中的TTL代表该记录的缓存时间。</p><h2 id="DNS为什么要使用UDP？"><a href="#DNS为什么要使用UDP？" class="headerlink" title="DNS为什么要使用UDP？"></a>DNS为什么要使用UDP？</h2><p><strong>「DNS 使用 UDP 协议作为传输层协议的主要原因是为了避免使用 TCP 协议时造成的连接时延。」</strong></p><ul><li>为了得到一个域名的 IP 地址，往往会向多个域名服务器查询，如果使用 TCP 协议，那么每次请求都会存在连接时延，这样使 DNS 服务变得很慢。</li><li>大多数的地址查询请求，都是浏览器请求页面时发出的，这样会造成网页的等待时间过长。</li></ul><h2 id="DNS实现负载均衡"><a href="#DNS实现负载均衡" class="headerlink" title="DNS实现负载均衡"></a>DNS实现负载均衡</h2><p>想不到吧，DNS还能做负载均衡，因为一个域名可能对应不同的ip。</p><ul><li>当用户发起网站域名的 DNS 请求的时候，DNS 服务器返回这个域名所对应的服务器 IP 地址的集合</li><li>在每个回答中，会循环这些 IP 地址的顺序，用户一般会选择排在前面的地址发送请求。</li><li>以此将用户的请求均衡的分配到各个不同的服务器上，这样来实现负载均衡。</li></ul><h2 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h2><ul><li>DNS域名系统是应层的协议，运行在UDP之上，使用端口53</li><li>查询过程，本地查询是递归查询，依次通过 <strong>浏览器缓存—-本地hosts文件—-本地DNS解析器—-本地DNS服务器—-其他域名服务器请求</strong>。 接下来的过程就是迭代过程。</li><li>递归查询一般而言，发送一次请求就够，迭代过程需要用户发送多次请求。</li></ul><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://www.jianshu.com/p/f44b930cfcac" target="_blank" rel="noopener">HPACK完全解析</a></li><li><a href="https://developers.google.com/web/fundamentals/performance/http2/?hl=zh-CN" target="_blank" rel="noopener">HTTP/2简介 Google</a></li><li><a href="https://juejin.im/post/6857287743966281736#heading-59" target="_blank" rel="noopener">「查缺补漏」巩固你的HTTP知识体系</a></li><li><a href="https://github.com/CyC2018/CS-Notes/blob/master/notes/HTTP.md#%E5%85%ADhttps" target="_blank" rel="noopener">CS-NOTE</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文主要梳理HTTP协议的知识体系&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HTTP基础&lt;/li&gt;
&lt;li&gt;DNS&lt;/li&gt;
&lt;li&gt;HTTP缓存策略&lt;/li&gt;
&lt;li&gt;HTTPS&lt;/li&gt;
&lt;li&gt;常见问题&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>计网相关基础知识</title>
    <link href="http://yoursite.com/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</id>
    <published>2020-09-17T03:19:09.000Z</published>
    <updated>2020-11-02T09:27:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文旨在介绍计网的相关基础知识，只介绍到网络层之上</p><ol><li>计算机网络概述</li><li>应用层</li><li>Socket</li><li>传输层</li><li>网络层</li></ol></blockquote><a id="more"></a><h1 id="计算机网络概述"><a href="#计算机网络概述" class="headerlink" title="计算机网络概述"></a>计算机网络概述</h1><p>​    计算机网络就是为了解决<strong>计算机之间的通信问题</strong>。通讯就是指数据的交换，即信息的交换。计算机的世界里，一切信息都是数据。</p><p>​    与计算机网络有关的东西有很多：网线，网卡，路由器，IP地址，TCP，HTTP，FTP等等。这些东西分别对应着计算机网络中的不同层次。层次有不同的分法：</p><ul><li>OSI模型将计算机网络分成了7层，由上至下分别是：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层。因为分的太细，与实际操作时不相匹配的，因此市场上很少使用这种模型。</li><li>市场上成功的模型一般是四层或者五层，分成五层比较好理解：应用层、传输层、网络层、数据链路层、物理层。网线属于物理层，网卡属于数据链路层，路由器属于网络层，对应的协议有IP和ICMP协议，TCP属于传输层，HTTP属于应用层等等。</li></ul><p>​    计算机网络分层的原因在于其体系结构太复杂了，按照不同设备的功能划分成不同的层次更易于规范的标准化，而且每一层相对其它层独立且透明，这一层变化了也不影响其他层的工作，更易于维护。透明的含义可以解释如下：计算机网络的每一层之间不需要理解对方是则怎么工作的，我只需要接收下层给我的数据，这个数据符合我定义的数据规范，我解读并处理了该数据后，按照上一层定义的数据格式封装我的数据，并提交给上一层，上一层就能正确接收到我的数据。分层之后，某层的修改不会影响到其他层，<strong>举个通俗的例子：</strong>IPV4和IPV6是网络层不同版本的协议，但是这两种版本的切换对应用层HTTP是没有区别的，因为不管用IPV4或者IPV6，传给HTTP的数据格式都是一样的。</p><h1 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h1><p>​    应用层协议比较多，每个协议有不同的功能和用法，比如HTTP用于网页内容的传输，FTP用于文件的传输，SMTP用于邮件的传输等。HTTP是做web服务必须了解的知识点，但是内容很多，我单独写了一片博客：<a href>HTTP详解</a></p><h1 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h1><p>​    在应用层和传输层之间有一个接口叫做Socket。Socket不属于某一个层，它可以理解应用层和传输层之间的一个管道，用来连接操作系统和应用层中的具体应用进程，应用可以操作Socket来使用操作系统的网络功能。</p><p>​    因为传输层之下基本都是由操作系统控制，而应用层协议是由应用进程控制，所以要定义一个接口来建立起应用进程和底层协议的桥梁，这个接口的实现就是Socket。大部分操作系统都实现了Socket。</p><h1 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h1><p>​    传输层最经典的两个协议是TCP和UDP，其他的比如DCCP，SCTP本文就不讲了。传输层提供的是应用进程之间的逻辑通信机制。传输层通过Socket提供的端口号，把一个进程的数据传送到另一个进程。</p><p>​    传输层有多路复用的概念，这和物理层中的多路复用不一样，物理层的多路复用是指物理线路上的复用，如：频分复用、码分复用等；而传输层中多路复用是指：多个数据报被同时接收，计算机如何处理这些数据包是如何分发，按照什么原则分发。在传输层之下，所有的数据包都经过了相同的处理，但到了传输层，不同的数据包传输就有了区别。所有其他主机给我发送的所有UDP数据包都会被提交到同一个端口，而TCP数据包会根据其连接的不同分发给不同的端口。因为TCP连接是一对一的，每个端口只对应一个连接，也同时对应发送数据的主机上某个唯一端口，因此如果发送数据的主机想要和我创建多条TCP连接，需要创建不同的进程或者线程，还需要相应的端口号。</p><h2 id="UDP"><a href="#UDP" class="headerlink" title="UDP"></a>UDP</h2><p>​    UDP只对IP协议做简单的拓展，仅仅只把网络层传输过来的数据区分一下端口号，就递给进程了，有可能也会做一点简单的错误检测。UDP有以下的好处（主要和TCP对比）：</p><ol><li>不需要建立连接，因此数据请求的延迟小；</li><li>实现简单，不需要负责实现过程，比如维护连接等；</li><li>头部开销很小，在数据内容之上，只包装了一些区别端口号和差错检验的账号；</li><li>应用层可以很好地对其进行拓展。</li></ol><p>​    UDP数据报的结构如下：<img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/UDP数据包.png" alt></p><p>​    可以看到，一个UDP数据报，除了具体的传输数据，还在首部增加了8个字节的数据用来区分端口，限制长度和差错校验。其中这个数据长度是包含了8个字节的头部数据的，可以看出一个UDP的数据包的长度是有限制的，不能太大。UDP的源端口号可以省略，如果省略则代表了我的数据一旦发出去，就不需要回复了；校验和字段也可以省略，不过一般都会做一些简单的校验，防止数据在传输过程中出错，导致数据乱序，残缺。这种数据应用层接受到是无法使用的。校验后这种错误的数据会在传输层废弃，然后给发送源一个ICMP数据包，告知数据错误，然后这个数据传输就结束了，因为UDP不提供重传机制。</p><p>​    UDP进行差错检验的方法和IP中的方法一致，这里先不提。UDP的差错检验保证了端口与端口之间正确传输的检测，也能核实出数据部分是否产生了错误。在进行差错检测时，会添加一些额外的数据参与计算，这些数据计算完之后就丢弃了，真正用来传输的数据格式还是上面那个。伪首部结构如下图红色的部分：</p><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/UDP数据包-伪首.png" alt></p><h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP是一个点到点（端口到端口）的协议，是一个可靠的，按序字节流的协议。是一个面向连接的协议。</p><p>接收方和发送方都会有一定的存储空间用来缓存数据，一般用于重传，分组重组等功能。</p><p>面向连接的含义：通信前必须建立连接，两端维护连接，中间节点不连接。</p><p>TCP提供了可靠的数据传输，流量控制和拥塞控制。</p><h3 id="可靠的数据传输"><a href="#可靠的数据传输" class="headerlink" title="可靠的数据传输"></a>可靠的数据传输</h3><p>​    TCP实现可靠的数据传输主要是基于一种确认（acknowledge，ACK）机制。简单说来就是，我发你一个数据包，你得告诉我你收到了，不然我默认你没收到，等一段时间后就会重新发这个数据包给你，直到你告诉我你收到了。这是保证可靠传输的逻辑。</p><p>​    在可靠传输的具体实现中，TCP采用的是累加确认，确认的是数据中的自己号，而不是确认收到了第几个数据包。正因如此，TCP才被叫做按序字节流的协议。</p><p>​    在TCP发出报文后，如果没有收到确认，要过多久才会重新发送数据呢？计算超时时间有一个算法，里面最主要的参数是RTT（Round Trip delay time），RTT指我发出一个报文开始，到我接受到ACK报文所经过的时间。根据历史值的平均数，和上一个数据包的 RTT 值，经过加权计算之后的值设置为当前数据报的超时时间。这样结合了当前网络和历史网络的状况后得到的结果最合理。如果我发过了一个报文，过了超时时间，就会重新发。因为等待ACK报文需要时间，一个个发报文严重影响传输效率，因此TCP一般都一段段发：<font color="red"><strong>TCP有一个滑动窗口机制</strong></font>，一段一段的发送数据，确认时只按收到了第几个字节数（可以理解成下一个报文的头位置）来确认。这一过程中会遇到这样的问题：第五段报文丢失了，第六段、第七段和第八段报文被接收了，接收方因为没有收到第五段报文，因此在收到第六段报文时，接收方会发一个第五段报文的ACK报文，然后又收到了第七段报文，没办法，只好再发一次第五段的ACK，然后又收到了第八段报文，只好再发一次第五段报文ACK，至此，接收方连续发送了<strong>三次</strong>第五段报文的ACK，发送方立刻重发第五段报文，这就是<font color="red"><strong>快重传机制</strong></font>，可见快重传不需要等待计时器超时。一般设置了3次重复ACK报文就会启动重传，因为如果丢包，必然会有两次以上的ACK，但是如果只收到了两次ACK，则很有可能是乱序造成的，这时候重传解决不了问题，详见<a href="https://www.zhihu.com/question/21789252/answer/110640581" target="_blank" rel="noopener">TCP 快速重传为什么是三次冗余 ACK，这个三次是怎么定下来的？</a></p><h3 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h3><p>上面讲到TCP的有一个滑动窗口机制。接收方也有一个缓存窗口。如果数据的读取很慢，但是网速却很快，数据大量集中，超过了接收方缓存的大小，这时候即使再来数据，也无法接收，于是接收方就不停地发送缓存窗口最后一个位置的ACK，然后发送方就会不停地进行重传，这大大浪费了网络资源。因此，<strong>接收方每次返回ACK报文时，会在报文中加入缓存空间的剩余量是多少</strong>，发送方根据剩余量的多少发送数据。<strong>这里有一个边界问题：如果接受方的ACK报文中剩余量为0时怎么办？</strong>肯定不可能停止发送数据，因为停止发送就再也不知道剩余缓存量的变化了。因此，如果接收方缓存剩余量为0，发送方会间歇性、尝试性地发送一组探测报文（ZWP），探测一下对方还有多少余量，如果余量变多了就恢复数据的传输，这就实现了TCP的流量控制。</p><h3 id="拥塞机制"><a href="#拥塞机制" class="headerlink" title="拥塞机制"></a>拥塞机制</h3><p>TCP采用的是端到端的控制方法，由两端的计算机控制，中间的路由不提供明显的控制。TCP的拥塞控制中有多种算法。目前TCP的拥塞控制流程一般是这样的：</p><ul><li>最一开始，采用<strong>慢开始</strong>算法，发送窗口的大小成指数上升到某一阈值。举个例子，窗口大小依次为：1，2，4，8，16，32，64（阈值ssthresh，假设这个值是64）</li><li>到达阈值后，采用线性增算法（<strong>拥塞避免</strong>），发送窗口的大小每个时间点增加一：64，65，66，67….。</li><li>这时候会出现两种情况<ul><li>当增加到80时，发送方连续收到三个相同的ACK：立刻将发送窗口大小设为40（减一半），并将阈值也设置成40，随后线性增加发送窗口大小的算法。<font color="red"><strong>这就是快恢复</strong></font>。</li><li>当增加到80时，发送方发现一个数据包超时了（也就是没有收到接收方的ACK报文），立刻把发送窗口的大小设置成1。</li><li>解释<ul><li>第一种情况要么是乱序，要么是丢包，不管是那种，数据包都是能够传输进来的，网络很通畅，因此可以指定快恢复。</li><li>第二种情况直接超时了，说明网络质量很差，这时候需要降低发送速率，防止阻塞。</li></ul></li></ul></li></ul><p>为什么TCP有拥塞控制？因为其有重传机制，网络环境差就会不停地重传，造成阻塞，而UDP不依赖于网络环境，丢了就丢了。</p><h3 id="TCP报文"><a href="#TCP报文" class="headerlink" title="TCP报文"></a>TCP报文</h3><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/TCP报文.png" alt></p><p>由上至下依次解释如下：</p><ul><li>1、源端口号：数据发起者的端口号，16bit</li><li>2、目的端口号：数据接收者的端口号，16bit</li><li>3、<font color="red"><strong>序列号</strong></font>：32bit的序列号，<strong>真正发送数据时使用，告知当前发送的一段数据的<font color="red">首字节的序列号</font></strong>，如果发的报文不含数据（如确认报文），此字段是没有变化的。若 SYN=1 或 FIN =1 的数据报当作含有一字节数据。</li><li>4、<font color="red"><strong>确认序列号</strong></font>：32bit的确认号，是接收数据方<strong>期望收到发送方的下一个报文段</strong>的序号，<strong>因此确认序号应当是对方刚刚发给你的 TCP 报文中的序号字段加数据长度的值再<font color="red">加1</font>，是你的确认序号</strong>，你要回复他说，我收到你的数据了，所以要确认的是对方的序号。  </li><li>5、首部长度：4位，最大可表示的数为 15 。而光首部就有 20 字节，所以在这里规定，每个 1 代表 4 字节，就是上图中的一行，这个字段值为几，就是几行。最大可表示 15*4 = 60 字节。</li><li>6、保留：6bit，均为0</li><li>7、紧急URG：当URG=1时，表示报文段中有紧急数据，应尽快传送，紧急指针字段有效。</li><li>8、确认比特ACK：ACK = 1时代表这是一个确认报文，取值 0 则不是确认报文；</li><li>9、<strong>推送比特PSH</strong>：当发送端PSH=1时，接收端尽快的交付给应用进程；</li><li>10、复位比特（RST）：当RST=1时，表明TCP连接中出现严重差错，必须释放连接，再重新建立连接；</li><li>11、<strong>同步比特SYN：在建立连接是用来同步序号</strong>。<strong>一个报文中 SYN=1,ACK=0时，是表示这一个连接请求报文段。SYN=1，ACK=1时表示的是接收方同意建立连接。</strong></li><li>12、<strong>终止比特FIN</strong>：FIN=1时，表明此报文段的发送端的数据已经发送完毕，并要求释放传输连接。</li><li>13、<strong>窗口</strong>：就是提供流量控制的功能，表示可缓存字节数的多少。</li><li>14、校验和：该字段检验的范围包括首部和数据这两部分。由发端计算和存储，并由收端进行验证。</li><li>15、紧急指针：紧急指针在URG=1时才有效，它指出本报文段中的紧急数据的字节数。</li><li>16、选项：长度可变，最长可达40字节。绝大多数不适用此字段，也就是说 TCP 绝大部分是 20 字节。</li></ul><h3 id="TCP连接"><a href="#TCP连接" class="headerlink" title="TCP连接"></a>TCP连接</h3><p>TCP是面向连接的，双方进行数据交换前必须建立连接。TCP的连接机制就是注明的三次握手，四次挥手。</p><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>讲握手机制之前必须明确一个概念。序列号，用来标志我发送数据的第一个字节的序号。在建立连接前，会根据计算机的时钟信号初始化一个序列号，这个序列号是操作系统计算出来的（防止有人伪造连接）。目前我还没有发送数据，所以TCP头部信息中的序号的值就是初始值。</p><ul><li>发送端发起连接请求：向接收端发起一个请求连接的TCP报文，初始化一个序号x，SYN = 1, ACK = 0。</li><li>接收端收到连接请求，发起一个同意连接的TCP报文：接收端也会初始化一个序号y，SYN = 1, ACK = 1（同时确认序列号为：x + 1，可以简写成 ACK = x + 1)</li><li>发送端也发送了一次ACK，告知接收端我收到了你的同意：ACK = 1（确认序号为：y + 1，简写成 ACK = y + 1）</li></ul><p>​    两台主机都有自己的序号，建立连接的过程就是相互确认对方的序列号，从而在交换数据的时候保证有效。确认序号要确认的是期望得到的下一段报文的序号。</p><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/三次握手.png" alt></p><p>​    为什么需要三次握手呢？发送方如果发送了一条请求连接的报文A，但是因为网络问题超时了，此时发送端会重新再发一条请求B，这两条请求的序号是不一样的，此时如果接收方返回了一个同意连接的请求C，这个C的确认序号是基于A报文的序号的，如果此时接收方建立了连接，那就是B和C建立了连接，此时序号对不上，那么数据传输就会失败。此时引入了三次握手，如果接受方收不到C报文的ACK，就不会建立连接。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><ul><li>我准备断开连接了，此时发送一条请求断开连接的TCP报文：FIN = 1, seq = x + 2，ACK = 1（ACK = y + 1）。<ul><li>官方文档规定，除了建立连接，任何时候ACK都要是1</li><li>我一旦发出了FIN报文，我就不会再发送有数据的报文了</li><li>这里seq是x+2主要是为了与图片一致</li></ul></li><li>你收到了我的FIN报文，回复一个ACK，同意断开：ACK = x + 3<ul><li>此时，你虽然应答了我的断开连接报文，但是你仍可以继续传输数据。比如你的数据还没有穿完我就发给你一个断开连接的报文，如果你没有传完数据，是可以继续一直传的。</li></ul></li><li>你传完了数据，发我一个FIN：seq = y + 1</li><li>我收到了你的FIN，发送一个ACK：ACK = y + 2<ul><li>此时你如果收到了我的ACK，就可以立刻释放连接了</li><li>我不能释放连接，因为我不确定你有没有收到我的ACK，因此我需要等一段时间再释放（数据包最大存活时间的两倍：2MSL）</li></ul></li></ul><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/四次挥手.png" alt></p><p>注意：</p><ol><li><p>收到我的FIN之后，如果你没有要传给我的数据，那么你就直接返回个FIN给我，这样就简化成了三次挥手。</p></li><li><p>为什么要四次挥手？要么保证发送方能够正确释放连接，要么保证接受方能够正确释放连接，少一个都不行。</p></li><li>为什么要等待2MSL，超过2MSL后，连接中的所有报文会自动丢弃，这样我释放连接再建立了新连接后，可以保证没有旧的报文。</li></ol><h1 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h1><p>​    网络层的核心功能是<strong>转发</strong>和<strong>路由</strong>。因为要实现路由和转发功能，所以这一层实现了很多路由协议，要实现转发，就需要知道转发地址，这用到了IP协议。IP协议中规定一些寻址规则，以及数据报过大时如何切成一小片一小片的问题等。此外，网络层还包括重要的 ICMP 协议，依托于这种协议的数据都像是网络中的指令，计算机或者中间路由设备就成为了官兵的角色，根据指令内容做出相应的动作反应。</p><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><h3 id="基础知识科普"><a href="#基础知识科普" class="headerlink" title="基础知识科普"></a>基础知识科普</h3><p>​    IP地址是有限的，只有32bit，所以要对其进行划分，比如中国一部分，美国一部分。划分大块后还要继续划分，划给省、市、学校等等。这个划分过程，称为划分子网。于是就规定了，IP地址是有两个部分组成的<strong><font color="red">网络号和主机号</font></strong>。网络号的位置是不确定的，如果一个子网很大，网络号就小，主机号就可以很多。</p><p>​    以前会把IP地址划分成A,B,C类，还有划分子网的概念，将主机号中的一部分拿出来作为子网号：IP = 网络号 + 子网号 + 主机号。要使用子网必须使用子网掩码，一个B类地址默认的子网号是<code>255.255.0.0</code>，如果他的子网占两个比特，那么他的子网掩码就是<code>11111111.11111111.11000000.00000000 = 255.255.192.0</code>。外部网络是看不见子网的。</p><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/IP地址分类.png" alt></p><p>​    现在划分子网的方式是CIDR（无类域间路由），形式是 <code>x.x.x.x/n</code>，例如：<code>202.113.132.45/24</code>，这表示前24位是网络号，后8位是主机号。</p><p>​    这里列举一些特殊的网络地址：</p><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/特殊的网络地址.png" alt></p><p>​    以上特殊的网络地址有可能会碰到，放在这里记录一下。</p><p>​    还有一些是私有的网络地址，一般是自己的内部局域网访问，比如校园网什么的。如下图所示：</p><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/私有网络地址.png" alt></p><h3 id="IP数据格式"><a href="#IP数据格式" class="headerlink" title="IP数据格式"></a>IP数据格式</h3><p>​    从传输层传来的TCP或UDP的段需要在网络层增加一个首部，然后在提交给数据链路层。网络层对数据作了些什么呢？首先网络层具有转发的功能，因此必须要知道数据的目的地，于是网络层对数据增加了目的地址，这个目的地址就IP地址，唯一地标识一台主机。网络层还会对超过MTU（Max Transfer Unit最大传输单元）的数据包进行分片。以太网的MTU是1500字节，这是经验的规定，因为如果MTU设置的太小，数据包被切成很多快，传输的错误率就会上升，不利于数据的传输；切的太大，又会增加传输的延迟。</p><p>​    IP数据报的结构如下：</p><p><img src="/2020/09/17/%E8%AE%A1%E7%BD%91%E7%9B%B8%E5%85%B3%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/IP数据报.png" alt></p><ol><li><p><strong>版本 4bit</strong> 指 IP 协议的版本。目前广泛使用的 IP 协议版本号为 4 ，IPv6，版本号为 6 。</p></li><li><p><strong>首部长度</strong> <strong>4bit</strong> 单位是 4 个字节( 32bit 也就是上面的一行。因为 4bit 最大描述的数值是15，首部长度最短也需要20字节，不够描述的，所以单位改成 4 字节)，那这里的值一般为 5 。首部长度也就是 20 字节。首部长度大小取值范围 20 字节到 60 （4*15）字节，首部长度一般都是 20 字节。当 IP 分组的首部长度不是 4 字节的整数倍时，必须利用最后的填充字段加以填充。因此数据部分永远在4字节的整数倍开始。</p></li><li><p><strong>区分服务</strong> <strong>8bit</strong> 目前几乎不使用，若要支持区分服务，需要中间所有的路由器都支持区分服务，但是目前的绝大多数路由器都不支持，所以区分服务几乎不使用了。</p></li><li><p><strong>总长度 16bit</strong> 首部长度 + 数据长度，单位是字节。数据报的最大长度为 2^16-1 = 65535 字节。但由于数据链路层的最大传送单元 MTU &lt; 65535，所与当一个数据报封装成链路层的帧时，此数据报的总长度（即首部加上数据部分）一定不能超过下面的数据链路层的MTU值，若超过则需要分片(因此有上图的第二行，用于切片)。</p></li><li><p><strong>标识 16bit</strong> 软件在存储器中维持一个计数器，每产生一个数据报，计数器就加1，并将此值赋给标识字段。但这个“标识”并不是序号，因为 IP 是无连接服务，数据报不存在按序接收的问题。<strong>当数据报由于长度超过网络的 MTU 而必须分片时，这个标识字段的值就被复制到所有的数据报的标识字段中。<font color="red">相同的标识字段的值使分片后的各数据报片最后能正确地重装成为原来的数据报</font></strong>。</p></li><li><p><strong>标志 3bit</strong> 目前只有2位有意义。标志字段中间的一位记为 DF (Don’t Fragment)，意思是“不能分片”。只有当DF=0时才允许分片，若为 1 则不分片。标志字段中的最低位记为 MF (More Fragment)。MF=1即表示后面“还有分片”的数据报。MF=0表示这已是若干数据报片中的最后一个。 </p></li><li><p><strong>片偏移 13bit</strong> 当一个较长的 IP 数据报在分片后，分片后的某一片的第一个 bit 在原分组中的相对位置。也就是说，相对传输层数据报的数据部分的起点，该片从何处截断的。片偏移以 8 个字节为偏移单位。这就表明，每个分片的长度也一定是 8 字节（ 64位 ）的整数倍。那为什么 ipv4 片偏移量以 8 字节位单位呢？如果直接用字节为单位，总长度是 16bit 而片偏移量只有 13 bit，就会出现不够描述的。 所以偏移量就按 8 字节为单位的来规定了。</p></li><li><p><strong>生存时间 8bit</strong> TTL( Time To Live ) 就是说 IP 数据报最大能经过多少个路由器跳转(每经过一个路由器，TTL减1)。<strong>防止数据报在网络中因为某些错误导致无限循环，浪费网络资源</strong>。那么可以知道，路由器在转发时会将这个字段的值减 1，并重新计算首部校验和。</p></li><li><p><strong>协议 8bit</strong> 标志此数据报携带的数据是使用协议类型( 例如TCP、UDP等 )，以便使目的主机的 IP 层知道应将数据部分上交给哪个处理过程。</p></li><li><p><strong>首部检验和</strong> <strong>16bit</strong> 注意这个字段只检验数据报的首部，不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算一下首部检验和（因为生存时间、标志、片偏移都可能发生变化，就是说在中间路由被重新分片时会出现变化。），不检验数据部分可减少计算量。</p></li><li><p><strong>源IP地址</strong>　占32位。</p></li><li><p><strong>目的IP地址</strong>　占32位。</p></li></ol><h2 id="DHCP"><a href="#DHCP" class="headerlink" title="DHCP"></a>DHCP</h2><p>​    我们自己电脑的IP地址有两种方式，第一种是直接设置一个固定的IP地址，需要配置一系列信息，比如子网掩码和DNS服务器地址等等；第二种是自动获取IP地址，这就是DHCP（动态主机配置协议）。通过本网络中的DHCP服务器发出请求，DHCP看看自己还有哪些IP地址没有分发出去，随机挑选一个给你用，返回给你的数据包中不仅包含了IP地址，还有子网掩码，默认网关地址以及DNS服务器地址。</p><p>​    DHCP的好处就是方便，以及节省资源，插上网线就能用，不用了之后，这个IP就给别人用。</p><h3 id="DHCP索要IP地址的流程"><a href="#DHCP索要IP地址的流程" class="headerlink" title="DHCP索要IP地址的流程"></a>DHCP索要IP地址的流程</h3><ol><li>想上网的设备要先在本网络中广播一个DHCP的报文，看谁回应，谁就就是DHCP服务器。这个过程称之为发现报文。</li><li>DHCP服务器在自己身体里找一个合适的IP地址，向全体广播提供一个<strong>提供报文</strong>。</li><li>上网的设备收到IP地址后会发一个请求报文，告诉DHCP服务器收到了IP地址。</li><li>随后DHCP服务器发送一个确认报文，并更新自己的数据库。</li></ol><p>​    这样做的原因是因为网络中可能有很多的DHCP服务器，这些服务器接收到了设备的DHCP报文，都会提供一个包含IP地址的报文，但是设备自己只能接收一个IP地址，所以要设备要发送一个请求报文来与告知其中某一个DHCP服务器“我用了你的IP”，这样这台DHCP服务器才会更新其数据库，其他的DHCP服务则会收回其分发的IP地址。</p><p>​    具体通信过程如下：</p><ol><li>DHCP服务其的默认端口是67</li><li>联网设备发送 DHCP 报文的默认端口是 68</li><li>发现报文：源 IP 0.0.0.0：68 目的 IP 255.255.255.255：67 双方都不知道彼此的 IP 地址 所以都是广播通信</li><li>提供报文：源 IP x.x.x.x：67 目的IP 255.255.255.255：67</li><li>下面就是再发一个请求报文和确认报文了</li></ol><h3 id="DHCP特点"><a href="#DHCP特点" class="headerlink" title="DHCP特点"></a>DHCP特点</h3><ol><li>在应用层实现，通过应用进程实现</li><li>使用 UDP</li><li>使用了 IP 广播</li></ol><h2 id="ICMP"><a href="#ICMP" class="headerlink" title="ICMP"></a>ICMP</h2><p>与 IP 息息相关。它的主要功能有差错报告和网络探测俩种。差错报告就是数据在网络中进行转发时，可能会出现一些错误，比如，数据报经过路由器时发现 TTL=0，那么路由器就会丢弃该报文，然后向发送端发送一个 ICMP 报文。而网络探测的功能，最常用的就是 ping 工具呢，这个 ping 工具基于的就是 ICMP 的回声请求应答报文，属于 ICMP 中的一种报文格式。具体的就不细说了。</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ol><li><a href="https://juejin.im/post/6844903518365564936#heading-11" target="_blank" rel="noopener">计算机网络知识解析</a></li><li><a href="https://github.com/CyC2018/CS-Notes" target="_blank" rel="noopener">CS-NOTE</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文旨在介绍计网的相关基础知识，只介绍到网络层之上&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;计算机网络概述&lt;/li&gt;
&lt;li&gt;应用层&lt;/li&gt;
&lt;li&gt;Socket&lt;/li&gt;
&lt;li&gt;传输层&lt;/li&gt;
&lt;li&gt;网络层&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="计算机网络基础" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Reids和Memcached对比</title>
    <link href="http://yoursite.com/2020/09/15/Reids%E5%92%8CMemcached/"/>
    <id>http://yoursite.com/2020/09/15/Reids%E5%92%8CMemcached/</id>
    <published>2020-09-15T03:19:09.000Z</published>
    <updated>2020-11-02T09:24:05.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Reids和Memcached对比"><a href="#Reids和Memcached对比" class="headerlink" title="Reids和Memcached对比"></a>Reids和Memcached对比</h1><blockquote><p>本文简单介绍了Redis和Memcached的区别</p></blockquote><a id="more"></a><h2 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h2><ol><li>数据类型<ul><li>Redis支持String、hash等5种类型</li><li>Memcached只支持hash</li></ul></li><li>单线程和多线程<ul><li>Redis是单线程请求，所有命令串行执行，并发情况下数据是一致的；但是性能受限于CPU，单实例的QPS在4-6w</li><li>Memcached是多线程，在单实例的情况下，可以达到写入60-80w qps，读80-100w</li></ul></li><li>持久化<ul><li>Redis支持持久化，使用AOF或者RDB</li><li>Memcached不支持持久化</li></ul></li><li>对热点、bigkey的支持<ul><li>QPS较高的情况下容易造成redis阻塞：单线程CPU饱和</li><li>memcached多线程，支持较好</li></ul></li><li>高可用/HA<ul><li>Redis哨兵模式master-slave，支持多级复制和增量复制</li><li>Memcached无法高可用</li></ul></li><li><b>发布订阅</b><ul><li>Redis支持pub/sub，可以用来订阅和通知</li><li>Memcached没有订阅</li></ul></li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Memcached可以提供更高的QPS，在请求量巨大的时候可以使用Memcached</li><li>Memcached无法持久化且可用性不高，在承载巨大的并发请求时，应采用多活结构来提高可用性</li><li>可以一台服务器部署多个Memcached实例，减少单实例的压力</li><li>大部分情况应使用Redis，毕竟Redis可用性高，支持持久化</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Reids和Memcached对比&quot;&gt;&lt;a href=&quot;#Reids和Memcached对比&quot; class=&quot;headerlink&quot; title=&quot;Reids和Memcached对比&quot;&gt;&lt;/a&gt;Reids和Memcached对比&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文简单介绍了Redis和Memcached的区别&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Redis" scheme="http://yoursite.com/tags/Redis/"/>
    
      <category term="Memcached" scheme="http://yoursite.com/tags/Memcached/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解:39,41,42</title>
    <link href="http://yoursite.com/2020/06/27/LeetCode%E9%A2%98%E8%A7%A3-39-41-42/"/>
    <id>http://yoursite.com/2020/06/27/LeetCode%E9%A2%98%E8%A7%A3-39-41-42/</id>
    <published>2020-06-27T10:31:15.000Z</published>
    <updated>2020-06-27T13:45:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><blockquote><p>第39题：<a href="https://leetcode-cn.com/problems/combination-sum/" target="_blank" rel="noopener">组合总和(中等)</a></p><p>第41题：<a href="https://leetcode-cn.com/problems/first-missing-positive/" target="_blank" rel="noopener">缺失的第一个正数(困难)</a></p><p>第42题：<a href="https://leetcode-cn.com/problems/trapping-rain-water/" target="_blank" rel="noopener">接雨水(困难)</a></p><p>补充：个人项的题解，没有图解，没有视频。</p></blockquote><a id="more"></a><hr><h1 id="第39题：组合总和"><a href="#第39题：组合总和" class="headerlink" title=" 第39题：组合总和 "></a><font color="red"> 第39题：组合总和 </font></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定一个无重复元素的数组<code>candidates</code> 和一个目标数<code>target</code> ，找出<code>candidates</code> 中所有可以使数字和为<code>target</code>的组合。<code>candidates</code> 中的数字可以无限制重复被选取。数组中所有元素都是正数，解集不能重复。</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates &#x3D; [2,3,6,7], target &#x3D; 7,</span><br><span class="line">所求解集为:</span><br><span class="line">[</span><br><span class="line">  [7],</span><br><span class="line">  [2,2,3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>这种题型，只有回溯这一种解法，涉及到回溯，所谓回溯，就是稍微有一点技巧的穷举法，穷举法一般意味着高空间利用率和时间利用率，因此只要涉及到回溯，就要考虑剪枝。其次，遇到无序数组，如果题目没有要求时间复杂度必须在O(n)，一般情况下都可以去排序，而本题在排序后可以达到剪枝的效果。</p><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; combinationSum(<span class="keyword">int</span>[] candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        Arrays.sort(candidates);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        dfs(candidates, target, ans, <span class="keyword">new</span> ArrayDeque&lt;Integer&gt;(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[] candidates, </span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> target, </span></span></span><br><span class="line"><span class="function"><span class="params">                    List&lt;List&lt;Integer&gt;&gt; ans, </span></span></span><br><span class="line"><span class="function"><span class="params">                    Deque&lt;Integer&gt; path,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span> begin)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">0</span>)&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> ArrayList&lt;&gt;(path));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = begin; i &lt; candidates.length; i++)&#123;</span><br><span class="line">          <span class="comment">// 这一步是剪枝操作，很好理解</span></span><br><span class="line">            <span class="keyword">if</span>(candidates[i] &gt; target) <span class="keyword">return</span>;</span><br><span class="line">            path.addLast(candidates[i]);</span><br><span class="line">            dfs(candidates, target - candidates[i], ans, path, i);</span><br><span class="line">            path.removeLast();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="第41题：缺失的第一个正数"><a href="#第41题：缺失的第一个正数" class="headerlink" title=" 第41题：缺失的第一个正数 "></a><font color="red"> 第41题：缺失的第一个正数 </font></h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给你一个未排序的整数数组，请你找出其中没有出现的最小的正整数。</p><blockquote><p>时间复杂度: $O(n)$</p><p>空间复杂度: $O(1)$</p></blockquote><h3 id="说明-1"><a href="#说明-1" class="headerlink" title="说明"></a>说明</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: [1,2,0]</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><ol><li>时间复杂度O(n)：只能进行遍历的操作</li><li>空间复杂度O(1)：所有操作必须是原地的</li></ol><p>这两点带来的局限性，导致了本题必须要抓住一个关键点：<strong>一个长度为n的数组nums，其序列中如果没有缺失的正数，则$nums[i] == i$</strong>，也就是说，如果在这个数组的<code>idx</code>位置其值不是<code>idx+1</code>，则这个位置的数就是缺失的。因此，这道题的解题思路就确定了：使数组<code>idx</code>位置的值可判断，不一定非要$nums[idx] == idx + 1$，也可以使<code>idx</code>位置的值为负(<a href="https://leetcode-cn.com/problems/first-missing-positive/solution/que-shi-de-di-yi-ge-zheng-shu-by-leetcode-solution/" target="_blank" rel="noopener">题解</a>) 。本题将$nums[idx] == idx +１$。</p><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstMissingPositive</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            exchange(nums, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] != i+<span class="number">1</span>) <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[nums.length - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> num)</span></span>&#123;</span><br><span class="line">      <span class="comment">// 递归出口：位置上的值是正确的值，或者超出了范围</span></span><br><span class="line">        <span class="keyword">if</span>(num &lt;= <span class="number">0</span> || num &gt; nums.length || nums[num - <span class="number">1</span>] == num) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[num - <span class="number">1</span>];</span><br><span class="line">            nums[num - <span class="number">1</span>] = num;</span><br><span class="line">            exchange(nums, temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="第42题：接雨水"><a href="#第42题：接雨水" class="headerlink" title=" 第42题：接雨水 "></a><font color="red"> 第42题：接雨水 </font></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给定 <em>n</em> 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</p><p><img src="/2020/06/27/LeetCode%E9%A2%98%E8%A7%A3-39-41-42/getRain.png" alt="接雨水示意图"></p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>这题比较难，我的第一反应特别蠢：从底向上一层层遍历，看每一层最多能接收多少雨水。这样的时间复杂度是$O(MN)$，LC直接通过不了。实际上这道题是有好的思路的，核心想法就是：<strong>确定每个<code>idx</code>位置上能装多少雨水。</strong>而每个<code>idx</code>上装雨水的量，取决于在这个位置左右两端最高的那堵墙，因此如果我们知道每个位置上左右两端的最高位置，则可以完成计算：$res = Math.min(leftMax[idx], rightMax[idx]) - height[idx]$</p><h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.length, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">0</span> || len == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span>[] leftMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        leftMax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span>[] rightMax = <span class="keyword">new</span> <span class="keyword">int</span>[len];</span><br><span class="line">        rightMax[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len; i++)&#123;</span><br><span class="line">            leftMax[i] = Math.max(leftMax[i - <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 这一步有点技巧，确定右边最大的值需要从右到左遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = len - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">            rightMax[i] = Math.max(rightMax[i + <span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)&#123;</span><br><span class="line">            ans += Math.min(leftMax[i], rightMax[i]) - height[i]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>时间复杂度：$O(n)$，只进行了遍历操作</li><li>空间复杂度：$O(n)$，保存了每个<code>idx</code>位置左右两端的最大值</li></ul><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>这道题其实还有更好的解法：<a href="https://leetcode-cn.com/problems/trapping-rain-water/solution/jie-yu-shui-by-leetcode/" target="_blank" rel="noopener">双指针法</a>，空间复杂度降到了$O(1)$，这种方法特别巧妙，利用了从左到右和从右到左两种不同的状态来计算在<code>idx</code>位置上可以存的雨水。但是这种方法在面试时是很难想出来的，因此这里就不赘述了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目名称&quot;&gt;&lt;a href=&quot;#题目名称&quot; class=&quot;headerlink&quot; title=&quot;题目名称&quot;&gt;&lt;/a&gt;题目名称&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;第39题：&lt;a href=&quot;https://leetcode-cn.com/problems/combination-sum/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;组合总和(中等)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第41题：&lt;a href=&quot;https://leetcode-cn.com/problems/first-missing-positive/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;缺失的第一个正数(困难)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;第42题：&lt;a href=&quot;https://leetcode-cn.com/problems/trapping-rain-water/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;接雨水(困难)&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;补充：个人项的题解，没有图解，没有视频。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Integer</title>
    <link href="http://yoursite.com/2020/03/13/%E6%B5%85%E8%B0%88Integer/"/>
    <id>http://yoursite.com/2020/03/13/%E6%B5%85%E8%B0%88Integer/</id>
    <published>2020-03-13T12:55:58.000Z</published>
    <updated>2020-03-13T14:47:32.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本博客主要涉及以下几个内容：</p><ol><li>装箱与拆箱</li><li>装箱生成的Integer在哪里</li><li>案例</li></ol></blockquote><a id="more"></a><h1 id="装箱与拆箱"><a href="#装箱与拆箱" class="headerlink" title="装箱与拆箱"></a>装箱与拆箱</h1><p>　　Java中有八种基本数据类型: byte, short, int, long, float, double, char, boolean。这八种基本数据类型对应着八个包装类，<strong>基本数据类型</strong>转换为<strong>包装类</strong>叫做装箱，反之叫做拆箱。</p><h2 id="为什么要进行装箱和拆箱？"><a href="#为什么要进行装箱和拆箱？" class="headerlink" title="为什么要进行装箱和拆箱？"></a>为什么要进行装箱和拆箱？</h2><p>　　Java中最主要有三类存储空间: 栈，堆，方法区。栈中存基本数据类型和堆中对象的引用；堆中一般存放运行时的动态数据，最主要有<code>new</code>出来的对象;方法区中存储的数据不是本文的重点，就不细说了，本文只涉及方法区中的常量池，常量池中存储的是常量。<br>　　基本数据类型因为经常被使用，所以为了提高效率，都放在栈中进行运算；但是栈中的数据并不具备持久性，对于Java中同样经常使用的容器，栈中的数据显然不具备放入容器中的资格，因此才有了装箱和拆箱的步骤。JDK5后，Java实现了自动装箱和拆箱。</p><h2 id="如何进行装箱和拆箱"><a href="#如何进行装箱和拆箱" class="headerlink" title="如何进行装箱和拆箱"></a>如何进行装箱和拆箱</h2><p>　　这里不放java反编译后的结果了，直接说结论。只给出<code>int</code>和<code>Integer</code>之间的转换。</p><ul><li>代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer in = <span class="number">9</span>; <span class="comment">//装箱</span></span><br><span class="line"><span class="keyword">int</span> i = in; <span class="comment">//拆箱</span></span><br></pre></td></tr></table></figure><ul><li>装箱调用：<code>Integer in = Integer.valueOf(9)</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>拆箱调用：<code>int i = in.intValue()</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">intValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="装箱生成的Integer去了哪里？"><a href="#装箱生成的Integer去了哪里？" class="headerlink" title="装箱生成的Integer去了哪里？"></a>装箱生成的Integer去了哪里？</h1><p>　　上面的源码引出了一个新的类<code>IntegerCache</code>, 这个类是<code>Integer</code>类的静态内部类，内部存在三个常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br></pre></td></tr></table></figure><p>　　常量<code>high</code>会在类中的静态代码块中被赋值为<code>127</code>，<code>cache[]</code>中存储了<code>value</code>为<code>-128 ~ 127</code>的<code>Integer</code>包装类。<br>　　由源码可知：当装箱的<code>int</code>值在<code>-128 ~ 127</code>中时，<code>Integer</code>会直接返回常量池中的对象，而这些对象，在<code>Integer</code>类加载的时候就被创建了，因此不会再开辟多余的空间。而当<code>int</code>的值超过范围，则会在堆中重新开辟<code>Integer</code>对象的空间。</p><h1 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">99</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">128</span>;</span><br><span class="line">Integer A = a;</span><br><span class="line">Integer AA = <span class="number">99</span>;</span><br><span class="line">Integer B = b;</span><br><span class="line">Integer BB = <span class="number">128</span>;</span><br><span class="line">System.out.println(AA == A); <span class="comment">// true</span></span><br><span class="line">System.out.println(BB == B); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>解释：</p><ol><li><code>A</code>和<code>AA</code>都指向常量池中的<code>Integer</code>对象</li><li><code>B</code>和<code>BB</code>都是在执行装箱操作后<code>new</code>出来的<code>Integer</code>对象，因此地址不同</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本博客主要涉及以下几个内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;装箱与拆箱&lt;/li&gt;
&lt;li&gt;装箱生成的Integer在哪里&lt;/li&gt;
&lt;li&gt;案例&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode题解(一):10, 15, 57, 59</title>
    <link href="http://yoursite.com/2020/03/07/LeetCode%E9%A2%98%E8%A7%A3-%E4%B8%80-10-15-57-59/"/>
    <id>http://yoursite.com/2020/03/07/LeetCode%E9%A2%98%E8%A7%A3-%E4%B8%80-10-15-57-59/</id>
    <published>2020-03-07T12:30:14.000Z</published>
    <updated>2020-03-08T03:48:21.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><blockquote><p>第10题：正则表达式匹配(困难)<br>第15题：三数之和(中等)<br>第57题：和为s的连续正数序列(简单)<br>第59题：II.队列的最大值(中等)</p></blockquote><a id="more"></a><hr><h1 id="第10题：正则表达式匹配"><a href="#第10题：正则表达式匹配" class="headerlink" title="第10题：正则表达式匹配"></a><font color="red">第10题：正则表达式匹配</font></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 <code>&#39;.&#39;</code>和 <code>&#39;*&#39;</code>的正则表达式匹配。</p><blockquote><p><code>&#39;.&#39;</code>匹配任意单个字符<br><code>&#39;*&#39;</code>匹配零个或多个前面的那个元素</p></blockquote><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>s 可能为空，且只包含从 a-z 的小写字母</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符<code>&#39;.&#39;</code>和 <code>&#39;*&#39;</code></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　见到字符串匹配，字符串操作的题，第一反应就是DP。而且DP数组中的下标如<code>i</code>一般都代表匹配字符串的<code>0: i - 1</code>或者<code>i: len - 1</code>。<br>　　很显然，这道题可以用DP求解，<code>dp[i][j]</code>表示<code>p[0: j-1]</code>可以和<code>s[0: i - 1]</code>匹配。</p><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><ul><li><code>dp[0][0] = true</code>: 因为<code>null</code>匹配<code>null</code></li><li><code>dp[0&lt; i &lt;= slen][0] = false</code>: p为<code>null</code>， 无法匹配任何值</li><li><code>dp[0][0&lt; j＜= plen]</code>: 这个初始化稍微复杂一点，因为例如<code>a*</code>或者<code>a*b*</code>这种都是可以匹配<code>null</code>的，因此我们用一个循环来初始化这种状态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>　　这题最难的地方在状态转移方程的求解，即如何求得<code>dp[i][j]</code>？</p><ol><li>第一种情况: <code>s[i - 1] == p[j - 1] ||　ｐ[j - 1] == &#39;.&#39;</code>，此时<code>dp[i][j] = dp[i - 1][j - 1]</code></li><li>第二种情况: <code>p[j - 1] == &#39;*&#39;</code>，分别有两种可能需要考虑: <ul><li><code>s[i - 1] == p[j - 2] || p[j - 2] == &#39;.&#39;</code>，此时又有三种情况，只要一种成立即可:<ul><li><code>*</code> 匹配0次: <code>dp[i][j] = dp[i][j - 2]</code>, 因为匹配0次的话，<code>p[0: j]</code>的作用等同于<code>p[0: j - 2]</code></li><li><code>*</code> 匹配1次: <code>dp[i][j] = dp[i][j - 1]</code>, 这个很容易理解</li><li><code>*</code> 匹配多次: <code>dp[i][j] = dp[i - 1][j]</code>, 这是最难理解的，因为如果<code>*</code>匹配了多次，则s字符串增加一个与<code>p[j - 2]</code>相同的数并无影响</li></ul></li><li><code>s[i - 1] != p[j - 2] || p[j - 2] != &#39;.&#39;</code>，此时只可能有一种情况:<ul><li><code>*</code> 只能匹配0次: <code>dp[i][j] = dp[i][j - 2]</code></li></ul></li></ul></li><li>其他情况: <code>dp[i][j] = false</code></li></ol><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slen = s.length(), plen = p.length();</span><br><span class="line">        <span class="comment">// dq[i][j] means p[0 : j] matches s[0 : i]</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[slen + <span class="number">1</span>][plen + <span class="number">1</span>]; </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= slen; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'.'</span>)</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p.charAt(j - <span class="number">2</span>) == <span class="string">'.'</span> || p.charAt(j - <span class="number">2</span>) == s.charAt(i - <span class="number">1</span>))&#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">2</span>] || dp[i][j - <span class="number">1</span>]; </span><br><span class="line">                    &#125;<span class="keyword">else</span> dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[slen][plen];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: <script type="math/tex">O(MN)</script> </li><li>空间复杂度: <script type="math/tex">O(MN)</script></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>　　本题还可以用回溯法做，但是笔者特别讨厌用递归，虽然递归用起来很简洁，但是空间利用率实在是太感人了，计算起来也十分麻烦。笔者曾经用递归写过一个项目的方法，出现堆栈溢出问题的时候简直崩溃，因此立下flag：能不用递归就不用递归。因此回溯的算法就不写了。<br><strong>回溯法思路：</strong></p><ul><li>首字符匹配，且p的后一字符不是<code>*</code> : 匹配<code>(s.substring(1), p.substring(1))</code></li><li>首字符匹配，且p的后一字符是<code>*</code> : 匹配<code>(s, p.substring(2)) ||　(ｓ.substring(1), p)</code></li><li>首字符不匹配，且p的后一字符是<code>*</code> : 匹配<code>(s, p.substring(2))</code></li><li>递归出口:  <ul><li>首字符不匹配，且p的后一字符不是<code>*</code> : <code>return false</code></li><li>p为空: <code>return s为空</code></li><li>这里注意一下，s为空并不作为出口，而作为(首字符不匹配)的情况</li></ul></li></ul><h3 id="遇到过的问题"><a href="#遇到过的问题" class="headerlink" title="遇到过的问题"></a>遇到过的问题</h3><ul><li>将<code>*</code>看成了匹配零次或无数次任意字符，导致直接做错</li><li>匹配多次的方程没想出来</li></ul><hr><p>　</p><h1 id="第15题：三数之和"><a href="#第15题：三数之和" class="headerlink" title="第15题：三数之和"></a><font color="red">第15题：三数之和</font></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意:</strong> 答案中不可以包含重复的三元组。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　这道题最主要的就是要想到用双指针的方法去求解twoSum，想到了就很简单。写博客的时候不小心写上了，改名字有点费事，所以就贴个代码上去。暴力求解这种基本谁都能想到，但是如果用暴力去做算法题的话，就失去了做算法题的意义，不是吗？</p><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// O(nlgn)</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// O(n^2)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[i], left = i+<span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">int</span> twoSum = nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(twoSum == target)&#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="keyword">while</span>(left + <span class="number">1</span> &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(right - <span class="number">1</span> &gt; i + <span class="number">1</span> &amp;&amp; nums[right] == nums[right-<span class="number">1</span>]) right--;</span><br><span class="line">                    left++;right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(twoSum &gt; target) right--;</span><br><span class="line">                <span class="keyword">else</span> left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: <script type="math/tex">O(N^2)</script></li><li>空间复杂度: <script type="math/tex">O(1)</script></li></ul><hr><h1 id="第57题-和为s的连续正数序列"><a href="#第57题-和为s的连续正数序列" class="headerlink" title="第57题: 和为s的连续正数序列"></a><font color="red">第57题: 和为s的连续正数序列</font></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　这道题比较简单，采用滑动窗口法进行计算即可。笔者不擅长解答除了找规律外的数学问题，所以数学解法就不考虑了。数学解法固然巧妙，但是我为了找工作而刷题，就不需要整这些花里胡哨的了，只需要保证时间空间复杂度尽可能少一些就ok。</p><h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">2</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>) ans.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; right &lt;= target / <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (left + right) * (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++) temp[i - left] = i;</span><br><span class="line">                ans.add(temp);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) left++;</span><br><span class="line">            <span class="keyword">else</span> right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>[][]) ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: <script type="math/tex">O(N)</script></li><li>空间复杂度: <script type="math/tex">O(N)</script>: 使用了一个数组来临时存储序列</li></ul><h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><p>　　这道题很简单，但是笔者一开始并没有想到用滑动窗口法去解决问题，我第一反应是先固定左端的数，然后用二分查找的算法去找右边的数。算法是没错的，时间复杂度<code>O(NlgN)</code>也算马马虎虎，但是死活提交不过。后来Debug才发现，原来是计算的<code>sum</code>越界了，<code>int</code>最大能取到<font color="brown">$ 2^{31} - 1 = 2147483647 = 0x7fffffff $</font>, 如果再加1，就会变最小负值，然后就一直是负数了，除非再加一次最大值。随便举个例子: 计算<code>1, 2, 3,..., 8000000</code>就越界了。</p><hr><h1 id="第59题：II-队列的最大值"><a href="#第59题：II-队列的最大值" class="headerlink" title="第59题：II.队列的最大值"></a><font color="red">第59题：II.队列的最大值</font></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　这道题卡了我很久，原因是我忽略了<strong>均摊时间复杂度的含义</strong>: 进行N次操作，其每次操作的平均复杂度为O(1)。<br>　　要解决这道题有两个很重要的点: </p><ol><li>只要插入了一个最大值，在前面的值<code>pop_front</code>前，这个最大值就不会改变。</li><li>如何保证最大值被<code>pop</code>掉后，我们可以找到次大值？: 只需要将正常入队的序列进行某些操作后保存为一个<strong>非递增的辅助序列</strong>即可。<ul><li>解释：假设我们有序列<code>xAyBzC</code>，其中<code>A &gt; x; B &gt; y; C &gt; z; A &gt; B &gt; C</code>，那么辅助序列<code>ABC</code>就是在进行<code>max_value()</code>操作中只可能出现的三个最大值，因为有了<code>A</code>，前面的<code>x</code>就失去了价值，而<code>A</code>一旦被<code>pop</code>后，<code>A</code>前面的数就不会在序列里了，子序列<code>yBzC</code>中最大的就是<code>B</code>，以此类推。因此这是一个线性问题。</li></ul></li></ol><h2 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; aux;</span><br><span class="line">    Deque&lt;Integer&gt; dq;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aux = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.dq = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aux.size() == <span class="number">0</span> ? -<span class="number">1</span> : aux.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        dq.addLast(value);</span><br><span class="line">        <span class="keyword">while</span>(aux.peekLast() != <span class="keyword">null</span> &amp;&amp; aux.peekLast() &lt; value) aux.pollLast();</span><br><span class="line">        aux.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dq.size() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Integer 没进入常量池，不能用 == 来判断</span></span><br><span class="line">        <span class="keyword">if</span>(dq.peek().equals(aux.peek())) aux.pollFirst();</span><br><span class="line">        <span class="keyword">return</span> dq.pollFirst();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="踩过的坑-1"><a href="#踩过的坑-1" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><ol><li>没理解均摊复杂度</li><li>没想到用非递增的辅助序列</li><li>两个没有拆箱的<code>Integer</code>对象，不能用<code>==</code>来判断其<code>value</code>是否相等。(基于这点，笔者想要写一篇文章来详细解析一下这种包装类，届时会放链接)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目名称&quot;&gt;&lt;a href=&quot;#题目名称&quot; class=&quot;headerlink&quot; title=&quot;题目名称&quot;&gt;&lt;/a&gt;题目名称&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;第10题：正则表达式匹配(困难)&lt;br&gt;第15题：三数之和(中等)&lt;br&gt;第57题：和为s的连续正数序列(简单)&lt;br&gt;第59题：II.队列的最大值(中等)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java中的HashMap以及红黑树</title>
    <link href="http://yoursite.com/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://yoursite.com/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2019-12-15T13:21:42.000Z</published>
    <updated>2020-03-07T12:06:59.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇博客涉及以下几个内容：</p><ol><li>HashMap的部分源码讲解</li><li>红黑树的数据结构</li></ol></blockquote><a id="more"></a><h1 id="HashMap的结构和源码"><a href="#HashMap的结构和源码" class="headerlink" title="HashMap的结构和源码"></a>HashMap的结构和源码</h1><p>　Java中集合一共可以分为两类，一类是Collection，代表是ArrayList；一类是Map，代表是HashMap。而HashMap存储结构是<strong>哈希表</strong>。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>　哈希表的本质是一个数组，但是性能比数组高很多，因为动态数组的插入和删除操作对应的时间复杂度是O(n)，而哈希表的增删改查操作时间复杂度均为O(1)。<br>　为什么快？<br>　哈希表利用函数映射的方式来将数据映射到其维护的数组上，这样执行增删改查操作时只需要通过这个函数就能找到数组的下标，从而实现快速定位。相比数组的顺序存储，哈希表是无序的，因此在执行删除操作时，并不需要移动其他下标的元素。<strong>用来执行元素映射的函数叫做哈希函数：hashcode()。</strong><br>　存储方式如下图：<br>  <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/hashtable.png" alt="哈希表"></p><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>　由上述的存储方式可知，<strong>如果两个不同元素通过哈希函数的值相同，则单纯用数组存储就会有冲突。</strong>这种方法最直接的解决办法就是设计优秀的哈希函数，把冲突的可能性降至最低，但是再优秀的哈希函数，都会有可能发生冲突。因此，需要有一种方法来解决冲突问题。<br>　常见的方法有：</p><ol><li>线性探测法，发生冲突后顺序找下一块空的地址。（运气差的话增删改查都会变O(n)）</li><li>对冲突的地址使用另一个Hash函数</li><li>链地址法：数组的每个位置都存一个链表。（运气差的话，查找会变O(n)）</li></ol><p>　HashMap解决冲突的办法就是<strong>链地址法</strong>，数组的每个位置我们称之为桶。如果运气不好的话，所有的数字都在一个桶里，那么查找一个链表的时间复杂度是O(n)，这很低效。<strong>所以JDK8之后，当一个桶里存放的元素超过8个时，则这个桶里会自动变成红黑树，这样查找的效率就成了O(logn)。</strong></p><h2 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h2><h3 id="HashMap主干数组"><a href="#HashMap主干数组" class="headerlink" title="HashMap主干数组"></a>HashMap主干数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是HashMap内部维护的一个数组，这个数组初始值为空，主干长度是2的次幂</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p><code>Node&lt;K,V&gt;</code>是HashMap的一个静态内部类(<strong>使用静态内部类是为了方便继承，TreeNode就继承了这个Node类</strong>)，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map.Entry是一个接口</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//此Node的hash值</span></span><br><span class="line">       <span class="keyword">final</span> K key; <span class="comment">// 此Node的key</span></span><br><span class="line">       V value; <span class="comment">// 此Node的value</span></span><br><span class="line">       Node&lt;K,V&gt; next; <span class="comment">//指向下一个Node</span></span><br><span class="line">       </span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line"> <span class="comment">/* ------- 以上是重点 ---------*/</span>      </span><br><span class="line"> <span class="comment">// get,set,toString,hashcode,equels</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　其存储结构如下图：<br><img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/hashmapNode.png" alt="Node存储结构"></p><p>　当数组中某个桶存储的元素超过一定的数量后(默认是8个)，则Node会被转化为TreeNode进行存储，TreeNode继承自<code>LinkedHashMap.Entry&lt;K,V&gt;</code>，关于<code>LinkedHashMap</code>可以移步我的博客：<a href>浅谈Java中LinkedHashMap</a>，<code>TreeNode</code>的解析将在下文的红黑树种讲解。</p><h3 id="几个重要字段"><a href="#几个重要字段" class="headerlink" title="几个重要字段"></a>几个重要字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认字段值：</span></span><br><span class="line"><span class="comment">//1.数组的默认初始容量是16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//2.数组的最大容量为2的30次方(int最大是 2^31-1)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//3.当数组中存储的值超过目前容量的75%，执行数组的扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//4.当数组中一个桶存储的元素超过8个时，list将会转化为tree</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//5.红黑树的最小容量为64</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//6.执行扩容操作时会将小于元素小于6的数还原</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重要字段：</span></span><br><span class="line"><span class="comment">//1.HashMap中实际存储的'key-value'数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//2.数组负载因子，默认是75%</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//3.数组存储阈值，如果key-value的数量大于该阈值，则进行数组扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">/** 4.被修改次数，由于HashMap线程不安全，如果对HashMap进行迭代的时候，其他线程改变了HashMap的结构(增、删、改)，则就会抛出ConcurrentModificationException异常 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><h3 id="HashMap构造器"><a href="#HashMap构造器" class="headerlink" title="HashMap构造器"></a>HashMap构造器</h3><p>　HashMap一共四种初始化的方式</p><ul><li>我们最常用的构造器是无参构造器：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个构造器不初始化table，为table分配空间会在内部的resize()函数中进行，下文会讲。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>HashMap也可以指定容量和负载因子进行初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span>+</span><br><span class="line">                                               loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//此步将initalCapacity规范成2的次幂</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>剩余两种构造器比较容易</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个不讲了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过一个Map实例化HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">//相当于一个拷贝工作，这个false我目前不是很理解，如果为true的话，在内部会执行afterNodeInserction函数，但是我看这个函数是空的，所以不是很理解。</span></span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put函数"><a href="#put函数" class="headerlink" title="put函数"></a>put函数</h3><p>　上面我们看到，如果使用缺省的构造器，我们是不会初始化table的，而真正初始化table需要等到我们第一次使用put操作。这是一种懒加载的机制，用来节约内存资源。<br>　以下是源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*定义一个数组tab，一个链表p表示桶里的链表情况，n表示数组长度，i表示key在数组中的索引*/</span></span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">      <span class="comment">/*如果table没有初始化，则resize()，下文会讲*/</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line">      <span class="comment">/*如果key所在桶里为空，则为这个key-value新建一个Node存放*/</span></span><br><span class="line">      <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*如果桶里不为空，则新建一个节点e用来寻找新插入或者修改的Node的位置*/</span></span><br><span class="line">          Node&lt;K,V&gt; e; K k;</span><br><span class="line">          <span class="comment">/*如果key相等，则不插入新节点，e指向要修改val的位置*/</span></span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              e = p;</span><br><span class="line">          <span class="comment">/*如果桶里是红黑树，则执行红黑树的插入操作*/</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">              e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">/*若桶里只是链表，则遍历这个链表*/</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">              <span class="comment">/*在表尾插入新的节点*/</span></span><br><span class="line">                  <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                      <span class="comment">/*如果链表的长度大于阈值，将链表转换成红黑树*/</span></span><br><span class="line">                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                          treeifyBin(tab, hash);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">/*若在遍历链表时，发现有Node的key与插入的key相等，则退出遍历*/</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  <span class="comment">/*p指向的Node沿着链表一直向后*/</span></span><br><span class="line">                  p = e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/*如果e不为null，则e指向要修改val的Node*/</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">              V oldValue = e.value;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                  e.value = value;</span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*新插入节点后增加HashMap的修改次数，*/</span></span><br><span class="line">      ++modCount;</span><br><span class="line">      <span class="comment">/*key-value的数量大于阈值后对数组进行扩容*/</span></span><br><span class="line">      <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">          resize();</span><br><span class="line">      afterNodeInsertion(evict);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>　我看了一下网上的流程图都不是很准确，我这里用文字表示一下，最近实在是太累了，等我写LinkedHashMap的时候把图补上。<br>　<strong>HashMap中put的流程如下：</strong></p><ol><li>判断table是否为空，为空则进行resize()初始化table</li><li>计算插入的Key的在table中的索引i</li><li>若table[i]中没有值，则新建一个Node插入该位置</li><li>若有值，则判断插入的key是否与table[i]中首节点的key相等，若相等则直接替换val</li><li>若key不等，则判断table[i]存放的是否为红黑树，若为红黑树，则进行红黑树的插入操作<ol><li>红黑树中也会进行key值的比较，若相等则直接修改val，若不等则插入新节点</li></ol></li><li>若table[i]中存放的是链表，则遍历链表<ol><li>若遍历过程中发现有key相等，则直接替换</li><li>若遍历到链表的结尾，则在结尾插入新的Node<ol><li>若此时table[i]内存放的元素大于8，则将链表转化成红黑树，并对红黑树进行扩容</li></ol></li></ol></li><li>插入成功后，若数组中存放的key-value数值大于数组阈值后，则进行resize()扩容操作。</li></ol><h3 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h3><p>　有put就有get，这是HashMap最常用的两个函数，其主要的难点在于红黑树的查找，这在下文会讲。<br>　以下是源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt; e;</span><br><span class="line">     <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line"> <span class="comment">/*定义数组，链表和待查找的节点，n表示数组的长度，k表示遍历节点的key*/</span></span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">     <span class="comment">/*若不满足查找条件比如数组不存在，桶里没值，返回null*/</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">/*检查第一个节点，若想等则返回*/</span></span><br><span class="line">         <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">             ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             <span class="keyword">return</span> first;</span><br><span class="line">         <span class="comment">/*若不等，则看其下一个有没有值，没有则返回null，TreeNode继承的爷爷辈是Node，因此可以调用父类对象的next，即使其已经是TreeNode了*/</span></span><br><span class="line">         <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">/*若有值则寻找，红黑树查找或列表遍历*/</span></span><br><span class="line">             <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                 <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">return</span> e;</span><br><span class="line">             &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h3><p>　最后一项删操作，如果增和查的操作都了解的话，删操作也就通俗易懂。其大体的思路就是：查到需要删除的节点，然后执行红黑树的删除或者链表的删除。<br>　源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.remove and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to match if matchValue, else ignored</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue if true only remove if value is equal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*定义一个数组，一个链表，n表示数组的长度，index表示要删除的数组索引位置*/</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">/*table为空或者桶内没有数据，无法执行删除，返回null*/</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*找到要删除的节点，用node指向它*/</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*删除node*/</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resize函数"><a href="#resize函数" class="headerlink" title="resize函数"></a>resize函数</h3><p>　在我们进行HashMap操作的时候会经常会有扩容的需求，因此了解扩容的机制十分重要。<br>　源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*此方法不能被重写*/</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">   <span class="comment">/*保存旧的table，并保存旧的阈值和容量*/</span></span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">/*若超过最大容量，则将阈值设置成2^31-1*/</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">/*若当前容量在最小值和最大值之间，则把新容量和新阈值扩大一倍*/</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*若阈值不为0，但数组容量为0，将容量扩展成阈值大小*/</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="comment">/*第一次初始化table，设置容量为16，阈值为16*0.75*/</span></span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*通过新容量设置新阈值，如果新容量比最大容量小，则为'新容量*负载因子' */</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="comment">/*执行扩容，对里面每个元素进行重新排放*/</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="红黑树讲解"><a href="#红黑树讲解" class="headerlink" title="红黑树讲解"></a>红黑树讲解</h1><p>　JDK8之后，HashMap引入了红黑树，红黑树是一种自平衡二叉查找树。本节将通过数据《算法》和HashMap的部分源码来解析红黑树的结构。</p><h2 id="2-3平衡树"><a href="#2-3平衡树" class="headerlink" title="2-3平衡树"></a>2-3平衡树</h2><p>　理解红黑树的平衡是一件比较抽象的事情，很多博客并不讲红黑树是如何实现平衡的。本文通过2-3平衡树来讲解一下”平衡”的概念。</p><h3 id="完美平衡"><a href="#完美平衡" class="headerlink" title="完美平衡"></a>完美平衡</h3><p>　完美平衡是指，所有空结点到根结点的的距离相等，比如下图就是一个完美平衡的二叉树:<br><img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/BinaryTree.png" alt="完美平衡树"><br>　很明显可以看出来，如果一颗普通的二叉树要达到完美平衡，其对于结点的数量是有要求的: $ n  = 2^{k} - 1  $ , 如果结点数量不满足这个等式, 那么一颗二叉树始终不可能是平衡的。<br>　<font color="red"><strong>那么如何使一棵树不管有几个结点都能保持平衡呢?</strong></font><br>　这里设想一下, 左右子树在最理想的情况下高度差是多少? 答案很明显是1, 因为任意数都可以在$ 2^{k} $和$ 2^{k+1} $之间。因此如果我们把高的子树的高度减一, 那么这棵树就实现了完美平衡。</p><h3 id="2-3树的基本结构"><a href="#2-3树的基本结构" class="headerlink" title="2-3树的基本结构"></a>2-3树的基本结构</h3><p>　如何实现高度减一呢? 有一个特别简单的办法, 那就是新定义一个结点:3-结点。我们将普通二叉树的结点定义为：2-结点。2-结点存储一个key，并且有左右两个子树; 3-结点存储两个key, 并且有左中右三个子树。2-3树就是由2-结点和3-结点组成的树, 二叉树也是2-3树的一种。下面是一个2-3树示例:<br><img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/2-3Tree.png" alt="2-3平衡树"></p><h3 id="实现完美平衡"><a href="#实现完美平衡" class="headerlink" title="实现完美平衡"></a>实现完美平衡</h3><p>　2-3树可以始终保持完美平衡, 因为在2-3树中插入新值不会破坏其平衡性, 下面我们仔细讲一讲如何实现2-3树的插入操作。<br>　一个树在第一次生成的时候一定是平衡的, 因为只有一个2-结点, 当我们在一个平衡的树的底部插入新结点的时候会破坏其平衡性。因此, 我们在讲解2-3树的插入操作前, 必须有一个前提: <strong>2-3树在插入前是平衡的</strong>。<br>　当我们插入一个新结点时，会遇到以下的几种情况: </p><ul><li>在一个2-结点的底部插入新键: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/insert1.png" alt="2-结点插入"></li><li>在一个没有父节点的3-结点底部插入新键: 临时构建一个4-结点。<img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/insert2.png" alt="3-结点插入"></li><li>在一个父节点是2-结点的3-结点底部插入新键: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/insert3.png" alt="3-结点插入2"></li><li>在一个父节点是3-结点的3-结点底部插入新键: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/insert4.png" alt="3-结点插入3"> </li></ul><p>　可以看到, 2-3树之所以能保持平衡性, 是因为其在插入的过程中, 不会在底部增加高度, 而是自下而上去寻找一个2-结点能够吸收这个高度变化, 如果没有寻找到这个2-结点, 则会通过把遇到的3-结点创建为临时4-结点并分解的方式使左右子树的高度均增加1, 以保证树的平衡。(这里稍微再说一下, 如果这个3-结点不是根结点, 则增加的高度也不会破坏其平衡性, 因为分解4-结点的操作会在顶部生成一个2-结点, 而这个增加的2-结点相当于对3-结点的父结点进行一次插入操作)</p><h3 id="查找和插入操作的复杂度"><a href="#查找和插入操作的复杂度" class="headerlink" title="查找和插入操作的复杂度"></a>查找和插入操作的复杂度</h3><p>　要理解2-3树的操作复杂度, 需要知道树的高度。因为其平衡特性, 2-3树的高度在 $ log_{2}N $ (全是2-结点)和$ log_{3}N $ (全是3-结点)之间。因此, 其查找的复杂度在 $ O(logN) $; 其插入操作需要先查找, 然后进行结点的变换。单个结点变换的复杂度为$ O(1) $, 平均要进行$logN$次变换(最少变换一次: 父结点是2-结点; 最坏变换树的高度: 一路上去全是3-结点, 最后到根结点), 因此插入的复杂度是: $O(logN)+O(logN) = O(logN)$。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>　理解了2-3平衡树后, 红黑树就好理解了。 红黑二叉树的基本思想是用标准的二叉树(全是2-结点)以及一些额外的信息(替换3-结点)来表示2-3平衡树。这个额外的信息是: 红链接将两个2-结点组成一个3-结点, 黑链接表示2-3树的普通链接。红链接指向的结点我们会标记为红色结点。关于一个3-结点和红链接的表示如下图： <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/RBTree.png" alt="红黑树结点"> </p><h3 id="等价定义"><a href="#等价定义" class="headerlink" title="等价定义"></a>等价定义</h3><p>　红黑树可以说是2-3树的变种, 任意的2-3树都能转换成红黑树, 我们可以用一种等价的定义来描述红黑树(和网络上一般讲解的不太一样, 但是都是对的): 红黑树是满足下列条件的二叉查找树:</p><ul><li>红链接均为左链接(即所有的红色结点都是左结点, 根结点必然是黑色);</li><li>没有任何一个结点同时与两条红链接相连;</li><li>该树是完美黑色平衡的</li></ul><p>　满足上述定义的红黑树与相应的2-3树必然是一一对应的。完美黑色平衡是非常直观的，因为红结点不能单独作为2-结点，我们把红链接放平，就是一颗完美平衡的2-3树, 下面是一个简单的示例: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/RedFlat.png" alt="红黑树结点"> </p><h3 id="简单的红黑树结点"><a href="#简单的红黑树结点" class="headerlink" title="简单的红黑树结点"></a>简单的红黑树结点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">Key key;</span><br><span class="line">Value val;</span><br><span class="line">TreeNode left, right; <span class="comment">// 只有左子树和右子树, HashMap中有所不同, 下面再讲</span></span><br><span class="line"><span class="keyword">int</span> N; <span class="comment">//这颗子树中的结点总数</span></span><br><span class="line"><span class="keyword">boolean</span> color; <span class="comment">// 表示从父结点指向它的链接的颜色</span></span><br><span class="line"></span><br><span class="line">TreeNode(Key key, Value val, <span class="keyword">int</span> N, <span class="keyword">boolean</span> color)&#123;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line"><span class="keyword">this</span>.N = N;</span><br><span class="line"><span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面是几个需要用到的简单函数:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(TreeNode x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> x.color == RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(TreeNode x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> x.N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="旋转和颜色变换"><a href="#旋转和颜色变换" class="headerlink" title="旋转和颜色变换"></a>旋转和颜色变换</h3><p>　进行插入的过程中可能会破坏上述性质:  出现红色右链接和两条连续的红链接。这些情况可以通过简单的旋转和颜色变换进行修复。其中旋转是一次进行链接变换的简单操作。</p><ul><li>左旋转: 把一条右红链接转换为左链接, 如图: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/rotateLeft.png" alt="红黑树结点"> </li><li>右旋转: 把一条左红链接转换为右链接, 如图: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/rotateRight.png" alt="红黑树结点"> </li><li>颜色变换: 当左右链接均为红色, 则把两条链接都变黑, 并把根结点变红, 如图: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/flipColor.png" alt="红黑树结点"></li></ul><p>　我们可以利用旋转操作帮我们保证红黑树和2-3树的一一对应, 因此我们无需担心树的平衡性。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li>左旋转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">rotateLeft</span><span class="params">(TreeNode h)</span></span>&#123;</span><br><span class="line">TreeNode x = h.right;</span><br><span class="line">h.right = x.right;</span><br><span class="line">x.left = h;</span><br><span class="line">x.color = h.color;</span><br><span class="line">h.color = RED;</span><br><span class="line">x.N = h.N;</span><br><span class="line">h.N = <span class="number">1</span> + size(h.left) +size(h.right);</span><br><span class="line">retrurn x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>右旋转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">rotateRight</span><span class="params">(TreeNode h)</span></span>&#123;</span><br><span class="line">TreeNode x = h.left;</span><br><span class="line">h.left = x.right;</span><br><span class="line">x.right = h;</span><br><span class="line">x.color = h.color;</span><br><span class="line">h.color = RED;</span><br><span class="line">x.N = h.N;</span><br><span class="line">h.N = <span class="number">1</span> + size(h.left) + size(h.right);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>颜色变换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">filpColors</span><span class="params">(TreeNode h)</span></span>&#123;</span><br><span class="line">h.left.color = BLACK;</span><br><span class="line">h.right.color = BLACK;</span><br><span class="line">h.color = RED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇博客涉及以下几个内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HashMap的部分源码讲解&lt;/li&gt;
&lt;li&gt;红黑树的数据结构&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java内部类</title>
    <link href="http://yoursite.com/2019/12/15/%E6%B5%85%E8%B0%88Java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/12/15/%E6%B5%85%E8%B0%88Java%E5%86%85%E9%83%A8%E7%B1%BB/</id>
    <published>2019-12-15T03:25:12.000Z</published>
    <updated>2020-03-07T12:05:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇博客主要涉及以下几个内容</p><ol><li>Java中的内部类</li><li>Java中的静态内部类</li><li>关于内部类常见的一些面试题</li></ol></blockquote><a id="more"></a><h1 id="Java中的内部类"><a href="#Java中的内部类" class="headerlink" title="Java中的内部类"></a>Java中的内部类</h1><p>内部类就是在Java类内部定义的类，主要分为四种类型：</p><ol><li>成员内部类</li><li>静态内部类</li><li>局部内部类</li><li>匿名内部类</li></ol><h2 id="使用内部类的原因"><a href="#使用内部类的原因" class="headerlink" title="使用内部类的原因"></a>使用内部类的原因</h2><ol><li>Java拥有单继承的特性，而内部类可以独立继承一个类或实现接口。这一定程度上方便了开发。</li><li>内部类的信息与其他外围类信息独立，提供了更好的封装</li></ol><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>作为外部类的成员变量存在，其性质如下：</p><ol><li>可以有访问修饰符</li><li>外部类在类中访问内部类需要通过new的方式</li><li>外部类加载，成员内部类不加载</li><li>不能有静态信息【因为如果外部类没有实例化，则内部类不会被加载(不符合类加载的几种条件)，因此静态变量不会进内存，这与static的概念矛盾了】</li><li>内部类的this关键字表示自己的对象，如要访问外部类的对象则使用<code>外部类名.this</code></li><li>在外部类外访问内部类需要使用<code>外部类的实例引用.new 内部类构造函数</code></li></ol><ul><li>以下demo体现了这些特性：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOuterInnerClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//访问内部类</span></span><br><span class="line">        <span class="comment">//1. 先要有外部类的应引用</span></span><br><span class="line">        OuterInnerClass outer = <span class="keyword">new</span> OuterInnerClass();</span><br><span class="line">        <span class="comment">//2. 通过该引用创建外部类</span></span><br><span class="line">        OuterInnerClass.InnerClass inner = outer.<span class="keyword">new</span> InnerClass();</span><br><span class="line">        <span class="comment">//3. 也可以通过自定义的方法创建</span></span><br><span class="line">        <span class="comment">//inner = outer.creatInner();</span></span><br><span class="line">        <span class="comment">//4.直接使用内部类</span></span><br><span class="line">        inner.print();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         输出结果如下：</span></span><br><span class="line"><span class="comment">         1. Outer Constructor..</span></span><br><span class="line"><span class="comment">         2. Inner Constructor</span></span><br><span class="line"><span class="comment">         3. Outer's val:10</span></span><br><span class="line"><span class="comment">         4. Inner's val:5</span></span><br><span class="line"><span class="comment">         5. outerPrint..</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterInnerClass</span> /*<span class="keyword">extends</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">IA</span>*/</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Outer Constructor.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">outerPrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"outerPrint.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> /*<span class="keyword">extends</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">IB</span>*/</span>&#123;</span><br><span class="line">    <span class="comment">//内部类变量有重名</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> val = <span class="number">5</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Inner Constructor"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//外部类和内部类的成员变量重名如何区分？</span></span><br><span class="line">            System.out.println(<span class="string">"Outer's val:"</span> + OuterInnerClass.<span class="keyword">this</span>.val);</span><br><span class="line">            System.out.println(<span class="string">"Inner's val:"</span> + <span class="keyword">this</span>.val);</span><br><span class="line">            <span class="comment">//可以直接访问外部类的成员变量和方法</span></span><br><span class="line">            outerPrint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">creatInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 外部类中访问内部类通过new的方式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类的性质如下：</p><ol><li>可以有访问修饰符</li><li>静态内部类不依赖于外部类。因此外部类被加载，内部类不会被加载；而内部类被加载，外部类也不会被加载<ol><li>内部类创建：<code>Outer.Inner inner = new Outer.Inner()</code></li><li>访问内部类的静态成员：<code>Outer.Inner.staticValue</code></li></ol></li><li>静态内部类<strong>只可以关联外部类的静态资源</strong>（因为内部类被加载时，关联外部类的静态资源会使外部类加载，但是不能拥有外部类的实例）</li><li>与成员内部类的区别<ol><li>不需要依赖于外部类的实例创建</li><li>只能关联外部类静态资源</li><li>不存在this关键字</li></ol></li></ol><ul><li>以下demo可以体现以上性质：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticOuterInner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成静态内部类的实例</span></span><br><span class="line">        Outer.Inner inner = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">        <span class="comment">//类外访问静态内部类的静态资源</span></span><br><span class="line">        Outer.Inner.innerStaticMethod();</span><br><span class="line">        <span class="comment">//调用内部类的方法</span></span><br><span class="line">        inner.innerMethod();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         输出为：</span></span><br><span class="line"><span class="comment">         1. inner static block...</span></span><br><span class="line"><span class="comment">         2. Inner constructor...</span></span><br><span class="line"><span class="comment">         3. innerStaticMethod...</span></span><br><span class="line"><span class="comment">         4. Outer static block...</span></span><br><span class="line"><span class="comment">         5. Outer static value:10</span></span><br><span class="line"><span class="comment">         6. innerMethod...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Outer static block..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Outer constructor..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"inner static block..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">innerStaticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"innerStaticMethod..."</span>);</span><br><span class="line">            <span class="comment">//可以访问外部类的静态变量</span></span><br><span class="line">            System.out.println(<span class="string">"Outer static value:"</span> + a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Inner constructor..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"innerMethod..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outStaticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//类中访问静态内部类</span></span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出解释：</li></ul><ol><li>首先创建静态内部类的实例，先加载内部类执行静态代码块，随后执行构造方法。由静态内部类的性质可知，加载静态内部类，外部类是不加载的。</li><li>随后执行静态内部类的静态方法，此方法关联了外部类的静态变量，因此外部类被加载，但没有实例化。</li><li>最后执行了静态内部类实例的方法。可见在整个流程中，外部类只是加载了，并没有实例化。</li></ol><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>在一个方法内定义的类，有如下性质：</p><ol><li>没有访问权限修饰符</li><li>仅在方法内有效</li><li>无法创造静态信息，因为这个类是临时的</li><li>可以访问外部类的所有信息（方法内部本身就是可以访问的）</li><li>可以访问方法的参数和局部变量（但是这些变量始终不能被改变）</li></ol><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>常用来重写某个或某些方法，这个用的还是比较多的，比较常见的就是Java的动态代理实现，会实现一个匿名内部类并重写invoke()方法。</p><ul><li>使用动态代理的Demo</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnonInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IPerson person = PersonProxy.getPerson();</span><br><span class="line">        person.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     输出结果：</span></span><br><span class="line"><span class="comment">     1. 做饭...</span></span><br><span class="line"><span class="comment">     2. 吃饭...</span></span><br><span class="line"><span class="comment">     3. 洗碗...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">IPerson</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃饭..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> IPerson person = <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPerson <span class="title">getPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用匿名内部类InvocationHandler，重写invoke方法，对Person接口的所有方法进行增强</span></span><br><span class="line">        <span class="keyword">return</span> (IPerson) Proxy.newProxyInstance(person.getClass().getClassLoader()</span><br><span class="line">                , person.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object obj = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            System.out.println(<span class="string">"做饭..."</span>);</span><br><span class="line">                            obj = method.invoke(person);</span><br><span class="line">                            <span class="keyword">return</span> obj;</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                            System.out.println(<span class="string">"饭馊了..."</span>);</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没吃上饭:"</span> + e);</span><br><span class="line">                        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                            System.out.println(<span class="string">"洗碗..."</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇博客主要涉及以下几个内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java中的内部类&lt;/li&gt;
&lt;li&gt;Java中的静态内部类&lt;/li&gt;
&lt;li&gt;关于内部类常见的一些面试题&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务与隔离级别</title>
    <link href="http://yoursite.com/2019/12/15/MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2019/12/15/MySQL%E4%BA%8B%E5%8A%A1%E4%B8%8E%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</id>
    <published>2019-12-15T03:19:09.000Z</published>
    <updated>2021-07-26T01:56:51.073Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><ol><li>事务的特性</li><li>MySQL隔离级别</li></ol></blockquote><a id="more"></a><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><p>进行数据库的操作离不开事务，事务也是各大厂招聘的必问环节。</p><h2 id="事务的特性"><a href="#事务的特性" class="headerlink" title="事务的特性"></a>事务的特性</h2><p>ACID是事务的基本特性，也是事务这个概念成立的基础。</p><ul><li>Atomic（原子性）：表示一个事务中的所有操作，要么全部成功，要么全部失败回滚。</li><li>Consistance（一致性）：事务执行前后，数据库的数据要保持一致，逻辑上的一致。（这个实现必须要依赖于其他三个特性）<ul><li>只有满足一致性，事务才有意义，事务的提交才是正确的。</li></ul></li><li>Isolation（隔离性）：并发情况下，多用户开启的事务相互之间不能受影响。</li><li>Duration（持久性）：事务的提交是持久性的，会永久改变数据库。</li></ul><p>原子性、一致性和持久性比较容易理解，主要是隔离性的满足需要深入探讨。</p><p>隔离性主要是为了满足高并发情况下事务的隔离问题，因此先明确一下常见的隔离问题。</p><h2 id="事务的隔离问题"><a href="#事务的隔离问题" class="headerlink" title="事务的隔离问题"></a>事务的隔离问题</h2><ol><li>脏读：一个事务读到了另一个事务未提交的内容。</li><li>不可重复读：A事务中，多次读同一条数据，读到的数据不一致（可能是B事务提交了对这条数据的修改）。</li><li>幻读：A事务的两次读取中，读到了未出现过的数据行（可能是B事务插入了这条数据）。</li><li>丢失修改：A事务和B事务同时对一条数据进行了修改，B事务的提交覆盖了A事务的提交。</li></ol><p>在事务的隔离问题中，其中丢失修改是“写”的问题，而其余是“读”的问题。</p><p><font color="red">事务的隔离级别不是用来解决“写”的问题而存在的</font>，也因此我们将“丢失修改”的问题单独拿出来说。</p><h2 id="解决丢失修改的问题"><a href="#解决丢失修改的问题" class="headerlink" title="解决丢失修改的问题"></a>解决丢失修改的问题</h2><p>两种策略：</p><ul><li>悲观策略：事务A对于某项数据进行修改时，在数据上加上排它锁。</li><li>乐观策略：数据表上加上<code>version</code>字段，每次修改数据都要检验一下<code>version</code>是否正确，不正确就回滚。</li></ul><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><p>在讲事务的隔离级别时，MVCC的概念必须要了解。MVCC是Innodb引擎实现隔离级别的一种具体方式，MVCC通俗点讲就是：给数据一个快照。这与CopyOnWrite的思想类似。这里有三个概念：</p><ul><li>一个事务只能读取<strong>已经提交</strong>的快照</li><li>当前事务能够读到自身未提交的快照</li><li>数据的读不更新快照，数据的写更新快照</li></ul><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>使用MVCC之后，所有的select操作都不会加锁，而是用快照读的方式。</p><h4 id="版本号：快照是基于版本号的"><a href="#版本号：快照是基于版本号的" class="headerlink" title="版本号：快照是基于版本号的"></a>版本号：快照是基于版本号的</h4><ul><li>系统版本号<code>sys_id</code>：每开启一个事务，版本号都会递增</li><li>事务版本号<code>trx_id</code>：事务开启前的当前版本号</li></ul><h4 id="Undo日志"><a href="#Undo日志" class="headerlink" title="Undo日志"></a>Undo日志</h4><p>每一条数据行都有三个隐藏的字段：<code>隐藏id（主键）、trx_id、roll_pt</code>。其中<code>roll_pt</code>是回滚指针，用来指向undo日志。在事务提交前，undo日志会记录数据行一开始的状态；提交后，undo日志不会立刻删除，而是会放在删除区等待删除。</p><p><strong>举例：行更新的过程</strong></p><h4 id="ReadView"><a href="#ReadView" class="headerlink" title="ReadView"></a>ReadView</h4><p>MVCC中进行快照读的基准是ReadView。执行<code>select</code>操作，可能会创建一个ReadView（依赖于隔离级别），ReadView保存着系统中所有未提交事务的<code>trx_id</code>。</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">TRX_ID</th><th style="text-align:center"></th></tr></thead><tbody><tr><td style="text-align:center">TRX_ID_MIN</td><td style="text-align:center">…</td><td style="text-align:center">TRX_ID_MAX</td></tr></tbody></table></div><ul><li>TRX_ID_MIN：表示在生成readview时当前系统中活跃的读写事务中最小的事务id</li><li>TRX_ID_MAX：表示生成readview时系统中应该分配给下一个事务的id值（一般情况下是当前事务id + 1，高并发情况下可能更大）</li></ul><p>当用户想要读取某条数据行时，innodb会将这个行的版本号与readview中的版本号进行比较：</p><ul><li>trx_id &lt; TRX_ID_MIN：当前事务开启时，生成这个版本记录的事务已经提交了，所以一定可以读取</li><li>trx_id &gt; TRX_ID_MAX：生成这个版本的事务是本次事务开启readview之后才开启的，对当前事务不可见，不可读取数据（这种情况相爱trx_id的数据一定是无法提交成功的，因为我select的时候会加读锁，之后的事务的修改想要提交成功必须要等我释放锁）</li><li>TRX_ID_MIN &lt; trx_id &lt; TRX_ID_MAX：如果trx_id不在readview里，表示生成该版本号的事务已经提交， 可以读取数据；否则，说明未提交，这就不可以读了。</li></ul><p>补充：如果出现不可读的情况，将会沿着undo日志通过版本链查找最新可用的版本号进行读取。</p><h1 id="Test"><a href="#Test" class="headerlink" title="Test"></a>Test</h1><h1 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h1><h2 id="读未提交（Read-Uncommited）"><a href="#读未提交（Read-Uncommited）" class="headerlink" title="读未提交（Read Uncommited）"></a>读未提交（Read Uncommited）</h2><p>顾名思义，可以读到其他事务未提交的数据。这种隔离级别是<strong>不加锁的</strong>，效率最高，也不用MVCC。</p><h2 id="读已提交（Read-Commited）"><a href="#读已提交（Read-Commited）" class="headerlink" title="读已提交（Read Commited）"></a>读已提交（Read Commited）</h2><p>事务提交后，可以被其他事务读取。但是事务B在两次读取的时间间隔内，事务A提交了修改，则事务B两次读取的数据就会不一样，这就是”不可重复读“的问题。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>事务A在修改数据的时候加写锁，直到事务结束。</p><p>此时这种解决方法会遇到一个问题：<strong>其他事务想要读数据时，会等待锁的释放。</strong></p><p>因此Innodb引擎使用了MVCC来解决读写的一个并发情况。在这种隔离级别下：每次select都会生成一个readview，从而保证每次读取都只能读到已经提交的数据。但是，因为每次select都会生成一个新的readview，因此在这个事务执行期间，可以生成多个不同的readview从而读取到不一致的数据。无法解决不可重复读的情况。</p><h2 id="可重复读（Repeatable-Read）：MySQL默认"><a href="#可重复读（Repeatable-Read）：MySQL默认" class="headerlink" title="可重复读（Repeatable Read）：MySQL默认"></a>可重复读（Repeatable Read）：MySQL默认</h2><p>事务在执行期间，不会读取到其他事务对数据的<strong>修改</strong>。但是其他事务插入的数据依然会被update等操作捕捉到。</p><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>事务开启后的第一次<code>select</code>操作生成了一次readview，后续的所有<code>select</code>都是读的第一次生成的快照。</p><p>但是所有<code>update</code>、<code>delete</code>操作都是当前读，所谓<strong><font color="red">当前读就是读取到最新已提交版本号的数据</font></strong>，所以当前读不走快照的。因此，当事务A在执行<code>update</code>或者<code>delete</code>操作时，会读取到其他事务提交的数据，这些新数据和之间<code>select</code>的数据不一致，间接产生了幻读问题。</p><p><strong>由此可见，MVCC可以解决由select操作引起的直接幻读，但是不能解决修改操作引起的间接幻读。</strong></p><p>==业务场景==：</p><p>快手公司准备给次日24：00之间注册的用户发放1元红包，这时开启事务后会执行update操作，但是24：00之后依然会有大量新用户注册入库，此时update会同时修改这些新用户的红包信息（错误发钱），这就产生了幻读问题，并给公司带来业务损失。</p><h3 id="如何解决幻读？"><a href="#如何解决幻读？" class="headerlink" title="如何解决幻读？"></a>如何解决幻读？</h3><p>Innodb其实在RR隔离级别下实现了幻读的解决：使用了<strong>Next-Key Locks</strong>。</p><p>当开启一个<code>select</code>的操作时，会锁住索引前后的间隔（左开右闭，行锁），这时其他事务进行<code>insert</code>操作会阻塞。</p><p>假设一个数据表如下：</p><div class="table-container"><table><thead><tr><th style="text-align:center">Id</th><th style="text-align:center">a</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">5</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">8</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">11</td></tr><tr><td style="text-align:center">4</td><td style="text-align:center">18</td></tr></tbody></table></div><p>此时<strong>Next-Key Locks</strong>对于索引a的锁的间隔是：$(-oo, 5], (5, 8], (8, 11], (11, 18], (18, +oo]$</p><p>如果此时我们执行：<code>select * from table_name where a = 8</code></p><p>此时会锁住：$ (5, 8] U (8, 11] = (5, 11]$，此时其他事务无法这个范围内的行进行任何操作。</p><h2 id="可串行化"><a href="#可串行化" class="headerlink" title="可串行化"></a>可串行化</h2><p>所有事务串行处理，效率很低，但是足够安全。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;事务的特性&lt;/li&gt;
&lt;li&gt;MySQL隔离级别&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java类加载顺序和static关键字</title>
    <link href="http://yoursite.com/2019/12/15/%E6%B5%85%E8%B0%88Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E5%92%8Cstatic%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/12/15/%E6%B5%85%E8%B0%88Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E5%92%8Cstatic%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2019-12-15T03:19:09.000Z</published>
    <updated>2021-07-19T07:01:25.836Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇博客主要包含以下几个内容</p><ol><li>Java中类加载的顺序</li><li>Java中static关键字的用法</li><li>面试的一些常见问题</li></ol></blockquote><a id="more"></a><h1 id="Java中的类加载"><a href="#Java中的类加载" class="headerlink" title="Java中的类加载"></a>Java中的类加载</h1><p>JVM要执行一段Java程序分为两步：</p><ol><li>将类编译成.class字节码文件</li><li>进行类加载生成类</li></ol><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>想要理解static必须要了解一下类加载的过程，主要分为三步：</p><ol><li>第一步：类文件加载</li><li>第二步：类链接<ol><li>验证</li><li>准备</li><li>解析</li></ol></li><li>第三步：类初始化</li></ol><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类的加载一般通过JVM提供的类加载器ClassLoader完成，在以下几种情况下，JVM会把类加载进内存中进行使用：</p><ol><li>new 这个类的对象</li><li>访问这个类或接口的静态变量</li><li>调用这个类的静态方法</li><li>执行反射操作：Class.forName(“类名”)</li><li>加载这个类的子类</li><li>JVM启动时表明的启动类(<strong>这说明了一个类并不一定要被使用的时候才会被加载</strong>)</li></ol><h2 id="类文件加载"><a href="#类文件加载" class="headerlink" title="类文件加载"></a>类文件加载</h2><p>JVM在编译时会生成类的.class字节码文件，这个文件是存储在磁盘上的。当JVM运行时需要加载某个类时，会将这个文件读入内存，<strong>并由类加载器为其生成一个独一无二的java.lang.Class对象。</strong> 这个对象保存了一个类的所有信息，用暴力反射甚至可以操作其私有变量。</p><h2 id="类链接"><a href="#类链接" class="headerlink" title="类链接"></a>类链接</h2><p>这一步主要分为三小步</p><ol><li>验证：主要验证这个类是否有正确的内部结构(比如.class文件格式是否符合规范等)（这里我有疑问，如果验证失败了，其创建的Class对象是否还有意义？）</li><li>准备：为类中的静态变量分配内存，并设置初始值(同时也会在常量池中创建这个常亮)</li><li>解析：将内存中二进制数据的符号引用生成直接引用（这个引用在堆里，详情可见<a href="https://memoforward.cn/2019/09/25/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AJava%E4%B8%AD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/" target="_blank" rel="noopener">HashMap 为什么会出现内存泄漏问题以及 Java 中引用类型的存储位置</a>)</li></ol><h2 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h2><p>这一步主要给静态变量赋正确的值。<br>也就是说，当我定义<code>static a = 10</code>时，会先在第二步中进行初始化成0，然后在类初始化时被赋予正确的值。因为在程序运行时，每个类只会被加载一次，因此静态成员变量的初始化只会进行一次。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol><li>加载子类前会先加载父类</li><li>类加载完成后，才会执行类实例化的操作</li><li>类初始化和类实例化时不同的概念</li></ol><h1 id="static关键字的用法"><a href="#static关键字的用法" class="headerlink" title="static关键字的用法"></a>static关键字的用法</h1><p>static关键字主要用于五个方面：</p><ol><li>静态方法</li><li>静态成员变量</li><li>静态代码块</li><li>静态内部类</li><li>静态导入</li></ol><h2 id="静态变量和静态代码块"><a href="#静态变量和静态代码块" class="headerlink" title="静态变量和静态代码块"></a>静态变量和静态代码块</h2><p>类加载的时候被赋值和调用，其顺序与代码顺序一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line">    <span class="comment">//改变两段定义的位置程序性会报错</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(a); <span class="comment">// a:0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestStatic t = <span class="keyword">new</span> TestStatic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>类的静态方法会在类加载时分配入口地址，<strong>并且早于类对象的构造函数调用</strong>，因此静态方法是无法访问类的非静态成员变量的，因此在静态方法中也无法使用<code>this或者super</code>关键字。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>具体可以查看我的博客：<a href="https://memoforward.cn/2019/12/15/%E6%B5%85%E8%B0%88Java%E5%86%85%E9%83%A8%E7%B1%BB/" target="_blank" rel="noopener">浅谈Java内部类</a></p><h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><p>这个是JDK5之后的特性，用于导入某个类的<strong>静态方法</strong>，导入后可以直接使用方法名来使用该方法。其用法如下：<code>import static 包名.类名.方法名</code>，方法名可以改成通配符<code>*</code>，这样就可以导入所有静态方法。（我试了一下，静态成员变量无法导入）<br>例子继续按照上方的代码，增加了一个静态方法，并把该类放置在<code>memoforward包</code>下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"gogogogo....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后我在另一个类中静态导入方法<code>print()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> memoforward.TestStatic.print;</span><br><span class="line"><span class="comment">//import static memoforward.TestStatic.*;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticImport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的输出是：<code>10 和 gogogo...</code>，表示调用某个类静态方法后，这个类会先被加载。</p><h2 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h2><ul><li>静态成员变量和静态方法都是被所有对象共有的，任意对象都可以操作<strong>同一份</strong>静态变量，使用静态方法。</li><li>子类对象可以使用父类对象的静态成员变量（且仍是同一份数据），但是如果子类重新声明了同名静态变量，则JVM会为子类额外分为一块内存空间，此时会由对象的类型来确定到底调用哪一个静态变量（因此静态变量不存在继承的关系，其调用完全根据其类型，静态方法同理），学术点讲：静态方法是静态绑定的。</li><li>如果子类和父类有同名的静态变量或者静态方法，则根据其<strong>引用类型</strong>进行调用。</li></ul><p>测试代码：</p><ul><li>父类Father</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> b = <span class="number">17</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Father method..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子类Son</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son method..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试：可见静态的变量和方法若有重名会根据其引用类型来确定，若没有重名，则子类调用父类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> memoforward.Father;</span><br><span class="line"><span class="keyword">import</span> memoforward.Son;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticExtends</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        Father fs = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(father.a); <span class="comment">// 10</span></span><br><span class="line">        System.out.println(son.a); <span class="comment">// 5</span></span><br><span class="line">        System.out.println(fs.a); <span class="comment">// 10 </span></span><br><span class="line">        System.out.println(son.b); <span class="comment">// 17</span></span><br><span class="line">        father.staticMethod(); <span class="comment">// Father staticMehtod...</span></span><br><span class="line">        son.staticMethod(); <span class="comment">// Son staticMethod...</span></span><br><span class="line">        fs.staticMethod(); <span class="comment">// Father staticMehtod...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h1><ul><li><p>问题一<br>Q：static关键字会改变变量的访问权限吗？<br>A：不会，能影响访问权限的只有<code>public、private和protected</code>关键字，如果一个静态变量被声明为<code>private</code>，则在类外是无法使用的。</p></li><li><p>问题二<br>Q：抽象方法可否是静态的？<br>A：不能，静态方法不能被重写，且抽象方法无法直接被类调用。</p></li><li><p>问题三<br>Q：以下代码的输出是什么</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Test"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person "</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"MyClass"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：输出如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. test static</span><br><span class="line">2. myclass static</span><br><span class="line">2. person static </span><br><span class="line">3. person Test</span><br><span class="line">4. test constructors</span><br><span class="line">5. person MyClass</span><br><span class="line">6. myclass constructor</span><br></pre></td></tr></table></figure></p><p>Explanation:</p><ol><li>调用Test类的静态方法Main，首先会加载Test类，因此执行静态代码块，输出:<code>test static</code></li><li>使用new MyClass()，会先加载类MyClass，输出:<code>myclass static</code></li><li>执行子类实例化前，会先执行父类实例化，初始化操作的顺序：先给成员变量赋默认值，再执行构造函数，因此先执行父类<code>Test</code>中<code>new Person(&quot;Test&quot;)</code></li><li>加载<code>Person</code>类，并执行构造函数，先后输出:<code>person static</code>和<code>person Test</code></li><li>父类<code>Test</code>中成员变量<code>person</code>赋值完毕，执行构造函数,输出：<code>test constructor</code></li><li>随后进行子类对象<code>MyClass</code>初始化，因为<code>Person</code>类已经加载过，因此不会再加载了，所以先后输出:<code>person MyClass</code>和<code>myClass constructor</code></li></ol><p><font color="red"> Attention: </font><br>这里有个小细节：子类所有实例化操作（包括成员变量赋值和构造器）都慢于父类实例化的操作，而实例化操作的顺序是：先进行成员变量赋值，再执行构造函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇博客主要包含以下几个内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java中类加载的顺序&lt;/li&gt;
&lt;li&gt;Java中static关键字的用法&lt;/li&gt;
&lt;li&gt;面试的一些常见问题&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java面试问题汇总（一）</title>
    <link href="http://yoursite.com/2019/12/13/%E5%B8%B8%E8%A7%81%E7%9A%84Java%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/12/13/%E5%B8%B8%E8%A7%81%E7%9A%84Java%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2019-12-13T11:23:55.000Z</published>
    <updated>2020-03-07T11:44:16.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇文章主要包括如下内容：</p><ol><li>无序数组寻找第K大的值的算法</li><li>Java中static关键字的理解</li><li>Java中的HashMap</li><li>Java中的LinkedHashMap</li></ol></blockquote><a id="more"></a><h1 id="无序数组寻找第K大的值"><a href="#无序数组寻找第K大的值" class="headerlink" title="无序数组寻找第K大的值"></a>无序数组寻找第K大的值</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个数组，寻找其第K大的值，并分析其复杂度</p><h2 id="笔者踩的坑"><a href="#笔者踩的坑" class="headerlink" title="笔者踩的坑"></a>笔者踩的坑</h2><p>遇到这种问题一定要思考一下，问一下面试官：</p><ol><li>数组是否是数字？</li><li>数组是否有序？ </li><li>数组中是否有重复的数字？</li></ol><p>笔者没问，回来后后悔不已，毕竟这是笔者第一次面试，把自己的菜展现的一览无余。</p><p><strong>我们假设这道题：无序，是数字，无重复。</strong></p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>寻找一个标志，遍历数组，将比它小的放在左边，比它大的放在右边（快排），记录比它小的数的个数，如果大于K，则在左边寻找，如果小于K，则在右边寻找。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> findKth(nums, k, <span class="number">0</span>, nums.length);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = start;</span><br><span class="line">        <span class="keyword">int</span> flag = nums[start];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start+<span class="number">1</span>; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= flag) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p++;</span><br><span class="line">                exchange(nums, p, i);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exchange(nums,start, p);</span><br><span class="line">        <span class="keyword">if</span>(count == k -<span class="number">1</span>) <span class="keyword">return</span> nums[p];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count &gt; k -<span class="number">1</span>) <span class="keyword">return</span> findKth(nums, k, start, p);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> findKth(nums, k - <span class="number">1</span> - count, p+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java中static关键字的理解"><a href="#Java中static关键字的理解" class="headerlink" title="Java中static关键字的理解"></a>Java中static关键字的理解</h1><p>具体可以移步我的博客：<a href>浅谈Java类加载机制和static关键字</a></p><h1 id="Java中的HashMap"><a href="#Java中的HashMap" class="headerlink" title="Java中的HashMap"></a>Java中的HashMap</h1><p>具体可以移步我的博客：<a href>浅谈Java中的HashMap以及红黑树</a></p><h1 id="Java中的LinkedHashMap"><a href="#Java中的LinkedHashMap" class="headerlink" title="Java中的LinkedHashMap"></a>Java中的LinkedHashMap</h1><p>具体可以移步我的博客：<a href>浅谈Java中LinkedHashMap的实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇文章主要包括如下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无序数组寻找第K大的值的算法&lt;/li&gt;
&lt;li&gt;Java中static关键字的理解&lt;/li&gt;
&lt;li&gt;Java中的HashMap&lt;/li&gt;
&lt;li&gt;Java中的LinkedHashMap&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的数据结构以及辅助索引的使用</title>
    <link href="http://yoursite.com/2019/09/28/MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/09/28/MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2019-09-28T14:34:43.000Z</published>
    <updated>2020-03-07T12:21:35.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文涉及的知识点如下</p><ol><li>MySQL的内部存储结构BTree和B+Tree</li><li>主键索引和辅助索引的结构 以及 查询操作的执行流程</li><li>InnoDB引擎和MyISAM引擎的差别</li></ol><a id="more"></a></blockquote><p>·　　之前学习MySQL都是一直半解，以为建立主键索引只是为了约束数据。直到自己学着做一些开源项目的时候，才发现有<strong>辅助索引</strong>这个神奇的设定，对应的SQL语句：<code>KEY aux_index(col_name)</code>，上网一搜才发现这是为了加快MySQL查询速度。于是我就对MySQL的数据存储结构产生了兴趣，在这里做一个小小的总结。</p><p>·　　我查看了官方的文档和许多博客，觉得这篇博客写的是真的好，分享给大家：<a href="https://www.kancloud.cn/kancloud/theory-of-mysql-index/41846" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><h1 id="BTree-和-B-Tree"><a href="#BTree-和-B-Tree" class="headerlink" title="BTree 和 B+Tree"></a>BTree 和 B+Tree</h1><p>·　　B+Tree是BTree的扩展，而常用的MySQL引擎<strong>MyISAM和InnoDB</strong>都是用B+Tree作为数据结构存储的（在参考博客里有使用BTree的原因，涉及计算机磁盘的读写，本文不讨论这部分内容），因此在这里介绍一下这两个数据结构。</p><h2 id="索引的价值"><a href="#索引的价值" class="headerlink" title="索引的价值"></a>索引的价值</h2><p>·　　索引顾名思义就是目录，我们需要的内容可能是庞大的，但是索引都是很简洁的，所以索引的存储相比内容而言更具灵活性，也更容易被应用于复杂的数据结构。我们把庞大的内容放在内存里，通过索引去找到这些内容，不仅可以利用索引的灵活性构成高效的数据结构来提高查找效率，也可以一定程度下减少查找时所用的I/O读写时间。</p><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h2><p>·　　BTree有一个重要的概念：度。<br>·　　这个概念似乎和正常的树不太一样，一般说来树节点的“度”表示此节点下拥有的子树的个数，是针对一个节点而言的，<strong>而BTree的度，表示这颗树的度</strong>。<br>·　　在介绍这个概念之前，我们要搞清楚BTree的节点中存的是什么。<strong>BTree的每个节点都储存了至少一个键值对，在每个键值对的前后都有一个指针。</strong> 具体的图如下：<br><img src="https://img-blog.csdnimg.cn/20190928201511856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>·　　上图中根节点储存有：<strong>三个键值对，四个指针。</strong> 每一个指针都会指向下一个节点，或者指向null。<br>·　　如果规定：<strong>一个节点中拥有<code>n</code>个指针和<code>n-1</code>个键值对，那么BTree的度<code>d</code>则约束了：<code>d ≤ n ≤ 2d</code>。</strong> 上图就是一个<code>d = 2</code>的BTree结构。<br>·　　根据上图我们显然可以猜到BTree树的性质</p><ol><li>每个节点中的键值对，根据键的大小，从左至右非递减。</li><li>指针左边的key都小于等于指针指向的子节点的所有key，右边的key都大于等于。</li></ol><p>·　　查找的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BTree_Search(node, m_key)&#123;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">foreach(k : node.key)&#123;</span><br><span class="line"><span class="keyword">if</span>(m_key == k) <span class="keyword">return</span> node.get(k);</span><br><span class="line"><span class="keyword">if</span>(m_key &lt; k) <span class="keyword">return</span> BTree_Search(node.leftPointer(k), m_key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BTree_Search(node.rightPointer(last_key), m_key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTree_Search(root, m_key);</span><br></pre></td></tr></table></figure><p>·　　这里有一个有趣的小细节：BTree在最简单的情况下就是一个二叉树，因此BTree树的高最高是logN。</p><h2 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h2><p>·　　通过上面的BTree我们注意到，每个节点都会存数据，为了加快读写的速度，引入了B+Tree，舍去了非叶子节点的数据存储，仅在叶子结点中存储所有的value；同时，其对指针的数量进行了一些调整。概念图如下：<br><img src="https://img-blog.csdnimg.cn/20190928205253979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>·　　可见，在B+Tree中，每个节点中指针的数量和键的数量相同，并满足：<code>d ≤ n &lt; 2d</code>。而且叶子节点不存储指针。<br>·　　查找的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BTree_Search(node, m_key)&#123;</span><br><span class="line"><span class="keyword">if</span>(node.isLeaf())&#123;</span><br><span class="line">foreach(k : node.key)&#123;</span><br><span class="line"><span class="keyword">if</span>(m_key == k) <span class="keyword">return</span> node.get(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">foreach(k : node.key)&#123;</span><br><span class="line"><span class="keyword">if</span>(m_key == k) <span class="keyword">return</span> BTree_Search(node.rightPointer(k), m_key);</span><br><span class="line"><span class="keyword">if</span>(m_key &lt; k) <span class="keyword">return</span> node.havaLeftPointer() ? BTree_Search(node.leftPointer(k), m_key) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BTree_Search(node.rightPointer(last_key), m_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MySQL中的数据结构（索引实现）"><a href="#MySQL中的数据结构（索引实现）" class="headerlink" title="MySQL中的数据结构（索引实现）"></a>MySQL中的数据结构（索引实现）</h1><p>·　　空谈结构没有数据就是耍流氓，因此这里提供一个数据库表。我们假设：<strong>id为主键索引，name为辅助索引。</strong></p><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>gender</th></tr></thead><tbody><tr><td>1</td><td>cxy</td><td>male</td></tr><tr><td>2</td><td>lhw</td><td>female</td></tr><tr><td>3</td><td>tyy</td><td>female</td></tr><tr><td>4</td><td>dsx</td><td>male</td></tr></tbody></table></div><h2 id="InooDB引擎"><a href="#InooDB引擎" class="headerlink" title="InooDB引擎"></a>InooDB引擎</h2><p>·　　鄙人不才，只用过这一个引擎，主要是因为InooDB支持事务和行级锁。InooDB索引结构是B+Tree，其索引就是一个个key。但是主键索引和辅助索引在叶子节点的存储结构上有一点不同。</p><ul><li><strong>对于主键索引，其存储结构可能如下（仅做示意）：</strong><br><img src="https://img-blog.csdnimg.cn/20190928213309884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>因此若执行<code>select * from this_table where id = 3</code>，就会执行</strong>：<br><img src="https://img-blog.csdnimg.cn/20190928214021332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>辅助索引结构示意图：顺序是ASCII码</strong><br><img src="https://img-blog.csdnimg.cn/2019092821434353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>·　　<strong>可见，辅助索引中存储的是主键索引，而不是真正的数据值。</strong></li><li><strong>因此若执行<code>select * from this_table where name = cxy</code>，就会执行</strong><br><img src="https://img-blog.csdnimg.cn/20190928215014827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><font color="red">**注意**</font></li></ul><ol><li>InooDB引擎必须要有主键，因为整个引擎都是以主键构成的B+Tree结构而存在的。如果我们不指定主键，mysql会自动给我们创建一个隐藏的主键。</li><li>InooDB的主键最好设置成：<strong>与业务无关且自增。</strong> 我们观察BTree的结构，一旦插入值，这个结构就要重建，很费时，如果主键是自增的，可以减少插入数据时BTree树的更新时间(降低数据写入的时间)。</li><li>辅助索引如果不手动创建，MySQL是不会帮我们创建的，<strong>如果没有辅助索引，我们通过name来找数据的时候，搜索复杂度是O(n)，非常耗时。</strong></li><li><strong>辅助索引并不是越多越好。</strong> 我们观察整个搜索流程会发现，<strong>辅助索引通过牺牲空间的方式来提升查询速度，如果辅助索引过多，必然会造成空间的浪费。</strong></li></ol><h2 id="MyISAM引擎"><a href="#MyISAM引擎" class="headerlink" title="MyISAM引擎"></a>MyISAM引擎</h2><p>·　　这个引擎我还没用过，因为其不支持事务，但是其查询速度非常快！<strong>因为，不管是主键索引还是辅助索引，其叶子节点都存放着数据的地址值</strong>，这表示，在MyISAM引擎中，主键并不是必须的，我们可以通过任何索引在一个logN时间内访问到数据。（但本质上，这还是一个通过空间换时间的算法）</p><ul><li><strong>简要画一下MyISAM的索引结构示意图</strong><br><img src="https://img-blog.csdnimg.cn/20190928221842902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>·　　辅助索引的结构是一样的。</li></ul><h2 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h2><p>·　　这个概念我是这么理解的，如果<strong>数据和索引在整个结构中不分离，则为聚集索引</strong>，因此在InooDB中主键索引是聚集索引，而辅助索引是非聚集索引；而在MyISAM中，所有的索引都是非聚集的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　用了一晚上来写这个博客，还算是有所收获，也终于知道了MySQL数据库的存储结构，以及要在什么时候使用辅助索引。</p><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文涉及的知识点如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MySQL的内部存储结构BTree和B+Tree&lt;/li&gt;
&lt;li&gt;主键索引和辅助索引的结构 以及 查询操作的执行流程&lt;/li&gt;
&lt;li&gt;InnoDB引擎和MyISAM引擎的差别&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>HashMap为什么会出现内存泄漏问题以及Java中引用类型的存储位置</title>
    <link href="http://yoursite.com/2019/09/25/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AJava%E4%B8%AD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/09/25/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AJava%E4%B8%AD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/</id>
    <published>2019-09-25T01:28:46.000Z</published>
    <updated>2020-03-07T12:21:12.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文涉及如下知识点：</p><ol><li>HotSpot的垃圾处理机制</li><li>HashMap为什么存在内存泄漏问题</li><li>Java中的引用变量的存储位置</li></ol></blockquote><a id="more"></a><p>·　　最近在研究弱引用的时候，注意到了Java在内存管理时的细节，在这里给大家分享一下。</p><h1 id="JVM中垃圾处理的机制"><a href="#JVM中垃圾处理的机制" class="headerlink" title="JVM中垃圾处理的机制"></a>JVM中垃圾处理的机制</h1><p>·　　垃圾处理的算法非常多，本博客只介绍使用最广的HotSpot虚拟机的垃圾回收算法。简单说来，其使用了<strong>可达性分析算法</strong> ，通过选出一系列称为<strong>GC Roots</strong>的对象作为起点，当一个对象没有任何一条<strong>强引用链</strong>指向<strong>GC Roots</strong>时，则这个对象会被判定为可回收对象。弱引用不是本章讨论的重点，有兴趣的自行百度。<br><img src="https://img-blog.csdnimg.cn/2019092422030897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="图1-1"><br>·　　在上图中，object5、6、7会被回收。<br>·　　显然，此算法最核心的部分在于<strong>GC Roots</strong>的选取，所以我们要关注<font color="red"><strong>在什么位置的对象才能成为GC Roots</strong></font>,在《深入理解JVM虚拟机》中给出了答案：</p><ol><li><strong>虚拟机栈中引用的对象</strong></li><li><strong>方法区中类静态属性引用的对象</strong></li><li><strong>方法区中的常量对象</strong></li><li><strong>本地方法栈中JNI(Native方法)引用的对象</strong></li></ol><p>·这里不普及JVM的内存结构。</p><h1 id="Java中引用类型的存储位置"><a href="#Java中引用类型的存储位置" class="headerlink" title="Java中引用类型的存储位置"></a>Java中引用类型的存储位置</h1><p>·　　介绍可达性算法主要是为了给我下面的想法做铺垫。<br>·　　<font color="red"><strong>注意：以下的内容我没有从任何书籍和博客上看到明确的解答，所以仅是我个人的一些理解。</strong></font></p><ul><li><strong>Java中的引用到底存在哪里?</strong><br>·　　大部分人都认为，在java中，所有的引用都保存在栈中(虚拟机栈），而引用指向的对象实例则在堆里。<strong>我认为这是不准确的，如果一个对象实例中有另一个对象的引用，那么<font color="red">这个引用并非存在栈里，而是存在于堆中</font></strong>。<br>·　　下面给出我测试用的一段代码：</li><li>测试用类B：对象占用内存大小1MB</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试用类A：占用内存大小2MB</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试代码：为了避免不必要的干扰，我在创建实例前先进行了一次垃圾回收。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　结果猜测：显然，<code>引用ａ</code>是存在于栈中的，而ａ指向的实例Ａ，以及实例Ａ中创建的实例Ｂ存在于堆中。现在不确定的点在于：指向实例B的<code>a.b</code>这个引用是存在于栈中，还是堆中呢？众所周知，栈中的数据会随着方法的结束而被释放，如果方法不结束，其数据就不会释放，因此我用<code>while(true){...}</code>使main方法永远不会结束，且每5秒进行一次垃圾回收，看堆中的储存情况。</p><ol><li>如果<code>a.b</code>保存在栈中，其就可作为<strong>GC Root</strong>存在，那么根据可达性算法，实例B永远不会被回收。</li><li>而如果<code>a.b</code>保存在堆中，一旦<code>引用a</code>被释放了，那么实例A和实例B就会如上图中的<code>object5、6、7</code>一样，被GC回收</li><li>根据以上两种理论，<strong>如果<code>a.b</code>保存在栈中，即使实例A被释放了，实例B也不会被释放，堆中至少有1MB的数据。而如果<code>a.b</code>保存在堆中，实例A和实例B都会被释放，堆中的数据至少会小于1MB。</strong></li></ol><ul><li>以下是程序的运行结果：<strong>堆内存中可粗略地细分为新生代和老年代</strong>，这里就不扩展了。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 3333K-&gt;744K(38400K)] 3333K-&gt;752K(125952K), 0.0042393 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 744K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;673K(87552K)] 752K-&gt;673K(125952K), [Metaspace: 3479K-&gt;3479K(1056768K)], 0.0078916 secs] [Times: user&#x3D;0.03 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 2713K-&gt;2176K(38400K)] 3386K-&gt;2849K(125952K), 0.0010460 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 2176K-&gt;0K(38400K)] [ParOldGen: 673K-&gt;2718K(87552K)] 2849K-&gt;2718K(125952K), [Metaspace: 3485K-&gt;3485K(1056768K)], 0.0079493 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 665K-&gt;64K(38400K)] 3384K-&gt;2782K(125952K), 0.0003627 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 64K-&gt;0K(38400K)] [ParOldGen: 2718K-&gt;670K(87552K)] 2782K-&gt;670K(125952K), [Metaspace: 3485K-&gt;3485K(1056768K)], 0.0039402 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 0K-&gt;0K(38400K)] 670K-&gt;670K(125952K), 0.0003178 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 0K-&gt;0K(38400K)] [ParOldGen: 670K-&gt;669K(87552K)] 670K-&gt;669K(125952K), [Metaspace: 3485K-&gt;3485K(1056768K)], 0.0066122 secs] [Times: user&#x3D;0.05 sys&#x3D;0.00, real&#x3D;0.01 secs]</span><br></pre></td></tr></table></figure><ol><li>第一次GC时，堆中的内存被清理到只有673K，并且进入了老年代：<code>[ParOldGen: 8K-&gt;673K(87552K)]</code>。</li><li>第二次GC前，我们创建了对象a，在堆内存中占用了2MB：<code>[PSYoungGen: 2713K-&gt;2176K(38400K)]</code>(<del>这里不做细微的误差分析，因为我也不清楚gc到底干了什么</del> )。随后这2MB内存进入了老年代：<code>[ParOldGen: 673K-&gt;2718K(87552K)]</code></li><li>第三次GC前，我们释放了实例A的链接，发现这2MB内存被释放了，老年代中仅剩原先的673K（可能有点误差）：<code>[ParOldGen: 2718K-&gt;670K(87552K)]</code></li><li>第四次GC，因为堆中已经没有实例A、B所以此垃圾回收没有释放任何空间。</li><li><font color="red">**总上所述：我认为类成员变量的引用必然在堆内存中。**</font></li></ol><h1 id="HashMap的内存泄漏问题"><a href="#HashMap的内存泄漏问题" class="headerlink" title="HashMap的内存泄漏问题"></a>HashMap的内存泄漏问题</h1><p>·　　有了上述问题的铺垫，我们可以正式聊一下HashMap中内存泄漏的问题， 因为之前看ThreadLocal的源码才意识到了这个问题，实在是惭愧，话不多说，我先解释一下内存泄漏的原因：</p><ol><li>首先要明确的一点是，<strong>Java中的参数都是按值传递的</strong>，即使是引用，在传递时也会生成引用的副本。</li><li>因此，HashMap的对象引用<code>map</code>在<code>put(key，value)</code>时，就会生成key，value引用的副本，我们姑且称为<code>key&#39;</code>和<code>value&#39;</code>。根据上面的理论，这个副本应该存在堆内存中。</li><li>当栈中的<code>key引用</code>被释放时，原来指向的实例<code>KEY</code>（姑且这么称呼），与栈中的<code>map引用</code>依然存在一条可达链：<strong>map —— HashMap实例 —— key’ —— KEY实例</strong> 这条强引用链。因此实例KEY不会被释放，虽然HashMap可以保存键为null的Entry，但是实例KEY我们就不会再用到了，而它迟迟不释放，就会造成内存泄漏的问题。</li></ol><ul><li>图示说明：可以很明显看出来<code>KEY</code>和<code>VALUE</code>有两条强引用链<br><img src="https://img-blog.csdnimg.cn/20190925084205942.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h2>我们将类A稍作修改，让其不关联类B：</li><li>类A</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="comment">//    public B b = new B();</span></span><br><span class="line">    <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"0.--------------"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"1.--------------"</span>);</span><br><span class="line">        Map&lt;A, B&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"2.--------------"</span>);</span><br><span class="line">        map.put(a,b);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"3.--------------"</span>);</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"4.--------------"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 3333K-&gt;712K(38400K)] 3333K-&gt;720K(125952K), 0.0016227 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 712K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;629K(87552K)] 720K-&gt;629K(125952K), [Metaspace: 3206K-&gt;3206K(1056768K)], 0.0074770 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">1.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 3379K-&gt;2176K(38400K)] 4008K-&gt;2805K(125952K), 0.0012001 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 2176K-&gt;0K(38400K)] [ParOldGen: 629K-&gt;2676K(87552K)] 2805K-&gt;2676K(125952K), [Metaspace: 3226K-&gt;3226K(1056768K)], 0.0076292 secs] [Times: user&#x3D;0.03 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">2.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1996K-&gt;32K(38400K)] 4672K-&gt;2708K(125952K), 0.0005201 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 2676K-&gt;2675K(87552K)] 2708K-&gt;2675K(125952K), [Metaspace: 3226K-&gt;3226K(1056768K)], 0.0076530 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">3.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1331K-&gt;96K(38400K)] 4007K-&gt;2771K(125952K), 0.0003721 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 96K-&gt;0K(38400K)] [ParOldGen: 2675K-&gt;2677K(87552K)] 2771K-&gt;2677K(125952K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0027659 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">4.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1331K-&gt;160K(38400K)] 4009K-&gt;2837K(125952K), 0.0005946 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 160K-&gt;0K(38400K)] [ParOldGen: 2677K-&gt;2718K(87552K)] 2837K-&gt;2718K(125952K), [Metaspace: 3488K-&gt;3488K(1056768K)], 0.0065556 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs]</span><br></pre></td></tr></table></figure><ul><li>结果分析：因为FullGC对线程的停顿时间比较长，未被回收的对象会进入老年代，而新生代中会被清0，因此为了方便，<strong>我们仅关注老年代的情况</strong>。</li></ul><ol><li>程序一开始先进行一次清理，避免不必要的干扰，老年代中有628K：<code>[ParOldGen: 8K-&gt;629K(87552K)]</code>。</li><li>随后，我们创建了HashMap实例，实例A和实例B，在这次的GC中，老年代中多了约2MB内存：<code>[ParOldGen: 629K-&gt;2676K(87552K)]</code>。</li><li>然后我们将实例A，B放进hashMap对象：<code>map.put(a,b)</code>，put操作会在堆内存中会有额外的开销（会新建一些对象用来进行put操作），因此新生代中会有新内存的使用（但很快就被清理掉了）：<code>[PSYoungGen: 1996K-&gt;32K(38400K)]</code>。我们通过观察老年代：<code>[ParOldGen: 2676K-&gt;2675K(87552K)]</code>，发现实际上这个put操作并没有为HashMap开辟新的内存空间，因为map仅仅只是把内部的引用指向了实例A, B而已。</li><li>这一步我们将栈中的引用a释放：<code>a = null;</code>，我们希望看到实例A被回收，但是GC并没有这样做，老年代中的值几乎没有变化：<code>[ParOldGen: 2675K-&gt;2677K(87552K)]</code></li><li>为了避免意外，令线程沉睡5秒后，再次清理，发现实例A仍在堆内存中：<code>[ParOldGen: 2677K-&gt;2718K(87552K)]</code>，因此可以判断这造成了一定的内存泄漏。</li><li><strong>事实上，HashMap中的某一个特定key很难被清理掉，因为用map.clear()会清理掉整个map。但是HashMap的内存泄漏一般不会很严重，因为只有在极少数情况下，我们才想去手动释放一个key。</strong></li></ol><h2 id="再次证明内存泄漏的代码"><a href="#再次证明内存泄漏的代码" class="headerlink" title="再次证明内存泄漏的代码"></a>再次证明内存泄漏的代码</h2><p>·　　笔者不太会手动去真正释放HashMap的key，因此，我做了一个实验，先把类A关联上类B，但是不实例化这个B。</p><ul><li>类A</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> B b;</span><br><span class="line">    <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实验步骤</li></ul><ol><li>实例化A,B得<code>引用a，b</code>，并把<code>a.b = b</code></li><li>令 <code>b = null</code>, 再令<code>a.b = null</code>，比较内存变化情况</li><li>再令 <code>a = null</code>，查看内存</li></ol><ul><li>实验代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"0.--------------"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"1.--------------"</span>);</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"2.--------------"</span>);</span><br><span class="line">        a.b = b;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"3.--------------"</span>);</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"4.--------------"</span>);</span><br><span class="line">        a.b = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"5.--------------"</span>);</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 3333K-&gt;776K(38400K)] 3333K-&gt;784K(125952K), 0.0013798 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 776K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;673K(87552K)] 784K-&gt;673K(125952K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0198551 secs] [Times: user&#x3D;0.05 sys&#x3D;0.00, real&#x3D;0.02 secs] </span><br><span class="line">1.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 2713K-&gt;2144K(38400K)] 3387K-&gt;2817K(125952K), 0.0047306 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 2144K-&gt;0K(38400K)] [ParOldGen: 673K-&gt;2718K(87552K)] 2817K-&gt;2718K(125952K), [Metaspace: 3487K-&gt;3487K(1056768K)], 0.0091880 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">2.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1331K-&gt;32K(38400K)] 4050K-&gt;2750K(125952K), 0.0003588 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 2718K-&gt;2718K(87552K)] 2750K-&gt;2718K(125952K), [Metaspace: 3487K-&gt;3487K(1056768K)], 0.0080175 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">3.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 665K-&gt;32K(38400K)] 3383K-&gt;2750K(125952K), 0.0004018 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 2718K-&gt;2718K(87552K)] 2750K-&gt;2718K(125952K), [Metaspace: 3487K-&gt;3487K(1056768K)], 0.0037897 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">4.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 665K-&gt;32K(38400K)] 3383K-&gt;2750K(125952K), 0.0005433 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 2718K-&gt;1694K(87552K)] 2750K-&gt;1694K(125952K), [Metaspace: 3487K-&gt;3487K(1056768K)], 0.0051309 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">5.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 665K-&gt;32K(38400K)] 2359K-&gt;1726K(125952K), 0.0045968 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 1694K-&gt;670K(87552K)] 1726K-&gt;670K(125952K), [Metaspace: 3488K-&gt;3488K(1056768K)], 0.0044260 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 665K-&gt;32K(38400K)] 1335K-&gt;702K(125952K), 0.0003409 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 670K-&gt;670K(87552K)] 702K-&gt;670K(125952K), [Metaspace: 3488K-&gt;3488K(1056768K)], 0.0030132 secs] [Times: user&#x3D;0.05 sys&#x3D;0.00, real&#x3D;0.00 secs]</span><br></pre></td></tr></table></figure><ul><li>结果分析</li></ul><ol><li>程序一开始先进行一次清理，避免不必要的干扰，老年代中有673K：<code>[ParOldGen: 8K-&gt;673K(87552K)]</code>。</li><li>创建了实例A,B后，老年代中多了2MB：<code>[ParOldGen: 673K-&gt;2718K(87552K)]</code></li><li>将实例A与实例B关联<code>a.b = b</code>后，堆内存无变化：<code>[ParOldGen: 2718K-&gt;2718K(87552K)]</code></li><li>令栈中的<code>引用b=null</code>，发现内存不释放：<code>[ParOldGen: 2718K-&gt;2718K(87552K)]</code>，这与HashMap的内存泄漏完全一致</li><li>此时，我们释放掉<code>a.b</code>对实例B的引用<code>a.b = null</code>，发现实例B被清理了：<code>[ParOldGen: 2718K-&gt;1694K(87552K)]</code>，但是实例A仍然占用了1MB的堆内存。</li><li>随后我们再次释放<code>引用a = null</code>，发现此时实例A也被清理了：<code>[ParOldGen: 1694K-&gt;670K(87552K)]</code></li><li><strong>这个实验证明了：GC Root与实例B之间确实有强引用链，而这个强引用链是 类A成员变量类B的引用提供的</strong></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　Java的内存管理机制还是很巧妙的，相比C++方便了很多，越往后面学发现这些底层的东西才是java的灵魂的所在啊。</p><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文涉及如下知识点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HotSpot的垃圾处理机制&lt;/li&gt;
&lt;li&gt;HashMap为什么存在内存泄漏问题&lt;/li&gt;
&lt;li&gt;Java中的引用变量的存储位置&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal的深入理解</title>
    <link href="http://yoursite.com/2019/09/24/ThreadLocal%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/24/ThreadLocal%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</id>
    <published>2019-09-24T13:10:22.000Z</published>
    <updated>2020-03-07T12:22:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇文章深入探讨了ThreadLocal的实现以及使用场景<br>本文章全部基于个人理解，如有错误请邮箱联系本人，多谢</p></blockquote><a id="more"></a><p>·　　最近对多线程，高并发产生了兴趣(<del>其实是面试大厂的时候对性能提升这一块有较高的要求</del> )，以前只会用 <code>synchronized</code> 关键字来实现线程安全，其实这是比较狭隘的，解决线程安全的问题有很多种方法，比如：非阻塞同步(乐观锁机制：在一个可能有线程安全问题的方法中，去判断此操作的结果是否符合预期，如果不符合就放弃此操作的输出，并重新对开始一轮新的操作直到符合预期后再输出)，使用可重入的代码(无法对共享变量进行修改的代码)以及我们今天要提及的<code>ThreadLocal</code>。<br>·　　我写博客主要还是为了给自己看，多了一些自己的理解，但是可能并不精炼。而讲<code>ThreadLocal</code>的好文已经有很多了，这也不是什么新技术，各位还是看比较权威的文章更好一点，我这里实名推荐一篇：<a href="https://blog.csdn.net/fengcaho0616/article/details/79154697" target="_blank" rel="noopener">(转载)ThreadLocal实现原理</a>，<strong>但是我仍要强烈鄙视一下这篇文章的博主，明明是转载的，却不标明出处。</strong></p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>·　　我在前言里说了辣么多解决线程安全的方法，这时候人本能就会想到两个问题：1. 哪个最好？2. 如果有最好的，还要用其他的干什么。<br>·　　在这里我仅说一下我的理解：</p><ol><li><strong><code>synchronized</code>方法是最能解决线程安全问题的方法，因为多线程能够安全地操作同一块内存地址的区域，这是其他方法做不到的。</strong> 但是这个方法弊端也很明显，多线程串行执行一个任务，效率极低(当然现在的锁进行了很多的优化措施，至少不会让某个线程在一个任务上长时间阻塞了，这个不是重点)。</li><li>非阻塞同步方法解决了线程串行的问题，但是存在ABA隐患(这也不是重点，所谓ABA请自行搜索啦)。</li><li><code>ThreadLocal</code>方法，它并不能解决一部分的线程安全问题，因为就算你使用了<code>ThreadLocal</code>，你也无法阻止多线程操作同一块内存空间的隐患，而<code>ThreadLocal</code>却解决了在web领域的一个重大的问题：<strong><font color="red">各线程的独立操作共享数据</font></strong>。</li></ol><h1 id="ThreadLocal使用场景解释"><a href="#ThreadLocal使用场景解释" class="headerlink" title="ThreadLocal使用场景解释"></a>ThreadLocal使用场景解释</h1><p>·　　很多小伙伴都懵逼了，“独立操作共享数据”是什么意思？其实很简单，我这里的解释需要涉及一点Servlet的知识才可以懂。</p><ul><li><font color="brown"><strong>ThreadLocal是干嘛的</strong></font><br>·　一句话总结：<code>ThreadLocal实例</code>能够把某个对象与当前<code>thread</code>绑定。于是在任何时刻，当前<code>thread</code>都能通过<code>ThreadLocal</code>获得该对象。</li><li><font color="brown"><strong>Servlet的线程安全问题</strong></font><br>·　我们都知道原生的Servlet是单例的，会产生线程安全问题，但是这具体是怎么产生的呢？这里给出一个例子：当线程A和线程B同时去访问同一个Servlet，并同时给<code>request</code>域对象中设置了 相同的键 和 不同的值，这时候，这两个线程就会抢夺资源，导致最终转发给用户的<code>reques</code>t可能并不是用户想要的。</li><li><font color="brown">**Servlet安全问题的解决思路**</font>·　如果，线程A和线程B能够独立操作该Servlet中的`request`对象，操作的方式仅对自己的线程的可见，这样这条线程在整个“客户端--服务端--客户端”的流程中，都能保存数据的一致性。**所以，解决方法就是：每个线程都会创建一个仅对自己可见的`request`代理对象，当线程死亡后，该`request`代理对象也随之销毁。** 而<font color="red">“创建一个仅对自己可见的`request`代理对象”，就需要用到我们的`ThreadLocal`。</font></li><li><font color="brown"><strong>ThreadLocal使用场景的思考</strong></font><br>·　可见，<code>ThreadLocal</code>方法，<strong>并不能实现多线程安全操作共享变量(如果不新建Request代理对象，就会依然存在安全问题，因为Request对于多线程而言还是单例的)</strong>，所以我认为它不能解决所有线程安全问题，(但是，它的优势在于：<strong>每个线程看似都能并发地独立”修改”某个共享变量(将<code>thread</code>与这个共享变量的代理对象绑定)，极大地提高时间利用率</strong>。<br>·　关于我的对线程安全的理解，我举个很通俗的比方，耳熟能详的 “生产者 —- 产品 —- 消费者” 问题上，<code>ThreadLocal</code>就不能帮我们解决线程安全问题，因为创建产品的代理对象没有意义。而在上述的Servlet问题中，我们并不关心线程间操作<code>request</code>的顺序是什么样的，我们只需要各线程能且只能看到自己的数据而已。</li><li><font color="brown"><strong>个人的理解</strong></font><br>·　根据我的理解，<code>threadLocal</code>被设计出来主要是用来解决并发条件下的数据隔离问题，是用空间换取时间的一种手段。<strong>其实归根结底，threadLocal用来解决Servlet的线程安全问题，理念上就是用了多例模式而已(给共享变量创建副本)，只不过这多出来的‘例’仅对当前线程可见</strong>。不过也不尽然，如果我们非要把与某个线程绑定的对象再与其他线程绑定也是没有问题的，但这就失去了使用<code>threadLocal</code>的意义，我们一般只会把某个对象与特定的一个<code>thread</code>绑定，这样我们就可以通过这个<code>thread</code>在任何时刻访问到这个对象，而其他<code>thread</code>无法做到。这意味着<strong>threadLocal使用场景并不局限在解决线程安全的问题上</strong> ：我们从数据库连接池获取连接的时候，我们只希望一条线程在它的生命周期内只能获取到一个连接对象，且这个连接对象在线程死亡前不会被释放。这就需要我们用threadLocal在当前线程第一次申请连接时，将某个池里的连接与当前线程绑定，以后每次要申请连接，该线程都只会得到这个连接，在线程死亡后，连接被归还。</li><li><font color="red">**一句话总结：两种情况下需要用`threadLocal`**</font></li></ul><ol><li>每个线程希望操作自己独有的对象，如<code>Request</code>对象</li><li>在一个线程中，同一个对象需要在多个方法中共享，如进行事务管理时，某个业务操作需要用到多个DAO方法，这些方法我们希望使用同一个<code>Connection</code>对象。</li></ol><h1 id="ThreadLocal结构的简单说明"><a href="#ThreadLocal结构的简单说明" class="headerlink" title="ThreadLocal结构的简单说明"></a>ThreadLocal结构的简单说明</h1><ul><li><font color="brown"><strong>什么是ThreadLocal</strong></font><br>·　一句话总结：本地线程副本<br>·　这句话有一层重要含义：<code>threadLocal</code>不特定属于某个线程，它用来管理所有的本地线程。也就是说，<font color="red"><strong>threadLocal本身是一个全局变量，每个线程通过它来获得仅对自己可见的局部变量</strong>。</font><br>·　用刚才Servlet的问题来举个例子（并不准确，但是便于理解）：出现安全问题是因为多线程共同访问了同一个Request对象，但是我们使用了ThreadLocal之后，<strong>每个线程都只会去访问一个<code>ThreadLocal&lt; Request &gt;</code>对象，并从这个对象中获取只对当前线程可见的Request代理对象。</strong><br>·　这意味着，一个线程其实可以从多个ThreadLocal对象中获取相对应的多个值。即：每个线程既可以通过ThreadLocal&lt; Request &gt;对象获得自己的Request代理对象，也可以同时通过<code>ThreadLocal&lt; Connection &gt;</code>对象获取自己的数据库连接对象。只不过这两者的使用理念不同，<strong>前者主要是为了保证多线程之间的数据隔离，后者主要是为了保证对象在单线程中对多方法共享</strong>。</li></ul><h2 id="对象是如何与线程相绑定的"><a href="#对象是如何与线程相绑定的" class="headerlink" title="对象是如何与线程相绑定的"></a>对象是如何与线程相绑定的</h2><p>·　 一句话总结：通过ThreadLocal的内部类<code>ThreadLocalMap</code>。<br>·　 下面是Thread源码的一部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>·　　由源码可知，在Thread内部有一个由ThreadLocal维护的<code>ThreadLocalMap</code>对象。因此我们可知，实现绑定的关键在于这个<code>ThreadLocalMap</code>类，下面是其一部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">        * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">        * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">        * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">        * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">        * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">           <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">           Object value;</span><br><span class="line"></span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               <span class="keyword">super</span>(k);</span><br><span class="line">               value = v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The table, resized as necessary.</span></span><br><span class="line"><span class="comment">        * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> Entry[] table;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　由源码可知，<strong><code>ThreadLocalMap</code>本质上是一个<code>Entry</code>数组</strong>，Entry又是其内部类。这个内部类的key是一个threadLocal的弱引用(super(k))，value是我们要与当前线程绑定的对象。<br>·　　因此，我们可以简要的画出ThreadLocal的结构图：<br><img src="https://img-blog.csdnimg.cn/20190924110421984.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>·　在这个图里有几点必要重要的信息：</p><ol><li>全局的<code>ThreadLocal</code>对象在整个存储的结构中，是作为一个key而存在的，而且还是这个key的弱引用。</li><li>Map是每个线程独有的，和全局的ThreadLocal不存在从属关系，也就是说，这个map里可以存放多个不同的ThreadLocal对象作为key，这些ThreadLocal对象对于线程的ThreadLocalMap而言是同级的。(虽然很基础，但是我还是提一嘴，这个内部类是静态的，所以ThreadLocalMap本质上不特定属于某一个ThreadLocal对象)</li></ol><h2 id="深入理解的注意事项"><a href="#深入理解的注意事项" class="headerlink" title="深入理解的注意事项"></a>深入理解的注意事项</h2><p>·　　在讲ThreadLocal如何进行线程的绑定等一系列操作前，我们还是先缕清一些问题。</p><ul><li><font color="brown"> <strong>为什么使用弱引用</strong></font><br>·　本人在做了一些研究之后，给大家简单地解释一下：在上图中，我们可以明显的看到<strong>ThreadLocal对象有两条对其的引用，一条来自外界的引用，一条来自内部Entry对其的引用</strong>，因为内部引用的释放我们一般是不愿意去操作的（因为太底层了），因此我们<strong>希望只要释放ThreadLocal的外部引用，这个ThreadLocal实例就能被垃圾回收</strong>。但是，如果内部引用是强引用，那么即使外部引用被释放了，也有一条强引用链：<strong>“CurrentThread Ref —- CurrentThread —- ThreadLocalMap —- Entry —- Entry.key —- ThreadLocal”</strong> 这样我们就无法有效地回收ThreadLocal了，久而久之GC如果一直回收不掉这个实例，而我们又不使用这个ThreadLocal了，那就导致了内存泄漏，很容易造成OutOfMemory异常。<strong>但是，如果这条强引用链最后的引用变成了弱引用，那GC就能顺利释放掉ThreadLocal对象了（GC会回收掉只有弱引用引用的对象）</strong>。如果想进一步了解Java内存泄漏的情况，可以看一下我的另一篇博客：<a href="https://memoforward.github.io/2019/09/25/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AJava%E4%B8%AD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/" target="_blank" rel="noopener">HashMap为什么会出现内存泄漏问题 以及 Java中引用类型的存储位置</a>。</li><li><p><font color="brown"><strong>使用了弱应用就不存在内存泄漏的问题了吗</strong></font><br>·　显然不是，从图中很容易看出，即使ThreadLocal对象被释放掉了，与线程绑定的Entry的Value并没有被释放掉，而我们也不会再使用这个Entry了，这同样也是内存泄漏的问题（这里的强引用链就不写了）。为了避免这样的问题，<strong>在释放掉ThreadLocal的外部引用前，我们一般会利用ThreadLocal对象先把这个Entry对Value的强引用释放掉</strong>，这就是在下一章要提到的threadLocal.remove()方法。</p></li><li><p><font color="brown"><strong>为什么要使用ThreadlLocal进行对象与线程的绑定</strong></font><br>·　仔细想一想，如果让我们自己设计，我们可能会想着直接用线程去绑定某个对象：在线程内部维护一个<code>List&lt;HashMap&lt;T,V&gt;&gt;</code>的结构：T表示要绑定的对象类型，V是这个对象实例的引用。但是仔细一想，这样做实在是不精明，因为首先这个结构过于复杂，其次并非所有线程都需要这个List来保存本地变量副本的(如用synchronized去保证线程安全的情况)，而HashMap的构造必需分配内存空间，当线程量多的时候造成的内存空间浪费将会十分严重。而我们反观ThreadLocalMap的设计，首先结构简单，其实Thread类维护的这个Map采用懒加载的方式，不使用的话就不会在堆空间中分配内存，可谓是鬼斧神工。</p></li></ul><h1 id="ThreadLocal部分源码"><a href="#ThreadLocal部分源码" class="headerlink" title="ThreadLocal部分源码"></a>ThreadLocal部分源码</h1><p>·　　本节内容十分简单，主要涉及到ThreadLocal自身的<strong>set(), get(), remove()</strong> 方法。假设我们的对象为<code>ThreadLocal&lt;?&gt; tl = new ThreadLocal&lt;&gt;();</code> 代码的详解，请参考这篇博客：<a href="https://blog.csdn.net/fengcaho0616/article/details/79154697" target="_blank" rel="noopener">(转载)ThreadLocal实现原理</a>，我这里仅仅只是概括而已。</p><ul><li><font color="brown"> **tl.set()**</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　这源码再清晰不过了：获取当前线程对象，并得到其内部维护的map，并把要绑定的对象放入map，其键为this，表示threadLocal对象的弱引用。createMap(t, value)体现了懒加载的特性，源码就不贴了，就是分配内存空间，这里主要看一下<strong>map.set(this，value)</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">          <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">          <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">          <span class="comment">// path would fail more often than not.</span></span><br><span class="line">          Entry[] tab = table;</span><br><span class="line">          <span class="keyword">int</span> len = tab.length;</span><br><span class="line">          <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">               e != <span class="keyword">null</span>;</span><br><span class="line">               e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">              ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                  e.value = value;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  replaceStaleEntry(key, value, i);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">          <span class="keyword">int</span> sz = ++size;</span><br><span class="line">          <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">              rehash();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>·　这里再详细的源码就不贴了，我说明一下map.set做了什么事情：</p><ol><li><font color="red">这里必须说明一下，threadLocalMap采用线性探测的方式向Entry数组里填入数据</font>，至于什么线性探测这里不细说了，这是解决hash冲突的最简单的方式。</li><li>如果Entry数组中有key（代码里是k）与set的key一样，则直接用新value覆盖掉原value</li><li>如果发现有Entry数组中无效槽<code>k==null</code>，则替换掉这个无效槽，并把key，value填入</li><li>若Entry数组中所有槽均有效，则在连续段末尾处放入key，value，随后检测一下这个Entry数组是否需要扩容。</li><li>至于<code>key.threadLocalHashCode</code>，这是一个魔数，这里不细说。数学是美妙的，一般底层程序中经常会出现类似的魔数。</li></ol><ul><li><font color="brown"> **tl.get()**</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　这个代码就更简单了：当前线程的Map通过这个threadLocal对象获得了与其绑定的值，这与我们第二节的理解完全一致，<strong>不过再强调一遍加深印象：一个threadLocal实例只能保证一个对象与当前线程绑定，这个线程要与多个对象绑定，最好把这些对象封装起来(比如Servlet的域对象们，SpringMVC的源码似乎就是这么做的)。</strong><br>·　　如果这个map还没有初始化的话，会执行：<code>setInitialValue();</code>，该操作新建一个表，并把此null赋值给<code>Entry.value</code></p><ul><li><font color="brown"> **tl.remove()**</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　这里同样不继续看<code>m.remove(this)</code>的源码了，这里的remove主要就干一件事：<code>Entry.value = null</code>。保证了这个Value对象能被垃圾回收器及时回收。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　ThreadLocal的设计十分巧妙，通过自身的对象去实现线程与数据之间的绑定，而这个绑定又以自己的弱应用作为key，这极大程度上简化了本应该很复杂的数据结构，因为这巧妙地解决了与线程绑定的对象数据类型不确定这个问题，否则就要用我上面提到的<code>List&lt;HashMap&lt;T,V&gt;&gt;</code>来存储。我仍不是很清楚设计师是怎么想出来这种设计模式的，也不知道这种设计理念是什么，总之路漫漫其修远兮，吾将上下而求索。</p><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇文章深入探讨了ThreadLocal的实现以及使用场景&lt;br&gt;本文章全部基于个人理解，如有错误请邮箱联系本人，多谢&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>SpringJDBC模板的使用以及实现事务管理</title>
    <link href="http://yoursite.com/2019/09/04/SpringJDBC%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/04/SpringJDBC%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</id>
    <published>2019-09-04T06:20:44.000Z</published>
    <updated>2020-03-07T12:25:14.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文主要涉及如下知识点：</p><ol><li>SpringJDBC模板实战</li><li>Spring基于XML配置实现事务管理</li><li>Spring基于注解配置实现事务管理</li></ol></blockquote><a id="more"></a><h1 id="SpringJDBC模板"><a href="#SpringJDBC模板" class="headerlink" title="SpringJDBC模板"></a>SpringJDBC模板</h1><p>·　　当还未接触到SpringJDBC模板以及Mybatis等框架时，我们一直在使用DButils来对JDBC进行封装操作，SpringJDBC模板和DButils的操作可以说是十分相似。所以我们操作起来几乎没有难度，相比DBUtils需要额外引入连接池才可以使用，Spring自己内置了连接池（<font color="red">DriverManagerDataSource</font>），可以说是十分方便。<br>·　　使用SpringJDBC模板需要的jar包是：<strong>spring-jdbc</strong><br>·　　与数据库交互需要使用:<strong>mysql-connection-java</strong></p><h2 id="使用SpringJDBC模板"><a href="#使用SpringJDBC模板" class="headerlink" title="使用SpringJDBC模板"></a>使用SpringJDBC模板</h2><p>·　　使用SpringJDBC模板特别简单，只需要两个步骤：</p><ol><li>配置DriverManagerDataSource连接池，并注入jdbcTemplate对象</li><li>使用JdbcTemplate对象来进行数据库的交互<ul><li>JdbcTemplate的使用几乎和dbutils一样，查询用query，增删改用update，参数也是差不多。其中查询操作，DButils使用的返回值接口是ResultSetHandle&lt; T &gt;,而Spring所用的接口是RowMapper&lt; T &gt;，我们一般用其实现类<font color="red">BeanPropertyRowMaper&lt; T &gt; </font></li></ul></li></ol><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul><li>引入jar包,Maven依赖如下</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用于Spring整合tesng测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.testng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testng<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用SpringJDBCTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>把DataSource和jdbcTemplate交给SpringIOC去管理（非自己定义的bean用xml创建），同时开启组件扫描，xml完整配置如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contxt</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contxt:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springaop"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>创建数据库springaop，并创建客户表t_account</li></ul><div class="table-container"><table><thead><tr><th>id</th><th>aname</th><th>money</th></tr></thead><tbody><tr><td>1</td><td>cxy</td><td>2000.0</td></tr><tr><td>2</td><td>lhw</td><td>2000.0</td></tr></tbody></table></div><ul><li>编写Account端的操作，只编写通过客户姓名查询以及更新客户的操作（因为事务管理要用）</li></ul><p><strong>//AccountDao</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.memoforward.domain.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>//AccountDaoImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>...;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"accountDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; aList = jdbcTemplate.query(<span class="string">"select * from t_account where aname = ?"</span>, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account<span class="class">.<span class="keyword">class</span>), <span class="title">accountName</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(aList.size() != <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"查询失败..."</span>);</span><br><span class="line">        <span class="keyword">return</span> aList.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update t_account set aname=?,money=? where id = ?"</span>,account.getAname(),account.getMoney(),account.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>`　　可见，SpringTemplate还是相当简单的，没有什么特殊的思想，对开发来说并没有方便很多，这里就不进行测试了。<br>·　　<font color="red">这里注意一下：</font><del>JDBC实现了threadLocal，所以即使它是单例的，也是线程安全的 (说实话我不是很懂….，以后成长起来再来解释一下)</del>，它会根据当前的线程去取数据库的连接。</p><h1 id="Spring实现事务管理"><a href="#Spring实现事务管理" class="headerlink" title="Spring实现事务管理"></a>Spring实现事务管理</h1><p>·　　有关事务管理的内容，不是本博客的重点，本篇文章只是略微介绍一下Spring事务管理的使用（因为这个是相当的方便）。Spring事务管理是基于AOP的，用来增强业务层的业务逻辑，有兴趣可以参考我关于AOP的教程：<a href="https://memoforward.github.io/2019/08/31/SpringIOC%E5%AE%9E%E6%88%98%EF%BC%88xml-%E6%B3%A8%E8%A7%A3%EF%BC%89/" target="_blank" rel="noopener">SpringAOP实战</a>。</p><h2 id="进行事务管理的原因"><a href="#进行事务管理的原因" class="headerlink" title="进行事务管理的原因"></a>进行事务管理的原因</h2><p>·　　虽然不着重讲事务管理的细节，但是这里给出一个特别经典的案例：<strong>转帐案例</strong>，来表明事务管理的重要性。<br>·　　我们在业务层实现一个转账方法，并设置一点小细节：模拟在转账过程中的停电事件，停电的时间点在：甲方已经转账成功，但乙方还未收到钱。停电事件用一个flag控制。<br>业务层实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>...;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Double money, <span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">        Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">        source.setMoney(source.getMoney() - money);</span><br><span class="line">        target.setMoney((target.getMoney() + money));</span><br><span class="line">        accountDao.update(source);</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"断电了...."</span>);</span><br><span class="line">        accountDao.update(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们设置flag为true，并进行转账：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTranser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    accountService.transfer(<span class="string">"cxy"</span>,<span class="string">"lhw"</span>,<span class="number">1000.0</span>,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库里的金额就变成了：可见1号的钱少了，结果2号的钱没多。</p><div class="table-container"><table><thead><tr><th>id</th><th>aname</th><th>money</th></tr></thead><tbody><tr><td>1</td><td>cxy</td><td>1000.0</td></tr><tr><td>2</td><td>lhw</td><td>2000.0</td></tr></tbody></table></div><p>造成这种现象的原因很简单，因为<B>：业务层会调用持久层（DAO）的方法，默认情况是：每次dao层的方法执行结束之后，事务都被自动提交了。</B><br>·　　因此，就需要对这个转账方法进行事务的管理：开启事务，如果异常就回滚，不异常就用提交，最后是释放连接。我在之前的文章里，用动态代理实现了事务管理，有兴趣可以参考一下：<a href="https://memoforward.github.io/2019/09/01/Java%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%A7%A3%E9%87%8A/" target="_blank" rel="noopener">Java两种动态代理实战+动态代理死循环的解释</a>。<br>·　　因为Spring中声明事务管理是基于aop的，所以很显然，事务管理的内容必然就是一个advice通知。而相比普通的切面，事务管理很常用，因此spring就自己把其封装了。</p><h2 id="xml的事务管理配置"><a href="#xml的事务管理配置" class="headerlink" title="xml的事务管理配置"></a>xml的事务管理配置</h2><ul><li>首先还是要引入相应的jar包：<strong>spring-tx和aspectjweaver</strong>，一个是事务管理的依赖，一个是用于识别切入点表达式。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置步骤：</li></ul><ol><li>配置事务管理器(DataSourceTransactionManagement)并注入Datasource。（事务管理器的接口是PlatformTransactionManagement）</li><li>配置事务通知&lt; tx:advice &gt;并将事务管理器添加至标签属性</li><li>配置aop，写切入点表达式并用&lt; aop: advisor &gt;引入事务通知</li><li>在事务通知下配置子标签&lt; tx:attributes &gt; ，在&lt; tx:attrributes &gt;标签下用&lt; tx:method &gt;配置业务方法（只有配置了切入点才能知道增强哪个包的方法，因此这步在最后）</li></ol><ul><li>xml配置如下：注意事务管理是业务层的和持久层没有关系。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contxt</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contxt:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 1.配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManagement"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 2.配置事务通知并引入事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span>  <span class="attr">transaction-manager</span>=<span class="string">"txManagement"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4.配置事务增强属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 6.对不同的方法进行不同的事务管理--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3.开启aop并引入事务通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.memoforward.service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springaop"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>关于&lt; tx:method &gt;的属性：这个标签是针对不同的方法进行不用的事务增强而设计出来的，spring为其提供了6种属性：</li></ul><div class="table-container"><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>isolation</td><td>用于指定事务的隔离级别。默认是数据库的默认隔离级别。</td></tr><tr><td>propagation</td><td>用于指定事务的传播行为。默认值是：REQUIRED，表示一定会开启事务。也有SUPPORTS表示支持当前事务（如果当面没有事务，则不开启事务），一般用于查询方法。</td></tr><tr><td>read-only</td><td>用于指定事务是否只读。只有查询方法才能是true。</td></tr><tr><td>timeout</td><td>用于指定事务的超时时间，默认是-1，表示永不超时。设置的单位级别是秒。</td></tr><tr><td>rollback-for</td><td>用于指定一个异常，当产生该异常时，事务回滚，产生其他异常，事物不回滚。不设置则所有异常都回滚 。</td></tr><tr><td>no-rollback-for</td><td>用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常，事物回滚。不设置则所有异常都回滚 。</td></tr></tbody></table></div><ul><li>结果：这就不进行测试了，因为非常简单。当配置了如上的事务后，在“转账”操作未结束的时候，所有的dao方法都不会提交，因此保证了转账的安全性。</li></ul><h2 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h2><p>·　　Spring事务管理同样也可以进行注解配置，注解配置比较简单，但是有不方便的地方。<br>·　　Spring进行注解配置的步骤是：</p><ol><li>配置事务管理器</li><li>开启Spring对注解配置事务的支持（&lt; tx:annotation-driven &gt;）,纯注解配置的话在配置类上用@EnableTransactionManagement来开启。</li><li>在需要事务支持的地方使用@Transactional，其属性就是上述标签&lt; tx:method &gt; 的属性。这个注解用在类上表示此种事务对该类的所有方法都生效；用在方法上表示：此种事务仅对该方法生效。<font color="red">注意：</font>我还不太清楚如果使用该注解对不同的事务管理器进行操作。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contxt</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contxt:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManagement"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"txManagement"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springaop"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其业务层改为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(readOnly = <span class="keyword">true</span>, propagation = Propagation.SUPPORTS)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(readOnly = <span class="keyword">false</span>, propagation = Propagation.REQUIRED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Double money, <span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">        Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">        source.setMoney(source.getMoney() - money);</span><br><span class="line">        target.setMoney((target.getMoney() + money));</span><br><span class="line">        accountDao.update(source);</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"断电了...."</span>);</span><br><span class="line">        accountDao.update(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果：进行了该注解配置后，转账操作也正常回滚了。</li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>·　　Spring声明式事务管理十分有用，用起来很方便，就是需要记忆的部分有点多，不过孰能生巧，多练多写才是王道。这里Spring有关业务层的内容就全部结束。我最近也变的很忙，关于java后台的学习笔记也要稍微停滞一段时间。闲暇之余可能会更新一些有关深度学习的内容（<del>为了毕业</del>），加油吧。</p><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文主要涉及如下知识点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SpringJDBC模板实战&lt;/li&gt;
&lt;li&gt;Spring基于XML配置实现事务管理&lt;/li&gt;
&lt;li&gt;Spring基于注解配置实现事务管理&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringAOP实战</title>
    <link href="http://yoursite.com/2019/09/02/SpringAOP%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2019/09/02/SpringAOP%E5%AE%9E%E6%88%98/</id>
    <published>2019-09-02T13:19:11.000Z</published>
    <updated>2020-03-07T12:24:54.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文主要涉及如下知识点</p><ol><li>SpringAOP的基本概念</li><li>基于XML配置的SpringAOP实战</li><li>基于注解配置的SpringAOP实战</li><li>环绕通知</li></ol></blockquote><a id="more"></a><h1 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h1><p>·　　AOP(Aspect Oriented Programming)面向切面编程，是OOP面向对象编程的升级，AOP是基于OOP的。OOP比较好理解，生活中万物都是对象，但是AOP乍一看不是很好理解。不过没关系，我稍微一点拨，肯定就能懂。<br>·　　说到底，其实就是“切面”这个概念我们不熟悉，我的理解是这样的：<strong>切面是某种对象的共同特征</strong>。什么意思呢？我举个简单的例子：我们一生中会玩很多的游戏，每个游戏都在不同的平台，那我们每次玩游戏，都要登录某个平台。<strong>面向对象编程的思维是这样的</strong>：我们这个人，就是一个对象，而我们玩游戏，就是这个对象使用了某种方法，所以在编程时我们把<B>“人”这个概念抽取成了对象，把“玩游戏”这个概念抽取成一个个不同的方法</B>。而在这个基础上，<strong>面向切面的编程方式</strong> 被提出了，因为我们发现，我们有无数种对应玩游戏的方法，但是每一种方法我们都需要进行登录的操作，所以我们把<B>“登录”这个操作抽取出来，称作是所有”玩游戏”方法的切面，而每个玩游戏的方法，就是一个个切入点</B>。<br>·　 　可见，“登录”是所有“玩游戏”方法的共同特征，所以切面这个概念不如对象一般直观，因为，所有的切面都是人为抽取出来的，具有一定的思考性。而<strong>面向切面编程</strong>最重要的两个优势在于：1.可以简化代码量；2.可以让业务代码仅关注业务逻辑，使代码结构更清晰。<br>·　　不管是哪一种优势，对于开发来说，都是至关重要的。</p><h1 id="切面的一些专业术语"><a href="#切面的一些专业术语" class="headerlink" title="切面的一些专业术语"></a>切面的一些专业术语</h1><p>·　　SpringAOP的实现是基于动态代理的，本人写过一遍有关动态代理的教程：<a href="https://memoforward.github.io/2019/09/01/Java%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%A7%A3%E9%87%8A/" target="_blank" rel="noopener">Java两种动态代理实战+动态代理死循环的解释</a>。<br>·　　要会看的懂SpringAOP的相关文档就必须懂有关切面的相关术语，<strong>首先Aspect就是切面</strong>的意思。这<del>个要是不知道，就快先去把6级考了再说。**</del><br><strong>术语如下：</strong></p><div class="table-container"><table><thead><tr><th>术语</th><th>含义</th></tr></thead><tbody><tr><td>joinpoint 连接点</td><td>可以被拦截到的方法，但不一定会被增强</td></tr><tr><td>pointcut 切入点</td><td>被增强的方法（可见切入点一定是连接点，而反之则不然）</td></tr><tr><td>advice 通知（增强）</td><td>指在拦截到切入点后，如何增强某个方法</td></tr><tr><td>target</td><td>指被代理的对象</td></tr><tr><td>weaving 织入</td><td>指一个过程：增强某个类并形成代理类的过程</td></tr><tr><td>proxy 代理</td><td>一个类被织入后，就生成了一个代理类</td></tr><tr><td>aspect 切面</td><td>指切入点和通知的结合</td></tr></tbody></table></div><p>·　　如果你能把上述玩游戏的例子和这里的术语对应上，那你术语部分就过关啦！<br><strong>其中advice术语是实现aop的关键，其有五种通知类型：</strong></p><ul><li>１．前置通知（before）：只在原方法之前调用的增强</li><li>２．后置通知（after-returning）：原方法完成之后调用的增强</li><li>３．异常通知（after-throwing）：原方法出异常后调用的增强</li><li>４．最终通知（after）：不管怎么样都会调用的增强，最后才会调用</li><li>５．环绕通知（around）：通过写代码来实现对切入点的管理（以上一般都是用配置，来决定顺序），环绕通知一般用于注解开发。</li></ul><h1 id="SpringAOP实战"><a href="#SpringAOP实战" class="headerlink" title="SpringAOP实战"></a>SpringAOP实战</h1><p>·　　本来想搞利用aop实现事务的管理的，不过既然在开头用了玩游戏的例子，那么索性，这里的案例就用玩游戏了。<br>·　　<strong>需求如下</strong>：玩家只需要关注玩游戏就行。代理类的任务在于：在玩游戏<strong>之前实现登录操作</strong>，游戏结束<strong>后执行退出操作</strong>，如果玩游戏途中<strong>出现了游戏BUG，就执行回档操作（异常）</strong>，最终不管怎么样，玩游戏是要钱的，<strong>最后要执行扣钱操作。</strong></p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>·　　引入jar包，<strong>aop需要的jar包是aspectjweaver</strong>，用于解析切入点表达式（下文会讲）以及spring-aop（这个一般引入spring-context依赖就会自己引入了），然后什么ioc的包等等，我就不说了，这次案例会用到一点点的IOC的知识，如果不会，可以参考我的IOC教程<a href="https://memoforward.github.io/2019/08/31/SpringIOC%E5%AE%9E%E6%88%98%EF%BC%88xml-%E6%B3%A8%E8%A7%A3%EF%BC%89/" target="_blank" rel="noopener">SpringIOC实战（xml+注解）</a>。</p><ul><li>依赖如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置玩家类(由Spring进行管理)<br>可见我们希望切面能增强所有玩游戏的方法，而不增强吃饭这个方法，其中我们看见玩LOL时会出现异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.player;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playLOL</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩英雄联盟..."</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"LOL崩溃了...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playDota2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩Dota2..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playWOW</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩魔兽世界..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playTaiWu</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩太吾绘卷..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"游戏玩累了，吃饭..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置通知类（由Spring进行管理）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"playerAdvice"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerAdvice</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.登录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---1.游戏登录---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.退出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---2.游戏退出---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3/异常回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---3.游戏回档---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.扣钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loseMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---4.游戏扣费---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用XML配置切面"><a href="#用XML配置切面" class="headerlink" title="用XML配置切面"></a>用XML配置切面</h2><p>·　　使用SpringAOP需要在xml文件中引入aop的约束，这里就不贴了。<br>·　　关于XML配置，共有如下的几个标签需要用到。</p><div class="table-container"><table><thead><tr><th>标签名</th><th>属性</th><th>作用</th><th>层级</th></tr></thead><tbody><tr><td>aop:config</td><td>无</td><td>开启aop的控制</td><td>1</td></tr><tr><td>aop:pointcut</td><td>id：指切入点表达式的id；expression：写切入点表达式</td><td>告诉切面将增强哪些方法（切入点）</td><td>2或3</td></tr><tr><td>aop:aspect</td><td>id：该切面的id；ref：该切面对应的通知类</td><td>声明一个切面</td><td>2</td></tr><tr><td>aop : before</td><td>method：该前置通知对应在通知类中的方法；pointcut-ref：切入点表达式id / pointcut：切入点表达式</td><td>声明一个前置通知</td><td>3</td></tr><tr><td>aop : after-returning</td><td>和上面类似</td><td>声明一个后置通知</td><td>3</td></tr><tr><td>aop : after-throwing</td><td>和上面类似</td><td>声明一个异常通知</td><td>3</td></tr><tr><td>aop : after</td><td>和上面类似</td><td>声明一个最终通知</td><td>3</td></tr></tbody></table></div><ul><li><strong>有关切入点表示的补充</strong><br>·　 切入点表达式有关键字：execution。在关键字内部写表达式，规则是：<strong>（访问修饰符 返回值 全限定类名.方法名）</strong>，且不同的execution之间可以用<strong>and、or、！</strong>等关键字来增强表达式的逻辑。</li></ul><p><strong>举个例子</strong>：如果要切入点要选Player类中的playLOL方法，则表达式可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.memoforward.player.Player.playLOL())</span><br></pre></td></tr></table></figure><p>·　　显然这么写太复杂了，因此有如下的简化措施：</p><ol><li>访问修饰符可省略</li><li>返回值可以用通配符<B> * </B> 表示任意返回值类型</li><li>包名可以用 <B> * </B>表示任意一个包；用 <B> *. </B>表示当前包及其所有子包</li><li>类名和方法名都可以用<B> * </B>表示任意类和任意方法</li><li>可用 <B>(．.) </B>表示任意参数和任意参数类型（如果不想用用任意类型，基础类型可以直接写，引用类型用 ‘包名.类名’ 的方式）</li></ol><p>`　　因此有全通配写法：该项目下所有包的所有方法（不推荐使用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* *..*.*(..))</span><br></pre></td></tr></table></figure><ul><li>一般情况下：我们只需要切到业务层实现类下的所有方法就可以了。</li></ul><h2 id="xml配置文件如下"><a href="#xml配置文件如下" class="headerlink" title="xml配置文件如下"></a>xml配置文件如下</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;aop:pointcut id="pt2" expression="..."/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"playerAdvice"</span> <span class="attr">ref</span>=<span class="string">"playerAdvice"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.memoforward.player.*.*(..)) and !execution(* com.memoforward.player.*.eat(..))"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"login"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"quit"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"rollback"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"loseMoney"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>注意事项：</strong><ol><li>用了两个execution语句实现了增强 除了eat方法外的所有方法。</li><li>注意切入点表达式的位置：如果在&lt; aop: aspect &gt;标签内，则这个表达式只对这个切面生效；如果在切面标签外，则对所有切面生效，但其必须要声明在切面之前。</li></ol></li></ul><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:beans.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testSpringAOP</span> <span class="keyword">extends</span> <span class="title">AbstractTestNGSpringContextTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Player player;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAOP01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player.eat();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playDota2();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playTaiWu();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playWOW();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playLOL();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果如下：可见除了eat方法，其他方法都被增强了，而且出异常的LOL也成功进行了游戏回档。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">游戏玩累了，吃饭...</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩Dota2...</span><br><span class="line">--<span class="number">-2.</span>游戏退出---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩太吾绘卷...</span><br><span class="line">--<span class="number">-2.</span>游戏退出---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩魔兽世界...</span><br><span class="line">--<span class="number">-2.</span>游戏退出---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩英雄联盟...</span><br><span class="line">--<span class="number">-3.</span>游戏回档---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: LOL崩溃了....</span><br></pre></td></tr></table></figure><h2 id="基于注解的AOP开发"><a href="#基于注解的AOP开发" class="headerlink" title="基于注解的AOP开发"></a>基于注解的AOP开发</h2><ul><li>基于注解的开发有两个步骤：</li></ul><ol><li>在配置文件中开启aop自动代理权限</li><li>配置切面的通知类</li></ol><ul><li>配置文件开启权限</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置切面通知类：@Aspect；@Pointcut；以及各种通知注解，很简单。<br><strong>注意：切入点表达式需要把 and 换成 &amp;&amp;</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"playerAdvice02"</span>)</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerAdvice02</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.memoforward.player.*.*(..)) &amp;&amp; !execution(* com.memoforward.player.*.eat(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.登录</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---游戏登录---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.退出</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---游戏退出---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3/异常回滚</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---游戏回档---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.扣钱</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loseMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---游戏扣费---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试如下：此时已经换成了PlayerAdvice02切面。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ...;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:beans.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testSpringAOP</span> <span class="keyword">extends</span> <span class="title">AbstractTestNGSpringContextTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Player player;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAOP</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player.eat();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playTaiWu();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playLOL();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果如下</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">游戏玩累了，吃饭...</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩太吾绘卷...</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">--<span class="number">-2.</span>游戏退出---</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩英雄联盟...</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">--<span class="number">-3.</span>游戏回档---</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: LOL崩溃了....</span><br></pre></td></tr></table></figure><ul><li><font color="red"><b>问题</b></font><br>·　　仔细一点就能发现，<strong>最终通知和后置通知的顺序反了</strong>，这是注解开发的一个大问题，目前还没有被修复，因此如果要用注解开发的话，一般使用<strong>环绕通知</strong>的方式，所谓环绕通知和动态代理的实现方法基本没什么区别。下面将简单介绍一下：</li></ul><h2 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h2><p>·　　环绕通知和动态代理的内部几乎是一样的写法，不同的点在于：动态代理的参数包含了被代理类的字节码对象；而在环绕通知中，因为Spring已经管理的被代理的类，因此就不必我们手动提供了，取而代之的，是<strong>Spring提供的的一个接口：ProceedingJoinPoint</strong>，此接口有两个方法，一个是获取被代理类方法的参数，一个是调用被代理类的方法。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"pt1()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">playerAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        login();</span><br><span class="line">        obj = pjp.proceed(args);</span><br><span class="line">        quit();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="comment">//注意pjp对象的方法需要用Throwable来处理异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        rollback();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(throwable);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        loseMoney();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果如下：可见执行顺序已经恢复正常</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">游戏玩累了，吃饭...</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩太吾绘卷...</span><br><span class="line">--<span class="number">-2.</span>游戏退出---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩英雄联盟...</span><br><span class="line">--<span class="number">-3.</span>游戏回档---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: java.lang.RuntimeException: LOL崩溃了....</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　SpringAOP说难不难，但是重要的是这种面向切面的编程思想以及动态代理。Spring还剩最后一项事务管理。我会在下一次博客把它补上。</p><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文主要涉及如下知识点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SpringAOP的基本概念&lt;/li&gt;
&lt;li&gt;基于XML配置的SpringAOP实战&lt;/li&gt;
&lt;li&gt;基于注解配置的SpringAOP实战&lt;/li&gt;
&lt;li&gt;环绕通知&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
</feed>
