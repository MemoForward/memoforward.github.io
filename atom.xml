<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>MemoForward&#39;s Blog</title>
  
  <subtitle>阿星的学习笔记</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-08T03:48:21.594Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>MemoForward</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>LeetCode题解(一):10, 15, 57, 59</title>
    <link href="http://yoursite.com/2020/03/07/LeetCode%E9%A2%98%E8%A7%A3-%E4%B8%80-10-15-57-59/"/>
    <id>http://yoursite.com/2020/03/07/LeetCode%E9%A2%98%E8%A7%A3-%E4%B8%80-10-15-57-59/</id>
    <published>2020-03-07T12:30:14.000Z</published>
    <updated>2020-03-08T03:48:21.594Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目名称"><a href="#题目名称" class="headerlink" title="题目名称"></a>题目名称</h1><blockquote><p>第10题：正则表达式匹配(困难)<br>第15题：三数之和(中等)<br>第57题：和为s的连续正数序列(简单)<br>第59题：II.队列的最大值(中等)</p></blockquote><a id="more"></a><hr><h1 id="第10题：正则表达式匹配"><a href="#第10题：正则表达式匹配" class="headerlink" title="第10题：正则表达式匹配"></a><font color="red">第10题：正则表达式匹配</font></h1><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个字符串 s 和一个字符规律 p，请你来实现一个支持 <code>&#39;.&#39;</code>和 <code>&#39;*&#39;</code>的正则表达式匹配。</p><blockquote><p><code>&#39;.&#39;</code>匹配任意单个字符<br><code>&#39;*&#39;</code>匹配零个或多个前面的那个元素</p></blockquote><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ul><li>s 可能为空，且只包含从 a-z 的小写字母</li><li>p 可能为空，且只包含从 a-z 的小写字母，以及字符<code>&#39;.&#39;</code>和 <code>&#39;*&#39;</code></li></ul><h2 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　见到字符串匹配，字符串操作的题，第一反应就是DP。而且DP数组中的下标如<code>i</code>一般都代表匹配字符串的<code>0: i - 1</code>或者<code>i: len - 1</code>。<br>　　很显然，这道题可以用DP求解，<code>dp[i][j]</code>表示<code>p[0: j-1]</code>可以和<code>s[0: i - 1]</code>匹配。</p><h3 id="数组初始化"><a href="#数组初始化" class="headerlink" title="数组初始化"></a>数组初始化</h3><ul><li><code>dp[0][0] = true</code>: 因为<code>null</code>匹配<code>null</code></li><li><code>dp[0&lt; i &lt;= slen][0] = false</code>: p为<code>null</code>， 无法匹配任何值</li><li><code>dp[0][0&lt; j＜= plen]</code>: 这个初始化稍微复杂一点，因为例如<code>a*</code>或者<code>a*b*</code>这种都是可以匹配<code>null</code>的，因此我们用一个循环来初始化这种状态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态转移方程"><a href="#状态转移方程" class="headerlink" title="状态转移方程"></a>状态转移方程</h3><p>　　这题最难的地方在状态转移方程的求解，即如何求得<code>dp[i][j]</code>？</p><ol><li>第一种情况: <code>s[i - 1] == p[j - 1] ||　ｐ[j - 1] == &#39;.&#39;</code>，此时<code>dp[i][j] = dp[i - 1][j - 1]</code></li><li>第二种情况: <code>p[j - 1] == &#39;*&#39;</code>，分别有两种可能需要考虑: <ul><li><code>s[i - 1] == p[j - 2] || p[j - 2] == &#39;.&#39;</code>，此时又有三种情况，只要一种成立即可:<ul><li><code>*</code> 匹配0次: <code>dp[i][j] = dp[i][j - 2]</code>, 因为匹配0次的话，<code>p[0: j]</code>的作用等同于<code>p[0: j - 2]</code></li><li><code>*</code> 匹配1次: <code>dp[i][j] = dp[i][j - 1]</code>, 这个很容易理解</li><li><code>*</code> 匹配多次: <code>dp[i][j] = dp[i - 1][j]</code>, 这是最难理解的，因为如果<code>*</code>匹配了多次，则s字符串增加一个与<code>p[j - 2]</code>相同的数并无影响</li></ul></li><li><code>s[i - 1] != p[j - 2] || p[j - 2] != &#39;.&#39;</code>，此时只可能有一种情况:<ul><li><code>*</code> 只能匹配0次: <code>dp[i][j] = dp[i][j - 2]</code></li></ul></li></ul></li><li>其他情况: <code>dp[i][j] = false</code></li></ol><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isMatch</span><span class="params">(String s, String p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> slen = s.length(), plen = p.length();</span><br><span class="line">        <span class="comment">// dq[i][j] means p[0 : j] matches s[0 : i]</span></span><br><span class="line">        <span class="keyword">boolean</span>[][] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[slen + <span class="number">1</span>][plen + <span class="number">1</span>]; </span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)</span><br><span class="line">            <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>) dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= slen; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= plen; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(s.charAt(i - <span class="number">1</span>) == p.charAt(j - <span class="number">1</span>) || p.charAt(j - <span class="number">1</span>) == <span class="string">'.'</span>)</span><br><span class="line">                    dp[i][j] = dp[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(p.charAt(j - <span class="number">1</span>) == <span class="string">'*'</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(p.charAt(j - <span class="number">2</span>) == <span class="string">'.'</span> || p.charAt(j - <span class="number">2</span>) == s.charAt(i - <span class="number">1</span>))&#123;</span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">2</span>] || dp[i][j - <span class="number">1</span>]; </span><br><span class="line">                    &#125;<span class="keyword">else</span> dp[i][j] = dp[i][j - <span class="number">2</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[slen][plen];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: <script type="math/tex">O(MN)</script> </li><li>空间复杂度: <script type="math/tex">O(MN)</script></li></ul><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>　　本题还可以用回溯法做，但是笔者特别讨厌用递归，虽然递归用起来很简洁，但是空间利用率实在是太感人了，计算起来也十分麻烦。笔者曾经用递归写过一个项目的方法，出现堆栈溢出问题的时候简直崩溃，因此立下flag：能不用递归就不用递归。因此回溯的算法就不写了。<br><strong>回溯法思路：</strong></p><ul><li>首字符匹配，且p的后一字符不是<code>*</code> : 匹配<code>(s.substring(1), p.substring(1))</code></li><li>首字符匹配，且p的后一字符是<code>*</code> : 匹配<code>(s, p.substring(2)) ||　(ｓ.substring(1), p)</code></li><li>首字符不匹配，且p的后一字符是<code>*</code> : 匹配<code>(s, p.substring(2))</code></li><li>递归出口:  <ul><li>首字符不匹配，且p的后一字符不是<code>*</code> : <code>return false</code></li><li>p为空: <code>return s为空</code></li><li>这里注意一下，s为空并不作为出口，而作为(首字符不匹配)的情况</li></ul></li></ul><h3 id="遇到过的问题"><a href="#遇到过的问题" class="headerlink" title="遇到过的问题"></a>遇到过的问题</h3><ul><li>将<code>*</code>看成了匹配零次或无数次任意字符，导致直接做错</li><li>匹配多次的方程没想出来</li></ul><hr><p>　</p><h1 id="第15题：三数之和"><a href="#第15题：三数之和" class="headerlink" title="第15题：三数之和"></a><font color="red">第15题：三数之和</font></h1><h2 id="题目描述-1"><a href="#题目描述-1" class="headerlink" title="题目描述"></a>题目描述</h2><p>给你一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？请你找出所有满足条件且不重复的三元组。</p><p><strong>注意:</strong> 答案中不可以包含重复的三元组。</p><h2 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　这道题最主要的就是要想到用双指针的方法去求解twoSum，想到了就很简单。写博客的时候不小心写上了，改名字有点费事，所以就贴个代码上去。暴力求解这种基本谁都能想到，但是如果用暴力去做算法题的话，就失去了做算法题的意义，不是吗？</p><h3 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; threeSum(<span class="keyword">int</span>[] nums) &#123;</span><br><span class="line">        <span class="comment">// O(nlgn)</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// O(n^2)</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i-<span class="number">1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> target = -nums[i], left = i+<span class="number">1</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &lt; right)&#123;</span><br><span class="line">                <span class="keyword">int</span> twoSum = nums[left] + nums[right];</span><br><span class="line">                <span class="keyword">if</span>(twoSum == target)&#123;</span><br><span class="line">                    ans.add(Arrays.asList(nums[i], nums[left], nums[right]));</span><br><span class="line">                    <span class="keyword">while</span>(left + <span class="number">1</span> &lt; nums.length - <span class="number">1</span> &amp;&amp; nums[left] == nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(right - <span class="number">1</span> &gt; i + <span class="number">1</span> &amp;&amp; nums[right] == nums[right-<span class="number">1</span>]) right--;</span><br><span class="line">                    left++;right--;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(twoSum &gt; target) right--;</span><br><span class="line">                <span class="keyword">else</span> left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: <script type="math/tex">O(N^2)</script></li><li>空间复杂度: <script type="math/tex">O(1)</script></li></ul><hr><h1 id="第57题-和为s的连续正数序列"><a href="#第57题-和为s的连续正数序列" class="headerlink" title="第57题: 和为s的连续正数序列"></a><font color="red">第57题: 和为s的连续正数序列</font></h1><h2 id="题目描述-2"><a href="#题目描述-2" class="headerlink" title="题目描述"></a>题目描述</h2><p>输入一个正整数 target ，输出所有和为 target 的连续正整数序列（至少含有两个数）。</p><p>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p><h2 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　这道题比较简单，采用滑动窗口法进行计算即可。笔者不擅长解答除了找规律外的数学问题，所以数学解法就不考虑了。数学解法固然巧妙，但是我为了找工作而刷题，就不需要整这些花里胡哨的了，只需要保证时间空间复杂度尽可能少一些就ok。</p><h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] findContinuousSequence(<span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">2</span>;</span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; ans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(target == <span class="number">1</span>) ans.add(<span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right &amp;&amp; right &lt;= target / <span class="number">2</span> + <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = (left + right) * (right - left + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">                <span class="keyword">int</span>[] temp = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = left; i &lt;= right; i++) temp[i - left] = i;</span><br><span class="line">                ans.add(temp);</span><br><span class="line">                right++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(sum &gt; target) left++;</span><br><span class="line">            <span class="keyword">else</span> right++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>[][]) ans.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[ans.size()][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度: <script type="math/tex">O(N)</script></li><li>空间复杂度: <script type="math/tex">O(N)</script>: 使用了一个数组来临时存储序列</li></ul><h2 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><p>　　这道题很简单，但是笔者一开始并没有想到用滑动窗口法去解决问题，我第一反应是先固定左端的数，然后用二分查找的算法去找右边的数。算法是没错的，时间复杂度<code>O(NlgN)</code>也算马马虎虎，但是死活提交不过。后来Debug才发现，原来是计算的<code>sum</code>越界了，<code>int</code>最大能取到<font color="brown">$ 2^{31} - 1 = 2147483647 = 0x7fffffff $</font>, 如果再加1，就会变最小负值，然后就一直是负数了，除非再加一次最大值。随便举个例子: 计算<code>1, 2, 3,..., 8000000</code>就越界了。</p><hr><h1 id="第59题：II-队列的最大值"><a href="#第59题：II-队列的最大值" class="headerlink" title="第59题：II.队列的最大值"></a><font color="red">第59题：II.队列的最大值</font></h1><h2 id="题目描述-3"><a href="#题目描述-3" class="headerlink" title="题目描述"></a>题目描述</h2><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。</p><p>若队列为空，pop_front 和 max_value 需要返回 -1</p><h2 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h2><p>　　这道题卡了我很久，原因是我忽略了<strong>均摊时间复杂度的含义</strong>: 进行N次操作，其每次操作的平均复杂度为O(1)。<br>　　要解决这道题有两个很重要的点: </p><ol><li>只要插入了一个最大值，在前面的值<code>pop_front</code>前，这个最大值就不会改变。</li><li>如何保证最大值被<code>pop</code>掉后，我们可以找到次大值？: 只需要将正常入队的序列进行某些操作后保存为一个<strong>非递增的辅助序列</strong>即可。<ul><li>解释：假设我们有序列<code>xAyBzC</code>，其中<code>A &gt; x; B &gt; y; C &gt; z; A &gt; B &gt; C</code>，那么辅助序列<code>ABC</code>就是在进行<code>max_value()</code>操作中只可能出现的三个最大值，因为有了<code>A</code>，前面的<code>x</code>就失去了价值，而<code>A</code>一旦被<code>pop</code>后，<code>A</code>前面的数就不会在序列里了，子序列<code>yBzC</code>中最大的就是<code>B</code>，以此类推。因此这是一个线性问题。</li></ul></li></ol><h2 id="完整代码-3"><a href="#完整代码-3" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span> </span>&#123;</span><br><span class="line">    Deque&lt;Integer&gt; aux;</span><br><span class="line">    Deque&lt;Integer&gt; dq;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MaxQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aux = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">this</span>.dq = <span class="keyword">new</span> LinkedList&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> aux.size() == <span class="number">0</span> ? -<span class="number">1</span> : aux.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        dq.addLast(value);</span><br><span class="line">        <span class="keyword">while</span>(aux.peekLast() != <span class="keyword">null</span> &amp;&amp; aux.peekLast() &lt; value) aux.pollLast();</span><br><span class="line">        aux.addLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dq.size() == <span class="number">0</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// Integer 没进入常量池，不能用 == 来判断</span></span><br><span class="line">        <span class="keyword">if</span>(dq.peek().equals(aux.peek())) aux.pollFirst();</span><br><span class="line">        <span class="keyword">return</span> dq.pollFirst();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="踩过的坑-1"><a href="#踩过的坑-1" class="headerlink" title="踩过的坑"></a>踩过的坑</h2><ol><li>没理解均摊复杂度</li><li>没想到用非递增的辅助序列</li><li>两个没有拆箱的<code>Integer</code>对象，不能用<code>==</code>来判断其<code>value</code>是否相等。(基于这点，笔者想要写一篇文章来详细解析一下这种包装类，届时会放链接)</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目名称&quot;&gt;&lt;a href=&quot;#题目名称&quot; class=&quot;headerlink&quot; title=&quot;题目名称&quot;&gt;&lt;/a&gt;题目名称&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;第10题：正则表达式匹配(困难)&lt;br&gt;第15题：三数之和(中等)&lt;br&gt;第57题：和为s的连续正数序列(简单)&lt;br&gt;第59题：II.队列的最大值(中等)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="算法题" scheme="http://yoursite.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
      <category term="算法题" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java中的HashMap以及红黑树</title>
    <link href="http://yoursite.com/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    <id>http://yoursite.com/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/</id>
    <published>2019-12-15T13:21:42.000Z</published>
    <updated>2020-03-07T12:06:59.841Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇博客涉及以下几个内容：</p><ol><li>HashMap的部分源码讲解</li><li>红黑树的数据结构</li></ol></blockquote><a id="more"></a><h1 id="HashMap的结构和源码"><a href="#HashMap的结构和源码" class="headerlink" title="HashMap的结构和源码"></a>HashMap的结构和源码</h1><p>　Java中集合一共可以分为两类，一类是Collection，代表是ArrayList；一类是Map，代表是HashMap。而HashMap存储结构是<strong>哈希表</strong>。</p><h2 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h2><p>　哈希表的本质是一个数组，但是性能比数组高很多，因为动态数组的插入和删除操作对应的时间复杂度是O(n)，而哈希表的增删改查操作时间复杂度均为O(1)。<br>　为什么快？<br>　哈希表利用函数映射的方式来将数据映射到其维护的数组上，这样执行增删改查操作时只需要通过这个函数就能找到数组的下标，从而实现快速定位。相比数组的顺序存储，哈希表是无序的，因此在执行删除操作时，并不需要移动其他下标的元素。<strong>用来执行元素映射的函数叫做哈希函数：hashcode()。</strong><br>　存储方式如下图：<br>  <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/hashtable.png" alt="哈希表"></p><h3 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h3><p>　由上述的存储方式可知，<strong>如果两个不同元素通过哈希函数的值相同，则单纯用数组存储就会有冲突。</strong>这种方法最直接的解决办法就是设计优秀的哈希函数，把冲突的可能性降至最低，但是再优秀的哈希函数，都会有可能发生冲突。因此，需要有一种方法来解决冲突问题。<br>　常见的方法有：</p><ol><li>线性探测法，发生冲突后顺序找下一块空的地址。（运气差的话增删改查都会变O(n)）</li><li>对冲突的地址使用另一个Hash函数</li><li>链地址法：数组的每个位置都存一个链表。（运气差的话，查找会变O(n)）</li></ol><p>　HashMap解决冲突的办法就是<strong>链地址法</strong>，数组的每个位置我们称之为桶。如果运气不好的话，所有的数字都在一个桶里，那么查找一个链表的时间复杂度是O(n)，这很低效。<strong>所以JDK8之后，当一个桶里存放的元素超过8个时，则这个桶里会自动变成红黑树，这样查找的效率就成了O(logn)。</strong></p><h2 id="HashMap的实现原理"><a href="#HashMap的实现原理" class="headerlink" title="HashMap的实现原理"></a>HashMap的实现原理</h2><h3 id="HashMap主干数组"><a href="#HashMap主干数组" class="headerlink" title="HashMap主干数组"></a>HashMap主干数组</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面是HashMap内部维护的一个数组，这个数组初始值为空，主干长度是2的次幂</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br></pre></td></tr></table></figure><p><code>Node&lt;K,V&gt;</code>是HashMap的一个静态内部类(<strong>使用静态内部类是为了方便继承，TreeNode就继承了这个Node类</strong>)，源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Map.Entry是一个接口</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> hash; <span class="comment">//此Node的hash值</span></span><br><span class="line">       <span class="keyword">final</span> K key; <span class="comment">// 此Node的key</span></span><br><span class="line">       V value; <span class="comment">// 此Node的value</span></span><br><span class="line">       Node&lt;K,V&gt; next; <span class="comment">//指向下一个Node</span></span><br><span class="line">       </span><br><span class="line">       Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">           <span class="keyword">this</span>.hash = hash;</span><br><span class="line">           <span class="keyword">this</span>.key = key;</span><br><span class="line">           <span class="keyword">this</span>.value = value;</span><br><span class="line">           <span class="keyword">this</span>.next = next;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line"> <span class="comment">/* ------- 以上是重点 ---------*/</span>      </span><br><span class="line"> <span class="comment">// get,set,toString,hashcode,equels</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　其存储结构如下图：<br><img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/hashmapNode.png" alt="Node存储结构"></p><p>　当数组中某个桶存储的元素超过一定的数量后(默认是8个)，则Node会被转化为TreeNode进行存储，TreeNode继承自<code>LinkedHashMap.Entry&lt;K,V&gt;</code>，关于<code>LinkedHashMap</code>可以移步我的博客：<a href>浅谈Java中LinkedHashMap</a>，<code>TreeNode</code>的解析将在下文的红黑树种讲解。</p><h3 id="几个重要字段"><a href="#几个重要字段" class="headerlink" title="几个重要字段"></a>几个重要字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认字段值：</span></span><br><span class="line"><span class="comment">//1.数组的默认初始容量是16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="comment">//2.数组的最大容量为2的30次方(int最大是 2^31-1)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">//3.当数组中存储的值超过目前容量的75%，执行数组的扩容</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="comment">//4.当数组中一个桶存储的元素超过8个时，list将会转化为tree</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="comment">//5.红黑树的最小容量为64</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"><span class="comment">//6.执行扩容操作时会将小于元素小于6的数还原</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重要字段：</span></span><br><span class="line"><span class="comment">//1.HashMap中实际存储的'key-value'数量</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="comment">//2.数组负载因子，默认是75%</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"><span class="comment">//3.数组存储阈值，如果key-value的数量大于该阈值，则进行数组扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="comment">/** 4.被修改次数，由于HashMap线程不安全，如果对HashMap进行迭代的时候，其他线程改变了HashMap的结构(增、删、改)，则就会抛出ConcurrentModificationException异常 */</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br></pre></td></tr></table></figure><h3 id="HashMap构造器"><a href="#HashMap构造器" class="headerlink" title="HashMap构造器"></a>HashMap构造器</h3><p>　HashMap一共四种初始化的方式</p><ul><li>我们最常用的构造器是无参构造器：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个构造器不初始化table，为table分配空间会在内部的resize()函数中进行，下文会讲。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>HashMap也可以指定容量和负载因子进行初始化</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">         <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span>+</span><br><span class="line">                                               loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="comment">//此步将initalCapacity规范成2的次幂</span></span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>剩余两种构造器比较容易</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个不讲了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过一个Map实例化HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    <span class="comment">//相当于一个拷贝工作，这个false我目前不是很理解，如果为true的话，在内部会执行afterNodeInserction函数，但是我看这个函数是空的，所以不是很理解。</span></span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="put函数"><a href="#put函数" class="headerlink" title="put函数"></a>put函数</h3><p>　上面我们看到，如果使用缺省的构造器，我们是不会初始化table的，而真正初始化table需要等到我们第一次使用put操作。这是一种懒加载的机制，用来节约内存资源。<br>　以下是源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Implements Map.put and related methods</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> value the value to put</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> onlyIfAbsent if true, don't change existing value</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@param</span> evict if false, the table is in creation mode.</span></span><br><span class="line"><span class="comment">   * <span class="doctag">@return</span> previous value, or null if none</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">      <span class="comment">/*定义一个数组tab，一个链表p表示桶里的链表情况，n表示数组长度，i表示key在数组中的索引*/</span></span><br><span class="line">      Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">      <span class="comment">/*如果table没有初始化，则resize()，下文会讲*/</span></span><br><span class="line">      <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">          n = (tab = resize()).length;</span><br><span class="line">      <span class="comment">/*如果key所在桶里为空，则为这个key-value新建一个Node存放*/</span></span><br><span class="line">      <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">          tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">/*如果桶里不为空，则新建一个节点e用来寻找新插入或者修改的Node的位置*/</span></span><br><span class="line">          Node&lt;K,V&gt; e; K k;</span><br><span class="line">          <span class="comment">/*如果key相等，则不插入新节点，e指向要修改val的位置*/</span></span><br><span class="line">          <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">              ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">              e = p;</span><br><span class="line">          <span class="comment">/*如果桶里是红黑树，则执行红黑树的插入操作*/</span></span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">              e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="comment">/*若桶里只是链表，则遍历这个链表*/</span></span><br><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">              <span class="comment">/*在表尾插入新的节点*/</span></span><br><span class="line">                  <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                      p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                      <span class="comment">/*如果链表的长度大于阈值，将链表转换成红黑树*/</span></span><br><span class="line">                      <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                          treeifyBin(tab, hash);</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  &#125;</span><br><span class="line">                  <span class="comment">/*若在遍历链表时，发现有Node的key与插入的key相等，则退出遍历*/</span></span><br><span class="line">                  <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                      ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                      <span class="keyword">break</span>;</span><br><span class="line">                  <span class="comment">/*p指向的Node沿着链表一直向后*/</span></span><br><span class="line">                  p = e;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">/*如果e不为null，则e指向要修改val的Node*/</span></span><br><span class="line">          <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">              V oldValue = e.value;</span><br><span class="line">              <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                  e.value = value;</span><br><span class="line">              afterNodeAccess(e);</span><br><span class="line">              <span class="keyword">return</span> oldValue;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">/*新插入节点后增加HashMap的修改次数，*/</span></span><br><span class="line">      ++modCount;</span><br><span class="line">      <span class="comment">/*key-value的数量大于阈值后对数组进行扩容*/</span></span><br><span class="line">      <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">          resize();</span><br><span class="line">      afterNodeInsertion(evict);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>　我看了一下网上的流程图都不是很准确，我这里用文字表示一下，最近实在是太累了，等我写LinkedHashMap的时候把图补上。<br>　<strong>HashMap中put的流程如下：</strong></p><ol><li>判断table是否为空，为空则进行resize()初始化table</li><li>计算插入的Key的在table中的索引i</li><li>若table[i]中没有值，则新建一个Node插入该位置</li><li>若有值，则判断插入的key是否与table[i]中首节点的key相等，若相等则直接替换val</li><li>若key不等，则判断table[i]存放的是否为红黑树，若为红黑树，则进行红黑树的插入操作<ol><li>红黑树中也会进行key值的比较，若相等则直接修改val，若不等则插入新节点</li></ol></li><li>若table[i]中存放的是链表，则遍历链表<ol><li>若遍历过程中发现有key相等，则直接替换</li><li>若遍历到链表的结尾，则在结尾插入新的Node<ol><li>若此时table[i]内存放的元素大于8，则将链表转化成红黑树，并对红黑树进行扩容</li></ol></li></ol></li><li>插入成功后，若数组中存放的key-value数值大于数组阈值后，则进行resize()扩容操作。</li></ol><h3 id="get函数"><a href="#get函数" class="headerlink" title="get函数"></a>get函数</h3><p>　有put就有get，这是HashMap最常用的两个函数，其主要的难点在于红黑树的查找，这在下文会讲。<br>　以下是源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">     Node&lt;K,V&gt; e;</span><br><span class="line">     <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * Implements Map.get and related methods</span></span><br><span class="line"><span class="comment">  *</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment">  * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line"> <span class="comment">/*定义数组，链表和待查找的节点，n表示数组的长度，k表示遍历节点的key*/</span></span><br><span class="line">     Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">     <span class="comment">/*若不满足查找条件比如数组不存在，桶里没值，返回null*/</span></span><br><span class="line">     <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">         (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">/*检查第一个节点，若想等则返回*/</span></span><br><span class="line">         <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">             ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">             <span class="keyword">return</span> first;</span><br><span class="line">         <span class="comment">/*若不等，则看其下一个有没有值，没有则返回null，TreeNode继承的爷爷辈是Node，因此可以调用父类对象的next，即使其已经是TreeNode了*/</span></span><br><span class="line">         <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="comment">/*若有值则寻找，红黑树查找或列表遍历*/</span></span><br><span class="line">             <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                 <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">             <span class="keyword">do</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                     ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                     <span class="keyword">return</span> e;</span><br><span class="line">             &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="remove函数"><a href="#remove函数" class="headerlink" title="remove函数"></a>remove函数</h3><p>　最后一项删操作，如果增和查的操作都了解的话，删操作也就通俗易懂。其大体的思路就是：查到需要删除的节点，然后执行红黑树的删除或者链表的删除。<br>　源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = removeNode(hash(key), key, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>)) == <span class="keyword">null</span> ?</span><br><span class="line">        <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Implements Map.remove and related methods</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> hash hash for key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> key the key</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value the value to match if matchValue, else ignored</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> matchValue if true only remove if value is equal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> movable if false do not move other nodes while removing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the node, or null if none</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">removeNode</span><span class="params">(<span class="keyword">int</span> hash, Object key, Object value,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">boolean</span> matchValue, <span class="keyword">boolean</span> movable)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*定义一个数组，一个链表，n表示数组的长度，index表示要删除的数组索引位置*/</span></span><br><span class="line">    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, index;</span><br><span class="line">    <span class="comment">/*table为空或者桶内没有数据，无法执行删除，返回null*/</span></span><br><span class="line">    <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">        (p = tab[index = (n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">/*找到要删除的节点，用node指向它*/</span></span><br><span class="line">        Node&lt;K,V&gt; node = <span class="keyword">null</span>, e; K k; V v;</span><br><span class="line">        <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">            ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">            node = p;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ((e = p.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">do</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key ||</span><br><span class="line">                         (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) &#123;</span><br><span class="line">                        node = e;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/*删除node*/</span></span><br><span class="line">        <span class="keyword">if</span> (node != <span class="keyword">null</span> &amp;&amp; (!matchValue || (v = node.value) == value ||</span><br><span class="line">                             (value != <span class="keyword">null</span> &amp;&amp; value.equals(v)))) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(<span class="keyword">this</span>, tab, movable);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (node == p)</span><br><span class="line">                tab[index] = node.next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p.next = node.next;</span><br><span class="line">            ++modCount;</span><br><span class="line">            --size;</span><br><span class="line">            afterNodeRemoval(node);</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="resize函数"><a href="#resize函数" class="headerlink" title="resize函数"></a>resize函数</h3><p>　在我们进行HashMap操作的时候会经常会有扩容的需求，因此了解扩容的机制十分重要。<br>　源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*此方法不能被重写*/</span></span><br><span class="line">   <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">   <span class="comment">/*保存旧的table，并保存旧的阈值和容量*/</span></span><br><span class="line">       Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">       <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">       <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">       <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">       <span class="comment">/*若超过最大容量，则将阈值设置成2^31-1*/</span></span><br><span class="line">       <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">               threshold = Integer.MAX_VALUE;</span><br><span class="line">               <span class="keyword">return</span> oldTab;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">/*若当前容量在最小值和最大值之间，则把新容量和新阈值扩大一倍*/</span></span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                    oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">               newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*若阈值不为0，但数组容量为0，将容量扩展成阈值大小*/</span></span><br><span class="line">       <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">           newCap = oldThr;</span><br><span class="line">       <span class="comment">/*第一次初始化table，设置容量为16，阈值为16*0.75*/</span></span><br><span class="line">       <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">           newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">           newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/*通过新容量设置新阈值，如果新容量比最大容量小，则为'新容量*负载因子' */</span></span><br><span class="line">       <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">           newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                     (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">       &#125;</span><br><span class="line">       threshold = newThr;</span><br><span class="line">       <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">       Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">       table = newTab;</span><br><span class="line">       <span class="comment">/*执行扩容，对里面每个元素进行重新排放*/</span></span><br><span class="line">       <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">               Node&lt;K,V&gt; e;</span><br><span class="line">               <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                   oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                   <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                       newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                   <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                       ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                   <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                       Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                       Node&lt;K,V&gt; next;</span><br><span class="line">                       <span class="keyword">do</span> &#123;</span><br><span class="line">                           next = e.next;</span><br><span class="line">                           <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                               <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                   loHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   loTail.next = e;</span><br><span class="line">                               loTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                           <span class="keyword">else</span> &#123;</span><br><span class="line">                               <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                   hiHead = e;</span><br><span class="line">                               <span class="keyword">else</span></span><br><span class="line">                                   hiTail.next = e;</span><br><span class="line">                               hiTail = e;</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                       <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j] = loHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                       <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                           hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                           newTab[j + oldCap] = hiHead;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> newTab;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h1 id="红黑树讲解"><a href="#红黑树讲解" class="headerlink" title="红黑树讲解"></a>红黑树讲解</h1><p>　JDK8之后，HashMap引入了红黑树，红黑树是一种自平衡二叉查找树。本节将通过数据《算法》和HashMap的部分源码来解析红黑树的结构。</p><h2 id="2-3平衡树"><a href="#2-3平衡树" class="headerlink" title="2-3平衡树"></a>2-3平衡树</h2><p>　理解红黑树的平衡是一件比较抽象的事情，很多博客并不讲红黑树是如何实现平衡的。本文通过2-3平衡树来讲解一下”平衡”的概念。</p><h3 id="完美平衡"><a href="#完美平衡" class="headerlink" title="完美平衡"></a>完美平衡</h3><p>　完美平衡是指，所有空结点到根结点的的距离相等，比如下图就是一个完美平衡的二叉树:<br><img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/BinaryTree.png" alt="完美平衡树"><br>　很明显可以看出来，如果一颗普通的二叉树要达到完美平衡，其对于结点的数量是有要求的: $ n  = 2^{k} - 1  $ , 如果结点数量不满足这个等式, 那么一颗二叉树始终不可能是平衡的。<br>　<font color="red"><strong>那么如何使一棵树不管有几个结点都能保持平衡呢?</strong></font><br>　这里设想一下, 左右子树在最理想的情况下高度差是多少? 答案很明显是1, 因为任意数都可以在$ 2^{k} $和$ 2^{k+1} $之间。因此如果我们把高的子树的高度减一, 那么这棵树就实现了完美平衡。</p><h3 id="2-3树的基本结构"><a href="#2-3树的基本结构" class="headerlink" title="2-3树的基本结构"></a>2-3树的基本结构</h3><p>　如何实现高度减一呢? 有一个特别简单的办法, 那就是新定义一个结点:3-结点。我们将普通二叉树的结点定义为：2-结点。2-结点存储一个key，并且有左右两个子树; 3-结点存储两个key, 并且有左中右三个子树。2-3树就是由2-结点和3-结点组成的树, 二叉树也是2-3树的一种。下面是一个2-3树示例:<br><img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/2-3Tree.png" alt="2-3平衡树"></p><h3 id="实现完美平衡"><a href="#实现完美平衡" class="headerlink" title="实现完美平衡"></a>实现完美平衡</h3><p>　2-3树可以始终保持完美平衡, 因为在2-3树中插入新值不会破坏其平衡性, 下面我们仔细讲一讲如何实现2-3树的插入操作。<br>　一个树在第一次生成的时候一定是平衡的, 因为只有一个2-结点, 当我们在一个平衡的树的底部插入新结点的时候会破坏其平衡性。因此, 我们在讲解2-3树的插入操作前, 必须有一个前提: <strong>2-3树在插入前是平衡的</strong>。<br>　当我们插入一个新结点时，会遇到以下的几种情况: </p><ul><li>在一个2-结点的底部插入新键: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/insert1.png" alt="2-结点插入"></li><li>在一个没有父节点的3-结点底部插入新键: 临时构建一个4-结点。<img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/insert2.png" alt="3-结点插入"></li><li>在一个父节点是2-结点的3-结点底部插入新键: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/insert3.png" alt="3-结点插入2"></li><li>在一个父节点是3-结点的3-结点底部插入新键: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/insert4.png" alt="3-结点插入3"> </li></ul><p>　可以看到, 2-3树之所以能保持平衡性, 是因为其在插入的过程中, 不会在底部增加高度, 而是自下而上去寻找一个2-结点能够吸收这个高度变化, 如果没有寻找到这个2-结点, 则会通过把遇到的3-结点创建为临时4-结点并分解的方式使左右子树的高度均增加1, 以保证树的平衡。(这里稍微再说一下, 如果这个3-结点不是根结点, 则增加的高度也不会破坏其平衡性, 因为分解4-结点的操作会在顶部生成一个2-结点, 而这个增加的2-结点相当于对3-结点的父结点进行一次插入操作)</p><h3 id="查找和插入操作的复杂度"><a href="#查找和插入操作的复杂度" class="headerlink" title="查找和插入操作的复杂度"></a>查找和插入操作的复杂度</h3><p>　要理解2-3树的操作复杂度, 需要知道树的高度。因为其平衡特性, 2-3树的高度在 $ log_{2}N $ (全是2-结点)和$ log_{3}N $ (全是3-结点)之间。因此, 其查找的复杂度在 $ O(logN) $; 其插入操作需要先查找, 然后进行结点的变换。单个结点变换的复杂度为$ O(1) $, 平均要进行$logN$次变换(最少变换一次: 父结点是2-结点; 最坏变换树的高度: 一路上去全是3-结点, 最后到根结点), 因此插入的复杂度是: $O(logN)+O(logN) = O(logN)$。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>　理解了2-3平衡树后, 红黑树就好理解了。 红黑二叉树的基本思想是用标准的二叉树(全是2-结点)以及一些额外的信息(替换3-结点)来表示2-3平衡树。这个额外的信息是: 红链接将两个2-结点组成一个3-结点, 黑链接表示2-3树的普通链接。红链接指向的结点我们会标记为红色结点。关于一个3-结点和红链接的表示如下图： <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/RBTree.png" alt="红黑树结点"> </p><h3 id="等价定义"><a href="#等价定义" class="headerlink" title="等价定义"></a>等价定义</h3><p>　红黑树可以说是2-3树的变种, 任意的2-3树都能转换成红黑树, 我们可以用一种等价的定义来描述红黑树(和网络上一般讲解的不太一样, 但是都是对的): 红黑树是满足下列条件的二叉查找树:</p><ul><li>红链接均为左链接(即所有的红色结点都是左结点, 根结点必然是黑色);</li><li>没有任何一个结点同时与两条红链接相连;</li><li>该树是完美黑色平衡的</li></ul><p>　满足上述定义的红黑树与相应的2-3树必然是一一对应的。完美黑色平衡是非常直观的，因为红结点不能单独作为2-结点，我们把红链接放平，就是一颗完美平衡的2-3树, 下面是一个简单的示例: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/RedFlat.png" alt="红黑树结点"> </p><h3 id="简单的红黑树结点"><a href="#简单的红黑树结点" class="headerlink" title="简单的红黑树结点"></a>简单的红黑树结点</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> RED = <span class="keyword">true</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> BLACK = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span></span>&#123;</span><br><span class="line">Key key;</span><br><span class="line">Value val;</span><br><span class="line">TreeNode left, right; <span class="comment">// 只有左子树和右子树, HashMap中有所不同, 下面再讲</span></span><br><span class="line"><span class="keyword">int</span> N; <span class="comment">//这颗子树中的结点总数</span></span><br><span class="line"><span class="keyword">boolean</span> color; <span class="comment">// 表示从父结点指向它的链接的颜色</span></span><br><span class="line"></span><br><span class="line">TreeNode(Key key, Value val, <span class="keyword">int</span> N, <span class="keyword">boolean</span> color)&#123;</span><br><span class="line"><span class="keyword">this</span>.key = key;</span><br><span class="line"><span class="keyword">this</span>.val = val;</span><br><span class="line"><span class="keyword">this</span>.N = N;</span><br><span class="line"><span class="keyword">this</span>.color = color;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下面是几个需要用到的简单函数:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isRed</span><span class="params">(TreeNode x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="keyword">return</span> x.color == RED;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">(TreeNode x)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> x.N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="旋转和颜色变换"><a href="#旋转和颜色变换" class="headerlink" title="旋转和颜色变换"></a>旋转和颜色变换</h3><p>　进行插入的过程中可能会破坏上述性质:  出现红色右链接和两条连续的红链接。这些情况可以通过简单的旋转和颜色变换进行修复。其中旋转是一次进行链接变换的简单操作。</p><ul><li>左旋转: 把一条右红链接转换为左链接, 如图: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/rotateLeft.png" alt="红黑树结点"> </li><li>右旋转: 把一条左红链接转换为右链接, 如图: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/rotateRight.png" alt="红黑树结点"> </li><li>颜色变换: 当左右链接均为红色, 则把两条链接都变黑, 并把根结点变红, 如图: <img src="/2019/12/15/%E6%B5%85%E8%B0%88Java%E4%B8%AD%E7%9A%84HashMap%E4%BB%A5%E5%8F%8A%E7%BA%A2%E9%BB%91%E6%A0%91/flipColor.png" alt="红黑树结点"></li></ul><p>　我们可以利用旋转操作帮我们保证红黑树和2-3树的一一对应, 因此我们无需担心树的平衡性。</p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><ul><li>左旋转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">rotateLeft</span><span class="params">(TreeNode h)</span></span>&#123;</span><br><span class="line">TreeNode x = h.right;</span><br><span class="line">h.right = x.right;</span><br><span class="line">x.left = h;</span><br><span class="line">x.color = h.color;</span><br><span class="line">h.color = RED;</span><br><span class="line">x.N = h.N;</span><br><span class="line">h.N = <span class="number">1</span> + size(h.left) +size(h.right);</span><br><span class="line">retrurn x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>右旋转</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">rotateRight</span><span class="params">(TreeNode h)</span></span>&#123;</span><br><span class="line">TreeNode x = h.left;</span><br><span class="line">h.left = x.right;</span><br><span class="line">x.right = h;</span><br><span class="line">x.color = h.color;</span><br><span class="line">h.color = RED;</span><br><span class="line">x.N = h.N;</span><br><span class="line">h.N = <span class="number">1</span> + size(h.left) + size(h.right);</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>颜色变换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode <span class="title">filpColors</span><span class="params">(TreeNode h)</span></span>&#123;</span><br><span class="line">h.left.color = BLACK;</span><br><span class="line">h.right.color = BLACK;</span><br><span class="line">h.color = RED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇博客涉及以下几个内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HashMap的部分源码讲解&lt;/li&gt;
&lt;li&gt;红黑树的数据结构&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java内部类</title>
    <link href="http://yoursite.com/2019/12/15/%E6%B5%85%E8%B0%88Java%E5%86%85%E9%83%A8%E7%B1%BB/"/>
    <id>http://yoursite.com/2019/12/15/%E6%B5%85%E8%B0%88Java%E5%86%85%E9%83%A8%E7%B1%BB/</id>
    <published>2019-12-15T03:25:12.000Z</published>
    <updated>2020-03-07T12:05:12.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇博客主要涉及以下几个内容</p><ol><li>Java中的内部类</li><li>Java中的静态内部类</li><li>关于内部类常见的一些面试题</li></ol></blockquote><a id="more"></a><h1 id="Java中的内部类"><a href="#Java中的内部类" class="headerlink" title="Java中的内部类"></a>Java中的内部类</h1><p>内部类就是在Java类内部定义的类，主要分为四种类型：</p><ol><li>成员内部类</li><li>静态内部类</li><li>局部内部类</li><li>匿名内部类</li></ol><h2 id="使用内部类的原因"><a href="#使用内部类的原因" class="headerlink" title="使用内部类的原因"></a>使用内部类的原因</h2><ol><li>Java拥有单继承的特性，而内部类可以独立继承一个类或实现接口。这一定程度上方便了开发。</li><li>内部类的信息与其他外围类信息独立，提供了更好的封装</li></ol><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2><p>作为外部类的成员变量存在，其性质如下：</p><ol><li>可以有访问修饰符</li><li>外部类在类中访问内部类需要通过new的方式</li><li>外部类加载，成员内部类不加载</li><li>不能有静态信息【因为如果外部类没有实例化，则内部类不会被加载(不符合类加载的几种条件)，因此静态变量不会进内存，这与static的概念矛盾了】</li><li>内部类的this关键字表示自己的对象，如要访问外部类的对象则使用<code>外部类名.this</code></li><li>在外部类外访问内部类需要使用<code>外部类的实例引用.new 内部类构造函数</code></li></ol><ul><li>以下demo体现了这些特性：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestOuterInnerClass</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//访问内部类</span></span><br><span class="line">        <span class="comment">//1. 先要有外部类的应引用</span></span><br><span class="line">        OuterInnerClass outer = <span class="keyword">new</span> OuterInnerClass();</span><br><span class="line">        <span class="comment">//2. 通过该引用创建外部类</span></span><br><span class="line">        OuterInnerClass.InnerClass inner = outer.<span class="keyword">new</span> InnerClass();</span><br><span class="line">        <span class="comment">//3. 也可以通过自定义的方法创建</span></span><br><span class="line">        <span class="comment">//inner = outer.creatInner();</span></span><br><span class="line">        <span class="comment">//4.直接使用内部类</span></span><br><span class="line">        inner.print();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         输出结果如下：</span></span><br><span class="line"><span class="comment">         1. Outer Constructor..</span></span><br><span class="line"><span class="comment">         2. Inner Constructor</span></span><br><span class="line"><span class="comment">         3. Outer's val:10</span></span><br><span class="line"><span class="comment">         4. Inner's val:5</span></span><br><span class="line"><span class="comment">         5. outerPrint..</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OuterInnerClass</span> /*<span class="keyword">extends</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">IA</span>*/</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> val = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OuterInnerClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Outer Constructor.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">outerPrint</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"outerPrint.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InnerClass</span> /*<span class="keyword">extends</span> <span class="title">B</span> <span class="keyword">implements</span> <span class="title">IB</span>*/</span>&#123;</span><br><span class="line">    <span class="comment">//内部类变量有重名</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> val = <span class="number">5</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">InnerClass</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Inner Constructor"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="comment">//外部类和内部类的成员变量重名如何区分？</span></span><br><span class="line">            System.out.println(<span class="string">"Outer's val:"</span> + OuterInnerClass.<span class="keyword">this</span>.val);</span><br><span class="line">            System.out.println(<span class="string">"Inner's val:"</span> + <span class="keyword">this</span>.val);</span><br><span class="line">            <span class="comment">//可以直接访问外部类的成员变量和方法</span></span><br><span class="line">            outerPrint();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> InnerClass <span class="title">creatInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 外部类中访问内部类通过new的方式</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> InnerClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>静态内部类的性质如下：</p><ol><li>可以有访问修饰符</li><li>静态内部类不依赖于外部类。因此外部类被加载，内部类不会被加载；而内部类被加载，外部类也不会被加载<ol><li>内部类创建：<code>Outer.Inner inner = new Outer.Inner()</code></li><li>访问内部类的静态成员：<code>Outer.Inner.staticValue</code></li></ol></li><li>静态内部类<strong>只可以关联外部类的静态资源</strong>（因为内部类被加载时，关联外部类的静态资源会使外部类加载，但是不能拥有外部类的实例）</li><li>与成员内部类的区别<ol><li>不需要依赖于外部类的实例创建</li><li>只能关联外部类静态资源</li><li>不存在this关键字</li></ol></li></ol><ul><li>以下demo可以体现以上性质：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticOuterInner</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//生成静态内部类的实例</span></span><br><span class="line">        Outer.Inner inner = <span class="keyword">new</span> Outer.Inner();</span><br><span class="line">        <span class="comment">//类外访问静态内部类的静态资源</span></span><br><span class="line">        Outer.Inner.innerStaticMethod();</span><br><span class="line">        <span class="comment">//调用内部类的方法</span></span><br><span class="line">        inner.innerMethod();</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         输出为：</span></span><br><span class="line"><span class="comment">         1. inner static block...</span></span><br><span class="line"><span class="comment">         2. Inner constructor...</span></span><br><span class="line"><span class="comment">         3. innerStaticMethod...</span></span><br><span class="line"><span class="comment">         4. Outer static block...</span></span><br><span class="line"><span class="comment">         5. Outer static value:10</span></span><br><span class="line"><span class="comment">         6. innerMethod...</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Outer static block..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Outer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Outer constructor..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span></span>&#123;</span><br><span class="line">        <span class="keyword">static</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"inner static block..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">innerStaticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"innerStaticMethod..."</span>);</span><br><span class="line">            <span class="comment">//可以访问外部类的静态变量</span></span><br><span class="line">            System.out.println(<span class="string">"Outer static value:"</span> + a);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Inner</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"Inner constructor..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">innerMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"innerMethod..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">outStaticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//类中访问静态内部类</span></span><br><span class="line">        Inner inner = <span class="keyword">new</span> Inner();</span><br><span class="line">        inner.innerMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出解释：</li></ul><ol><li>首先创建静态内部类的实例，先加载内部类执行静态代码块，随后执行构造方法。由静态内部类的性质可知，加载静态内部类，外部类是不加载的。</li><li>随后执行静态内部类的静态方法，此方法关联了外部类的静态变量，因此外部类被加载，但没有实例化。</li><li>最后执行了静态内部类实例的方法。可见在整个流程中，外部类只是加载了，并没有实例化。</li></ol><h2 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h2><p>在一个方法内定义的类，有如下性质：</p><ol><li>没有访问权限修饰符</li><li>仅在方法内有效</li><li>无法创造静态信息，因为这个类是临时的</li><li>可以访问外部类的所有信息（方法内部本身就是可以访问的）</li><li>可以访问方法的参数和局部变量（但是这些变量始终不能被改变）</li></ol><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><p>常用来重写某个或某些方法，这个用的还是比较多的，比较常见的就是Java的动态代理实现，会实现一个匿名内部类并重写invoke()方法。</p><ul><li>使用动态代理的Demo</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestAnonInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        IPerson person = PersonProxy.getPerson();</span><br><span class="line">        person.eat();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     输出结果：</span></span><br><span class="line"><span class="comment">     1. 做饭...</span></span><br><span class="line"><span class="comment">     2. 吃饭...</span></span><br><span class="line"><span class="comment">     3. 洗碗...</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IPerson</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> <span class="keyword">implements</span> <span class="title">IPerson</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"吃饭..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PersonProxy</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> IPerson person = <span class="keyword">new</span> Person();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IPerson <span class="title">getPerson</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//使用匿名内部类InvocationHandler，重写invoke方法，对Person接口的所有方法进行增强</span></span><br><span class="line">        <span class="keyword">return</span> (IPerson) Proxy.newProxyInstance(person.getClass().getClassLoader()</span><br><span class="line">                , person.getClass().getInterfaces(), <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object obj = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                            System.out.println(<span class="string">"做饭..."</span>);</span><br><span class="line">                            obj = method.invoke(person);</span><br><span class="line">                            <span class="keyword">return</span> obj;</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                            System.out.println(<span class="string">"饭馊了..."</span>);</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没吃上饭:"</span> + e);</span><br><span class="line">                        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">                            System.out.println(<span class="string">"洗碗..."</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇博客主要涉及以下几个内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java中的内部类&lt;/li&gt;
&lt;li&gt;Java中的静态内部类&lt;/li&gt;
&lt;li&gt;关于内部类常见的一些面试题&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>浅谈Java类加载顺序和static关键字</title>
    <link href="http://yoursite.com/2019/12/15/%E6%B5%85%E8%B0%88Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E5%92%8Cstatic%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/12/15/%E6%B5%85%E8%B0%88Java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F%E5%92%8Cstatic%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2019-12-15T03:19:09.000Z</published>
    <updated>2020-03-07T12:05:22.113Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇博客主要包含以下几个内容</p><ol><li>Java中类加载的顺序</li><li>Java中static关键字的用法</li><li>面试的一些常见问题</li></ol></blockquote><a id="more"></a><h1 id="Java中的类加载"><a href="#Java中的类加载" class="headerlink" title="Java中的类加载"></a>Java中的类加载</h1><p>JVM要执行一段Java程序分为两步：</p><ol><li>将类编译成.class字节码文件</li><li>进行类加载生成类</li></ol><h2 id="类加载的过程"><a href="#类加载的过程" class="headerlink" title="类加载的过程"></a>类加载的过程</h2><p>想要理解static必须要了解一下类加载的过程，主要分为三步：</p><ol><li>第一步：类文件加载</li><li>第二步：类链接<ol><li>验证</li><li>准备</li><li>解析</li></ol></li><li>第三步：类初始化</li></ol><h2 id="类加载的时机"><a href="#类加载的时机" class="headerlink" title="类加载的时机"></a>类加载的时机</h2><p>类的加载一般通过JVM提供的类加载器ClassLoader完成，在以下几种情况下，JVM会把类加载进内存中进行使用：</p><ol><li>new 这个类的对象</li><li>访问这个类或接口的静态变量</li><li>调用这个类的静态方法</li><li>执行反射操作：Class.forName(“类名”)</li><li>加载这个类的子类</li><li>JVM启动时表明的启动类(<strong>这说明了一个类并不一定要被使用的时候才会被加载</strong>)</li></ol><h2 id="类文件加载"><a href="#类文件加载" class="headerlink" title="类文件加载"></a>类文件加载</h2><p>JVM在编译时会生成类的.class字节码文件，这个文件是存储在磁盘上的。当JVM运行时需要加载某个类时，会将这个文件读入内存，<strong>并由类加载器为其生成一个独一无二的java.lang.Class对象。</strong> 这个对象保存了一个类的所有信息，用暴力反射甚至可以操作其私有变量。</p><h2 id="类链接"><a href="#类链接" class="headerlink" title="类链接"></a>类链接</h2><p>这一步主要分为三小步</p><ol><li>验证：主要验证这个类是否有正确的内部结构(比如.class文件格式是否符合规范等)（这里我有疑问，如果验证失败了，其创建的Class对象是否还有意义？）</li><li>准备：为类中的静态变量分配内存，并设置初始值(同时也会在常量池中创建这个常亮)</li><li>解析：将内存中二进制数据的符号引用生成直接引用（这个引用在堆里，详情可见<a href="https://memoforward.cn/2019/09/25/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AJava%E4%B8%AD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/" target="_blank" rel="noopener">HashMap 为什么会出现内存泄漏问题以及 Java 中引用类型的存储位置</a>)</li></ol><h2 id="类初始化"><a href="#类初始化" class="headerlink" title="类初始化"></a>类初始化</h2><p>这一步主要给静态变量赋正确的值。<br>也就是说，当我定义<code>static a = 10</code>时，会先在第二步中进行初始化成0，然后在类初始化时被赋予正确的值。因为在程序运行时，每个类只会被加载一次，因此静态成员变量的初始化只会进行一次。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><ol><li>加载子类前会先加载父类</li><li>类加载完成后，才会执行类实例化的操作</li><li>类初始化和类实例化时不同的概念</li></ol><h1 id="static关键字的用法"><a href="#static关键字的用法" class="headerlink" title="static关键字的用法"></a>static关键字的用法</h1><p>static关键字主要用于五个方面：</p><ol><li>静态方法</li><li>静态成员变量</li><li>静态代码块</li><li>静态内部类</li><li>静态导入</li></ol><h2 id="静态变量和静态代码块"><a href="#静态变量和静态代码块" class="headerlink" title="静态变量和静态代码块"></a>静态变量和静态代码块</h2><p>类加载的时候被赋值和调用，其顺序与代码顺序一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line">    <span class="comment">//改变两段定义的位置程序性会报错</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(a); <span class="comment">// a:0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        TestStatic t = <span class="keyword">new</span> TestStatic();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>类的静态方法会在类加载时分配入口地址，<strong>并且早于类对象的构造函数调用</strong>，因此静态方法是无法访问类的非静态成员变量的，因此在静态方法中也无法使用<code>this或者super</code>关键字。</p><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2><p>具体可以查看我的博客：<a href="https://memoforward.cn/2019/12/15/%E6%B5%85%E8%B0%88Java%E5%86%85%E9%83%A8%E7%B1%BB/" target="_blank" rel="noopener">浅谈Java内部类</a></p><h2 id="静态导入"><a href="#静态导入" class="headerlink" title="静态导入"></a>静态导入</h2><p>这个是JDK5之后的特性，用于导入某个类的<strong>静态方法</strong>，导入后可以直接使用方法名来使用该方法。其用法如下：<code>import static 包名.类名.方法名</code>，方法名可以改成通配符<code>*</code>，这样就可以导入所有静态方法。（我试了一下，静态成员变量无法导入）<br>例子继续按照上方的代码，增加了一个静态方法，并把该类放置在<code>memoforward包</code>下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStatic</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(a);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"gogogogo....."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>随后我在另一个类中静态导入方法<code>print()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> memoforward.TestStatic.print;</span><br><span class="line"><span class="comment">//import static memoforward.TestStatic.*;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticImport</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个程序的输出是：<code>10 和 gogogo...</code>，表示调用某个类静态方法后，这个类会先被加载。</p><h2 id="补充-1"><a href="#补充-1" class="headerlink" title="补充"></a>补充</h2><ul><li>静态成员变量和静态方法都是被所有对象共有的，任意对象都可以操作<strong>同一份</strong>静态变量，使用静态方法。</li><li>子类对象可以使用父类对象的静态成员变量（且仍是同一份数据），但是如果子类重新声明了同名静态变量，则JVM会为子类额外分为一块内存空间，此时会由对象的类型来确定到底调用哪一个静态变量（因此静态变量不存在继承的关系，其调用完全根据其类型，静态方法同理），学术点讲：静态方法是静态绑定的。</li></ul><p>测试代码：</p><ul><li>父类Father</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Father method..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子类Son</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span></span>&#123;</span><br><span class="line"><span class="comment">//    public static int a = 5; //如果注释打开，则子类对象的a为5</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Son method..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试：可见静态的变量和方法若有重名会根据其类型来确定，若没有，则子类调用父类。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> memoforward.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> memoforward.Father;</span><br><span class="line"><span class="keyword">import</span> memoforward.Son;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestStaticExtends</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Father father = <span class="keyword">new</span> Father();</span><br><span class="line">        Son son = <span class="keyword">new</span> Son();</span><br><span class="line">        System.out.println(father.a); <span class="comment">// 10</span></span><br><span class="line">        System.out.println(son.a); <span class="comment">// 10</span></span><br><span class="line">        father.staticMethod(); <span class="comment">// Father staticMehtod...</span></span><br><span class="line">        son.staticMethod(); <span class="comment">// Son staticMethod...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="面试常见问题"><a href="#面试常见问题" class="headerlink" title="面试常见问题"></a>面试常见问题</h1><ul><li><p>问题一<br>Q：static关键字会改变变量的访问权限吗？<br>A：不会，能影响访问权限的只有<code>public、private和protected</code>关键字，如果一个静态变量被声明为<code>private</code>，则在类外是无法使用的。</p></li><li><p>问题二<br>Q：抽象方法可否是静态的？<br>A：不能，静态方法不能被重写，且抽象方法无法直接被类调用。</p></li><li><p>问题三<br>Q：以下代码的输出是什么</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"Test"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"test constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> MyClass();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"person "</span>+str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> <span class="keyword">extends</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    Person person = <span class="keyword">new</span> Person(<span class="string">"MyClass"</span>);</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass static"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyClass</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"myclass constructor"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A：输出如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. test static</span><br><span class="line">2. myclass static</span><br><span class="line">2. person static </span><br><span class="line">3. person Test</span><br><span class="line">4. test constructors</span><br><span class="line">5. person MyClass</span><br><span class="line">6. myclass constructor</span><br></pre></td></tr></table></figure></p><p>Explanation:</p><ol><li>调用Test类的静态方法Main，首先会加载Test类，因此执行静态代码块，输出:<code>test static</code></li><li>使用new MyClass()，会先加载类MyClass，输出:<code>myclass static</code></li><li>执行子类实例化前，会先执行父类实例化，初始化操作的顺序：先给成员变量赋默认值，再执行构造函数，因此先执行父类<code>Test</code>中<code>new Person(&quot;Test&quot;)</code></li><li>加载<code>Person</code>类，并执行构造函数，先后输出:<code>person static</code>和<code>person Test</code></li><li>父类<code>Test</code>中成员变量<code>person</code>赋值完毕，执行构造函数,输出：<code>test constructor</code></li><li>随后进行子类对象<code>MyClass</code>初始化，因为<code>Person</code>类已经加载过，因此不会再加载了，所以先后输出:<code>person MyClass</code>和<code>myClass constructor</code></li></ol><p><font color="red"> Attention: </font><br>这里有个小细节：子类所有实例化操作（包括成员变量赋值和构造器）都慢于父类实例化的操作，而实例化操作的顺序是：先进行成员变量赋值，再执行构造函数。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇博客主要包含以下几个内容&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java中类加载的顺序&lt;/li&gt;
&lt;li&gt;Java中static关键字的用法&lt;/li&gt;
&lt;li&gt;面试的一些常见问题&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Java基础" scheme="http://yoursite.com/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java面试问题汇总（一）</title>
    <link href="http://yoursite.com/2019/12/13/%E5%B8%B8%E8%A7%81%E7%9A%84Java%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/12/13/%E5%B8%B8%E8%A7%81%E7%9A%84Java%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2019-12-13T11:23:55.000Z</published>
    <updated>2020-03-07T11:44:16.539Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇文章主要包括如下内容：</p><ol><li>无序数组寻找第K大的值的算法</li><li>Java中static关键字的理解</li><li>Java中的HashMap</li><li>Java中的LinkedHashMap</li></ol></blockquote><a id="more"></a><h1 id="无序数组寻找第K大的值"><a href="#无序数组寻找第K大的值" class="headerlink" title="无序数组寻找第K大的值"></a>无序数组寻找第K大的值</h1><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>给定一个数组，寻找其第K大的值，并分析其复杂度</p><h2 id="笔者踩的坑"><a href="#笔者踩的坑" class="headerlink" title="笔者踩的坑"></a>笔者踩的坑</h2><p>遇到这种问题一定要思考一下，问一下面试官：</p><ol><li>数组是否是数字？</li><li>数组是否有序？ </li><li>数组中是否有重复的数字？</li></ol><p>笔者没问，回来后后悔不已，毕竟这是笔者第一次面试，把自己的菜展现的一览无余。</p><p><strong>我们假设这道题：无序，是数字，无重复。</strong></p><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>寻找一个标志，遍历数组，将比它小的放在左边，比它大的放在右边（快排），记录比它小的数的个数，如果大于K，则在左边寻找，如果小于K，则在右边寻找。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> findKth(nums, k, <span class="number">0</span>, nums.length);</span><br><span class="line">&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = start;</span><br><span class="line">        <span class="keyword">int</span> flag = nums[start];</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = start+<span class="number">1</span>; i &lt; end; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt;= flag) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                p++;</span><br><span class="line">                exchange(nums, p, i);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        exchange(nums,start, p);</span><br><span class="line">        <span class="keyword">if</span>(count == k -<span class="number">1</span>) <span class="keyword">return</span> nums[p];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(count &gt; k -<span class="number">1</span>) <span class="keyword">return</span> findKth(nums, k, start, p);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> findKth(nums, k - <span class="number">1</span> - count, p+<span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exchange</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[left];</span><br><span class="line">        nums[left] = nums[right];</span><br><span class="line">        nums[right] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Java中static关键字的理解"><a href="#Java中static关键字的理解" class="headerlink" title="Java中static关键字的理解"></a>Java中static关键字的理解</h1><p>具体可以移步我的博客：<a href>浅谈Java类加载机制和static关键字</a></p><h1 id="Java中的HashMap"><a href="#Java中的HashMap" class="headerlink" title="Java中的HashMap"></a>Java中的HashMap</h1><p>具体可以移步我的博客：<a href>浅谈Java中的HashMap以及红黑树</a></p><h1 id="Java中的LinkedHashMap"><a href="#Java中的LinkedHashMap" class="headerlink" title="Java中的LinkedHashMap"></a>Java中的LinkedHashMap</h1><p>具体可以移步我的博客：<a href>浅谈Java中LinkedHashMap的实现</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇文章主要包括如下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无序数组寻找第K大的值的算法&lt;/li&gt;
&lt;li&gt;Java中static关键字的理解&lt;/li&gt;
&lt;li&gt;Java中的HashMap&lt;/li&gt;
&lt;li&gt;Java中的LinkedHashMap&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
    
      <category term="面试" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>MySQL的数据结构以及辅助索引的使用</title>
    <link href="http://yoursite.com/2019/09/28/MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/09/28/MySQL%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BB%A5%E5%8F%8A%E8%BE%85%E5%8A%A9%E7%B4%A2%E5%BC%95%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2019-09-28T14:34:43.000Z</published>
    <updated>2020-03-07T12:21:35.748Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文涉及的知识点如下</p><ol><li>MySQL的内部存储结构BTree和B+Tree</li><li>主键索引和辅助索引的结构 以及 查询操作的执行流程</li><li>InnoDB引擎和MyISAM引擎的差别</li></ol><a id="more"></a></blockquote><p>·　　之前学习MySQL都是一直半解，以为建立主键索引只是为了约束数据。直到自己学着做一些开源项目的时候，才发现有<strong>辅助索引</strong>这个神奇的设定，对应的SQL语句：<code>KEY aux_index(col_name)</code>，上网一搜才发现这是为了加快MySQL查询速度。于是我就对MySQL的数据存储结构产生了兴趣，在这里做一个小小的总结。</p><p>·　　我查看了官方的文档和许多博客，觉得这篇博客写的是真的好，分享给大家：<a href="https://www.kancloud.cn/kancloud/theory-of-mysql-index/41846" target="_blank" rel="noopener">MySQL索引背后的数据结构及算法原理</a></p><h1 id="BTree-和-B-Tree"><a href="#BTree-和-B-Tree" class="headerlink" title="BTree 和 B+Tree"></a>BTree 和 B+Tree</h1><p>·　　B+Tree是BTree的扩展，而常用的MySQL引擎<strong>MyISAM和InnoDB</strong>都是用B+Tree作为数据结构存储的（在参考博客里有使用BTree的原因，涉及计算机磁盘的读写，本文不讨论这部分内容），因此在这里介绍一下这两个数据结构。</p><h2 id="索引的价值"><a href="#索引的价值" class="headerlink" title="索引的价值"></a>索引的价值</h2><p>·　　索引顾名思义就是目录，我们需要的内容可能是庞大的，但是索引都是很简洁的，所以索引的存储相比内容而言更具灵活性，也更容易被应用于复杂的数据结构。我们把庞大的内容放在内存里，通过索引去找到这些内容，不仅可以利用索引的灵活性构成高效的数据结构来提高查找效率，也可以一定程度下减少查找时所用的I/O读写时间。</p><h2 id="B-Tree"><a href="#B-Tree" class="headerlink" title="B-Tree"></a>B-Tree</h2><p>·　　BTree有一个重要的概念：度。<br>·　　这个概念似乎和正常的树不太一样，一般说来树节点的“度”表示此节点下拥有的子树的个数，是针对一个节点而言的，<strong>而BTree的度，表示这颗树的度</strong>。<br>·　　在介绍这个概念之前，我们要搞清楚BTree的节点中存的是什么。<strong>BTree的每个节点都储存了至少一个键值对，在每个键值对的前后都有一个指针。</strong> 具体的图如下：<br><img src="https://img-blog.csdnimg.cn/20190928201511856.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>·　　上图中根节点储存有：<strong>三个键值对，四个指针。</strong> 每一个指针都会指向下一个节点，或者指向null。<br>·　　如果规定：<strong>一个节点中拥有<code>n</code>个指针和<code>n-1</code>个键值对，那么BTree的度<code>d</code>则约束了：<code>d ≤ n ≤ 2d</code>。</strong> 上图就是一个<code>d = 2</code>的BTree结构。<br>·　　根据上图我们显然可以猜到BTree树的性质</p><ol><li>每个节点中的键值对，根据键的大小，从左至右非递减。</li><li>指针左边的key都小于等于指针指向的子节点的所有key，右边的key都大于等于。</li></ol><p>·　　查找的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BTree_Search(node, m_key)&#123;</span><br><span class="line"><span class="keyword">if</span>(node == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">foreach(k : node.key)&#123;</span><br><span class="line"><span class="keyword">if</span>(m_key == k) <span class="keyword">return</span> node.get(k);</span><br><span class="line"><span class="keyword">if</span>(m_key &lt; k) <span class="keyword">return</span> BTree_Search(node.leftPointer(k), m_key);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BTree_Search(node.rightPointer(last_key), m_key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">BTree_Search(root, m_key);</span><br></pre></td></tr></table></figure><p>·　　这里有一个有趣的小细节：BTree在最简单的情况下就是一个二叉树，因此BTree树的高最高是logN。</p><h2 id="B-Tree-1"><a href="#B-Tree-1" class="headerlink" title="B+Tree"></a>B+Tree</h2><p>·　　通过上面的BTree我们注意到，每个节点都会存数据，为了加快读写的速度，引入了B+Tree，舍去了非叶子节点的数据存储，仅在叶子结点中存储所有的value；同时，其对指针的数量进行了一些调整。概念图如下：<br><img src="https://img-blog.csdnimg.cn/20190928205253979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>·　　可见，在B+Tree中，每个节点中指针的数量和键的数量相同，并满足：<code>d ≤ n &lt; 2d</code>。而且叶子节点不存储指针。<br>·　　查找的伪代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">BTree_Search(node, m_key)&#123;</span><br><span class="line"><span class="keyword">if</span>(node.isLeaf())&#123;</span><br><span class="line">foreach(k : node.key)&#123;</span><br><span class="line"><span class="keyword">if</span>(m_key == k) <span class="keyword">return</span> node.get(k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">foreach(k : node.key)&#123;</span><br><span class="line"><span class="keyword">if</span>(m_key == k) <span class="keyword">return</span> BTree_Search(node.rightPointer(k), m_key);</span><br><span class="line"><span class="keyword">if</span>(m_key &lt; k) <span class="keyword">return</span> node.havaLeftPointer() ? BTree_Search(node.leftPointer(k), m_key) : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> BTree_Search(node.rightPointer(last_key), m_key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MySQL中的数据结构（索引实现）"><a href="#MySQL中的数据结构（索引实现）" class="headerlink" title="MySQL中的数据结构（索引实现）"></a>MySQL中的数据结构（索引实现）</h1><p>·　　空谈结构没有数据就是耍流氓，因此这里提供一个数据库表。我们假设：<strong>id为主键索引，name为辅助索引。</strong></p><div class="table-container"><table><thead><tr><th>id</th><th>name</th><th>gender</th></tr></thead><tbody><tr><td>1</td><td>cxy</td><td>male</td></tr><tr><td>2</td><td>lhw</td><td>female</td></tr><tr><td>3</td><td>tyy</td><td>female</td></tr><tr><td>4</td><td>dsx</td><td>male</td></tr></tbody></table></div><h2 id="InooDB引擎"><a href="#InooDB引擎" class="headerlink" title="InooDB引擎"></a>InooDB引擎</h2><p>·　　鄙人不才，只用过这一个引擎，主要是因为InooDB支持事务和行级锁。InooDB索引结构是B+Tree，其索引就是一个个key。但是主键索引和辅助索引在叶子节点的存储结构上有一点不同。</p><ul><li><strong>对于主键索引，其存储结构可能如下（仅做示意）：</strong><br><img src="https://img-blog.csdnimg.cn/20190928213309884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>因此若执行<code>select * from this_table where id = 3</code>，就会执行</strong>：<br><img src="https://img-blog.csdnimg.cn/20190928214021332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><strong>辅助索引结构示意图：顺序是ASCII码</strong><br><img src="https://img-blog.csdnimg.cn/2019092821434353.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>·　　<strong>可见，辅助索引中存储的是主键索引，而不是真正的数据值。</strong></li><li><strong>因此若执行<code>select * from this_table where name = cxy</code>，就会执行</strong><br><img src="https://img-blog.csdnimg.cn/20190928215014827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li><li><font color="red">**注意**</font></li></ul><ol><li>InooDB引擎必须要有主键，因为整个引擎都是以主键构成的B+Tree结构而存在的。如果我们不指定主键，mysql会自动给我们创建一个隐藏的主键。</li><li>InooDB的主键最好设置成：<strong>与业务无关且自增。</strong> 我们观察BTree的结构，一旦插入值，这个结构就要重建，很费时，如果主键是自增的，可以减少插入数据时BTree树的更新时间(降低数据写入的时间)。</li><li>辅助索引如果不手动创建，MySQL是不会帮我们创建的，<strong>如果没有辅助索引，我们通过name来找数据的时候，搜索复杂度是O(n)，非常耗时。</strong></li><li><strong>辅助索引并不是越多越好。</strong> 我们观察整个搜索流程会发现，<strong>辅助索引通过牺牲空间的方式来提升查询速度，如果辅助索引过多，必然会造成空间的浪费。</strong></li></ol><h2 id="MyISAM引擎"><a href="#MyISAM引擎" class="headerlink" title="MyISAM引擎"></a>MyISAM引擎</h2><p>·　　这个引擎我还没用过，因为其不支持事务，但是其查询速度非常快！<strong>因为，不管是主键索引还是辅助索引，其叶子节点都存放着数据的地址值</strong>，这表示，在MyISAM引擎中，主键并不是必须的，我们可以通过任何索引在一个logN时间内访问到数据。（但本质上，这还是一个通过空间换时间的算法）</p><ul><li><strong>简要画一下MyISAM的索引结构示意图</strong><br><img src="https://img-blog.csdnimg.cn/20190928221842902.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>·　　辅助索引的结构是一样的。</li></ul><h2 id="聚集索引和非聚集索引"><a href="#聚集索引和非聚集索引" class="headerlink" title="聚集索引和非聚集索引"></a>聚集索引和非聚集索引</h2><p>·　　这个概念我是这么理解的，如果<strong>数据和索引在整个结构中不分离，则为聚集索引</strong>，因此在InooDB中主键索引是聚集索引，而辅助索引是非聚集索引；而在MyISAM中，所有的索引都是非聚集的。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　用了一晚上来写这个博客，还算是有所收获，也终于知道了MySQL数据库的存储结构，以及要在什么时候使用辅助索引。</p><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文涉及的知识点如下&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;MySQL的内部存储结构BTree和B+Tree&lt;/li&gt;
&lt;li&gt;主键索引和辅助索引的结构 以及 查询操作的执行流程&lt;/li&gt;
&lt;li&gt;InnoDB引擎和MyISAM引擎的差别&lt;/li&gt;
&lt;/ol&gt;&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://yoursite.com/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>HashMap为什么会出现内存泄漏问题以及Java中引用类型的存储位置</title>
    <link href="http://yoursite.com/2019/09/25/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AJava%E4%B8%AD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/"/>
    <id>http://yoursite.com/2019/09/25/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AJava%E4%B8%AD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/</id>
    <published>2019-09-25T01:28:46.000Z</published>
    <updated>2020-03-07T12:21:12.010Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文涉及如下知识点：</p><ol><li>HotSpot的垃圾处理机制</li><li>HashMap为什么存在内存泄漏问题</li><li>Java中的引用变量的存储位置</li></ol></blockquote><a id="more"></a><p>·　　最近在研究弱引用的时候，注意到了Java在内存管理时的细节，在这里给大家分享一下。</p><h1 id="JVM中垃圾处理的机制"><a href="#JVM中垃圾处理的机制" class="headerlink" title="JVM中垃圾处理的机制"></a>JVM中垃圾处理的机制</h1><p>·　　垃圾处理的算法非常多，本博客只介绍使用最广的HotSpot虚拟机的垃圾回收算法。简单说来，其使用了<strong>可达性分析算法</strong> ，通过选出一系列称为<strong>GC Roots</strong>的对象作为起点，当一个对象没有任何一条<strong>强引用链</strong>指向<strong>GC Roots</strong>时，则这个对象会被判定为可回收对象。弱引用不是本章讨论的重点，有兴趣的自行百度。<br><img src="https://img-blog.csdnimg.cn/2019092422030897.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="图1-1"><br>·　　在上图中，object5、6、7会被回收。<br>·　　显然，此算法最核心的部分在于<strong>GC Roots</strong>的选取，所以我们要关注<font color="red"><strong>在什么位置的对象才能成为GC Roots</strong></font>,在《深入理解JVM虚拟机》中给出了答案：</p><ol><li><strong>虚拟机栈中引用的对象</strong></li><li><strong>方法区中类静态属性引用的对象</strong></li><li><strong>方法区中的常量对象</strong></li><li><strong>本地方法栈中JNI(Native方法)引用的对象</strong></li></ol><p>·这里不普及JVM的内存结构。</p><h1 id="Java中引用类型的存储位置"><a href="#Java中引用类型的存储位置" class="headerlink" title="Java中引用类型的存储位置"></a>Java中引用类型的存储位置</h1><p>·　　介绍可达性算法主要是为了给我下面的想法做铺垫。<br>·　　<font color="red"><strong>注意：以下的内容我没有从任何书籍和博客上看到明确的解答，所以仅是我个人的一些理解。</strong></font></p><ul><li><strong>Java中的引用到底存在哪里?</strong><br>·　　大部分人都认为，在java中，所有的引用都保存在栈中(虚拟机栈），而引用指向的对象实例则在堆里。<strong>我认为这是不准确的，如果一个对象实例中有另一个对象的引用，那么<font color="red">这个引用并非存在栈里，而是存在于堆中</font></strong>。<br>·　　下面给出我测试用的一段代码：</li><li>测试用类B：对象占用内存大小1MB</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试用类A：占用内存大小2MB</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> B b = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试代码：为了避免不必要的干扰，我在创建实例前先进行了一次垃圾回收。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　结果猜测：显然，<code>引用ａ</code>是存在于栈中的，而ａ指向的实例Ａ，以及实例Ａ中创建的实例Ｂ存在于堆中。现在不确定的点在于：指向实例B的<code>a.b</code>这个引用是存在于栈中，还是堆中呢？众所周知，栈中的数据会随着方法的结束而被释放，如果方法不结束，其数据就不会释放，因此我用<code>while(true){...}</code>使main方法永远不会结束，且每5秒进行一次垃圾回收，看堆中的储存情况。</p><ol><li>如果<code>a.b</code>保存在栈中，其就可作为<strong>GC Root</strong>存在，那么根据可达性算法，实例B永远不会被回收。</li><li>而如果<code>a.b</code>保存在堆中，一旦<code>引用a</code>被释放了，那么实例A和实例B就会如上图中的<code>object5、6、7</code>一样，被GC回收</li><li>根据以上两种理论，<strong>如果<code>a.b</code>保存在栈中，即使实例A被释放了，实例B也不会被释放，堆中至少有1MB的数据。而如果<code>a.b</code>保存在堆中，实例A和实例B都会被释放，堆中的数据至少会小于1MB。</strong></li></ol><ul><li>以下是程序的运行结果：<strong>堆内存中可粗略地细分为新生代和老年代</strong>，这里就不扩展了。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (System.gc()) [PSYoungGen: 3333K-&gt;744K(38400K)] 3333K-&gt;752K(125952K), 0.0042393 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 744K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;673K(87552K)] 752K-&gt;673K(125952K), [Metaspace: 3479K-&gt;3479K(1056768K)], 0.0078916 secs] [Times: user&#x3D;0.03 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 2713K-&gt;2176K(38400K)] 3386K-&gt;2849K(125952K), 0.0010460 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 2176K-&gt;0K(38400K)] [ParOldGen: 673K-&gt;2718K(87552K)] 2849K-&gt;2718K(125952K), [Metaspace: 3485K-&gt;3485K(1056768K)], 0.0079493 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 665K-&gt;64K(38400K)] 3384K-&gt;2782K(125952K), 0.0003627 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 64K-&gt;0K(38400K)] [ParOldGen: 2718K-&gt;670K(87552K)] 2782K-&gt;670K(125952K), [Metaspace: 3485K-&gt;3485K(1056768K)], 0.0039402 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 0K-&gt;0K(38400K)] 670K-&gt;670K(125952K), 0.0003178 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 0K-&gt;0K(38400K)] [ParOldGen: 670K-&gt;669K(87552K)] 670K-&gt;669K(125952K), [Metaspace: 3485K-&gt;3485K(1056768K)], 0.0066122 secs] [Times: user&#x3D;0.05 sys&#x3D;0.00, real&#x3D;0.01 secs]</span><br></pre></td></tr></table></figure><ol><li>第一次GC时，堆中的内存被清理到只有673K，并且进入了老年代：<code>[ParOldGen: 8K-&gt;673K(87552K)]</code>。</li><li>第二次GC前，我们创建了对象a，在堆内存中占用了2MB：<code>[PSYoungGen: 2713K-&gt;2176K(38400K)]</code>(<del>这里不做细微的误差分析，因为我也不清楚gc到底干了什么</del> )。随后这2MB内存进入了老年代：<code>[ParOldGen: 673K-&gt;2718K(87552K)]</code></li><li>第三次GC前，我们释放了实例A的链接，发现这2MB内存被释放了，老年代中仅剩原先的673K（可能有点误差）：<code>[ParOldGen: 2718K-&gt;670K(87552K)]</code></li><li>第四次GC，因为堆中已经没有实例A、B所以此垃圾回收没有释放任何空间。</li><li><font color="red">**总上所述：我认为类成员变量的引用必然在堆内存中。**</font></li></ol><h1 id="HashMap的内存泄漏问题"><a href="#HashMap的内存泄漏问题" class="headerlink" title="HashMap的内存泄漏问题"></a>HashMap的内存泄漏问题</h1><p>·　　有了上述问题的铺垫，我们可以正式聊一下HashMap中内存泄漏的问题， 因为之前看ThreadLocal的源码才意识到了这个问题，实在是惭愧，话不多说，我先解释一下内存泄漏的原因：</p><ol><li>首先要明确的一点是，<strong>Java中的参数都是按值传递的</strong>，即使是引用，在传递时也会生成引用的副本。</li><li>因此，HashMap的对象引用<code>map</code>在<code>put(key，value)</code>时，就会生成key，value引用的副本，我们姑且称为<code>key&#39;</code>和<code>value&#39;</code>。根据上面的理论，这个副本应该存在堆内存中。</li><li>当栈中的<code>key引用</code>被释放时，原来指向的实例<code>KEY</code>（姑且这么称呼），与栈中的<code>map引用</code>依然存在一条可达链：<strong>map —— HashMap实例 —— key’ —— KEY实例</strong> 这条强引用链。因此实例KEY不会被释放，虽然HashMap可以保存键为null的Entry，但是实例KEY我们就不会再用到了，而它迟迟不释放，就会造成内存泄漏的问题。</li></ol><ul><li>图示说明：可以很明显看出来<code>KEY</code>和<code>VALUE</code>有两条强引用链<br><img src="https://img-blog.csdnimg.cn/20190925084205942.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><h2 id="代码验证"><a href="#代码验证" class="headerlink" title="代码验证"></a>代码验证</h2>我们将类A稍作修改，让其不关联类B：</li><li>类A</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line"><span class="comment">//    public B b = new B();</span></span><br><span class="line">    <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>代码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"0.--------------"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"1.--------------"</span>);</span><br><span class="line">        Map&lt;A, B&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"2.--------------"</span>);</span><br><span class="line">        map.put(a,b);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"3.--------------"</span>);</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"4.--------------"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">0.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 3333K-&gt;712K(38400K)] 3333K-&gt;720K(125952K), 0.0016227 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 712K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;629K(87552K)] 720K-&gt;629K(125952K), [Metaspace: 3206K-&gt;3206K(1056768K)], 0.0074770 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">1.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 3379K-&gt;2176K(38400K)] 4008K-&gt;2805K(125952K), 0.0012001 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 2176K-&gt;0K(38400K)] [ParOldGen: 629K-&gt;2676K(87552K)] 2805K-&gt;2676K(125952K), [Metaspace: 3226K-&gt;3226K(1056768K)], 0.0076292 secs] [Times: user&#x3D;0.03 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">2.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1996K-&gt;32K(38400K)] 4672K-&gt;2708K(125952K), 0.0005201 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 2676K-&gt;2675K(87552K)] 2708K-&gt;2675K(125952K), [Metaspace: 3226K-&gt;3226K(1056768K)], 0.0076530 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">3.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1331K-&gt;96K(38400K)] 4007K-&gt;2771K(125952K), 0.0003721 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 96K-&gt;0K(38400K)] [ParOldGen: 2675K-&gt;2677K(87552K)] 2771K-&gt;2677K(125952K), [Metaspace: 3229K-&gt;3229K(1056768K)], 0.0027659 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">4.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1331K-&gt;160K(38400K)] 4009K-&gt;2837K(125952K), 0.0005946 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 160K-&gt;0K(38400K)] [ParOldGen: 2677K-&gt;2718K(87552K)] 2837K-&gt;2718K(125952K), [Metaspace: 3488K-&gt;3488K(1056768K)], 0.0065556 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs]</span><br></pre></td></tr></table></figure><ul><li>结果分析：因为FullGC对线程的停顿时间比较长，未被回收的对象会进入老年代，而新生代中会被清0，因此为了方便，<strong>我们仅关注老年代的情况</strong>。</li></ul><ol><li>程序一开始先进行一次清理，避免不必要的干扰，老年代中有628K：<code>[ParOldGen: 8K-&gt;629K(87552K)]</code>。</li><li>随后，我们创建了HashMap实例，实例A和实例B，在这次的GC中，老年代中多了约2MB内存：<code>[ParOldGen: 629K-&gt;2676K(87552K)]</code>。</li><li>然后我们将实例A，B放进hashMap对象：<code>map.put(a,b)</code>，put操作会在堆内存中会有额外的开销（会新建一些对象用来进行put操作），因此新生代中会有新内存的使用（但很快就被清理掉了）：<code>[PSYoungGen: 1996K-&gt;32K(38400K)]</code>。我们通过观察老年代：<code>[ParOldGen: 2676K-&gt;2675K(87552K)]</code>，发现实际上这个put操作并没有为HashMap开辟新的内存空间，因为map仅仅只是把内部的引用指向了实例A, B而已。</li><li>这一步我们将栈中的引用a释放：<code>a = null;</code>，我们希望看到实例A被回收，但是GC并没有这样做，老年代中的值几乎没有变化：<code>[ParOldGen: 2675K-&gt;2677K(87552K)]</code></li><li>为了避免意外，令线程沉睡5秒后，再次清理，发现实例A仍在堆内存中：<code>[ParOldGen: 2677K-&gt;2718K(87552K)]</code>，因此可以判断这造成了一定的内存泄漏。</li><li><strong>事实上，HashMap中的某一个特定key很难被清理掉，因为用map.clear()会清理掉整个map。但是HashMap的内存泄漏一般不会很严重，因为只有在极少数情况下，我们才想去手动释放一个key。</strong></li></ol><h2 id="再次证明内存泄漏的代码"><a href="#再次证明内存泄漏的代码" class="headerlink" title="再次证明内存泄漏的代码"></a>再次证明内存泄漏的代码</h2><p>·　　笔者不太会手动去真正释放HashMap的key，因此，我做了一个实验，先把类A关联上类B，但是不实例化这个B。</p><ul><li>类A</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> B b;</span><br><span class="line">    <span class="keyword">byte</span>[] a = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">1024</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>实验步骤</li></ul><ol><li>实例化A,B得<code>引用a，b</code>，并把<code>a.b = b</code></li><li>令 <code>b = null</code>, 再令<code>a.b = null</code>，比较内存变化情况</li><li>再令 <code>a = null</code>，查看内存</li></ol><ul><li>实验代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GCTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"0.--------------"</span>);</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"1.--------------"</span>);</span><br><span class="line">        A a = <span class="keyword">new</span> A();</span><br><span class="line">        B b = <span class="keyword">new</span> B();</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"2.--------------"</span>);</span><br><span class="line">        a.b = b;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"3.--------------"</span>);</span><br><span class="line">        b = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"4.--------------"</span>);</span><br><span class="line">        a.b = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"5.--------------"</span>);</span><br><span class="line">        a = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        System.out.println(<span class="string">"--------------"</span>);</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">                System.gc();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">0.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 3333K-&gt;776K(38400K)] 3333K-&gt;784K(125952K), 0.0013798 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 776K-&gt;0K(38400K)] [ParOldGen: 8K-&gt;673K(87552K)] 784K-&gt;673K(125952K), [Metaspace: 3482K-&gt;3482K(1056768K)], 0.0198551 secs] [Times: user&#x3D;0.05 sys&#x3D;0.00, real&#x3D;0.02 secs] </span><br><span class="line">1.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 2713K-&gt;2144K(38400K)] 3387K-&gt;2817K(125952K), 0.0047306 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 2144K-&gt;0K(38400K)] [ParOldGen: 673K-&gt;2718K(87552K)] 2817K-&gt;2718K(125952K), [Metaspace: 3487K-&gt;3487K(1056768K)], 0.0091880 secs] [Times: user&#x3D;0.01 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">2.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 1331K-&gt;32K(38400K)] 4050K-&gt;2750K(125952K), 0.0003588 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 2718K-&gt;2718K(87552K)] 2750K-&gt;2718K(125952K), [Metaspace: 3487K-&gt;3487K(1056768K)], 0.0080175 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">3.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 665K-&gt;32K(38400K)] 3383K-&gt;2750K(125952K), 0.0004018 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 2718K-&gt;2718K(87552K)] 2750K-&gt;2718K(125952K), [Metaspace: 3487K-&gt;3487K(1056768K)], 0.0037897 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">4.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 665K-&gt;32K(38400K)] 3383K-&gt;2750K(125952K), 0.0005433 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 2718K-&gt;1694K(87552K)] 2750K-&gt;1694K(125952K), [Metaspace: 3487K-&gt;3487K(1056768K)], 0.0051309 secs] [Times: user&#x3D;0.02 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">5.--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 665K-&gt;32K(38400K)] 2359K-&gt;1726K(125952K), 0.0045968 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.01 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 1694K-&gt;670K(87552K)] 1726K-&gt;670K(125952K), [Metaspace: 3488K-&gt;3488K(1056768K)], 0.0044260 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">--------------</span><br><span class="line">[GC (System.gc()) [PSYoungGen: 665K-&gt;32K(38400K)] 1335K-&gt;702K(125952K), 0.0003409 secs] [Times: user&#x3D;0.00 sys&#x3D;0.00, real&#x3D;0.00 secs] </span><br><span class="line">[Full GC (System.gc()) [PSYoungGen: 32K-&gt;0K(38400K)] [ParOldGen: 670K-&gt;670K(87552K)] 702K-&gt;670K(125952K), [Metaspace: 3488K-&gt;3488K(1056768K)], 0.0030132 secs] [Times: user&#x3D;0.05 sys&#x3D;0.00, real&#x3D;0.00 secs]</span><br></pre></td></tr></table></figure><ul><li>结果分析</li></ul><ol><li>程序一开始先进行一次清理，避免不必要的干扰，老年代中有673K：<code>[ParOldGen: 8K-&gt;673K(87552K)]</code>。</li><li>创建了实例A,B后，老年代中多了2MB：<code>[ParOldGen: 673K-&gt;2718K(87552K)]</code></li><li>将实例A与实例B关联<code>a.b = b</code>后，堆内存无变化：<code>[ParOldGen: 2718K-&gt;2718K(87552K)]</code></li><li>令栈中的<code>引用b=null</code>，发现内存不释放：<code>[ParOldGen: 2718K-&gt;2718K(87552K)]</code>，这与HashMap的内存泄漏完全一致</li><li>此时，我们释放掉<code>a.b</code>对实例B的引用<code>a.b = null</code>，发现实例B被清理了：<code>[ParOldGen: 2718K-&gt;1694K(87552K)]</code>，但是实例A仍然占用了1MB的堆内存。</li><li>随后我们再次释放<code>引用a = null</code>，发现此时实例A也被清理了：<code>[ParOldGen: 1694K-&gt;670K(87552K)]</code></li><li><strong>这个实验证明了：GC Root与实例B之间确实有强引用链，而这个强引用链是 类A成员变量类B的引用提供的</strong></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　Java的内存管理机制还是很巧妙的，相比C++方便了很多，越往后面学发现这些底层的东西才是java的灵魂的所在啊。</p><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文涉及如下知识点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;HotSpot的垃圾处理机制&lt;/li&gt;
&lt;li&gt;HashMap为什么存在内存泄漏问题&lt;/li&gt;
&lt;li&gt;Java中的引用变量的存储位置&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal的深入理解</title>
    <link href="http://yoursite.com/2019/09/24/ThreadLocal%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/09/24/ThreadLocal%E7%9A%84%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3/</id>
    <published>2019-09-24T13:10:22.000Z</published>
    <updated>2020-03-07T12:22:11.574Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇文章深入探讨了ThreadLocal的实现以及使用场景<br>本文章全部基于个人理解，如有错误请邮箱联系本人，多谢</p></blockquote><a id="more"></a><p>·　　最近对多线程，高并发产生了兴趣(<del>其实是面试大厂的时候对性能提升这一块有较高的要求</del> )，以前只会用 <code>synchronized</code> 关键字来实现线程安全，其实这是比较狭隘的，解决线程安全的问题有很多种方法，比如：非阻塞同步(乐观锁机制：在一个可能有线程安全问题的方法中，去判断此操作的结果是否符合预期，如果不符合就放弃此操作的输出，并重新对开始一轮新的操作直到符合预期后再输出)，使用可重入的代码(无法对共享变量进行修改的代码)以及我们今天要提及的<code>ThreadLocal</code>。<br>·　　我写博客主要还是为了给自己看，多了一些自己的理解，但是可能并不精炼。而讲<code>ThreadLocal</code>的好文已经有很多了，这也不是什么新技术，各位还是看比较权威的文章更好一点，我这里实名推荐一篇：<a href="https://blog.csdn.net/fengcaho0616/article/details/79154697" target="_blank" rel="noopener">(转载)ThreadLocal实现原理</a>，<strong>但是我仍要强烈鄙视一下这篇文章的博主，明明是转载的，却不标明出处。</strong></p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>·　　我在前言里说了辣么多解决线程安全的方法，这时候人本能就会想到两个问题：1. 哪个最好？2. 如果有最好的，还要用其他的干什么。<br>·　　在这里我仅说一下我的理解：</p><ol><li><strong><code>synchronized</code>方法是最能解决线程安全问题的方法，因为多线程能够安全地操作同一块内存地址的区域，这是其他方法做不到的。</strong> 但是这个方法弊端也很明显，多线程串行执行一个任务，效率极低(当然现在的锁进行了很多的优化措施，至少不会让某个线程在一个任务上长时间阻塞了，这个不是重点)。</li><li>非阻塞同步方法解决了线程串行的问题，但是存在ABA隐患(这也不是重点，所谓ABA请自行搜索啦)。</li><li><code>ThreadLocal</code>方法，它并不能解决一部分的线程安全问题，因为就算你使用了<code>ThreadLocal</code>，你也无法阻止多线程操作同一块内存空间的隐患，而<code>ThreadLocal</code>却解决了在web领域的一个重大的问题：<strong><font color="red">各线程的独立操作共享数据</font></strong>。</li></ol><h1 id="ThreadLocal使用场景解释"><a href="#ThreadLocal使用场景解释" class="headerlink" title="ThreadLocal使用场景解释"></a>ThreadLocal使用场景解释</h1><p>·　　很多小伙伴都懵逼了，“独立操作共享数据”是什么意思？其实很简单，我这里的解释需要涉及一点Servlet的知识才可以懂。</p><ul><li><font color="brown"><strong>ThreadLocal是干嘛的</strong></font><br>·　一句话总结：<code>ThreadLocal实例</code>能够把某个对象与当前<code>thread</code>绑定。于是在任何时刻，当前<code>thread</code>都能通过<code>ThreadLocal</code>获得该对象。</li><li><font color="brown"><strong>Servlet的线程安全问题</strong></font><br>·　我们都知道原生的Servlet是单例的，会产生线程安全问题，但是这具体是怎么产生的呢？这里给出一个例子：当线程A和线程B同时去访问同一个Servlet，并同时给<code>request</code>域对象中设置了 相同的键 和 不同的值，这时候，这两个线程就会抢夺资源，导致最终转发给用户的<code>reques</code>t可能并不是用户想要的。</li><li><font color="brown">**Servlet安全问题的解决思路**</font>·　如果，线程A和线程B能够独立操作该Servlet中的`request`对象，操作的方式仅对自己的线程的可见，这样这条线程在整个“客户端--服务端--客户端”的流程中，都能保存数据的一致性。**所以，解决方法就是：每个线程都会创建一个仅对自己可见的`request`代理对象，当线程死亡后，该`request`代理对象也随之销毁。** 而<font color="red">“创建一个仅对自己可见的`request`代理对象”，就需要用到我们的`ThreadLocal`。</font></li><li><font color="brown"><strong>ThreadLocal使用场景的思考</strong></font><br>·　可见，<code>ThreadLocal</code>方法，<strong>并不能实现多线程安全操作共享变量(如果不新建Request代理对象，就会依然存在安全问题，因为Request对于多线程而言还是单例的)</strong>，所以我认为它不能解决所有线程安全问题，(但是，它的优势在于：<strong>每个线程看似都能并发地独立”修改”某个共享变量(将<code>thread</code>与这个共享变量的代理对象绑定)，极大地提高时间利用率</strong>。<br>·　关于我的对线程安全的理解，我举个很通俗的比方，耳熟能详的 “生产者 —- 产品 —- 消费者” 问题上，<code>ThreadLocal</code>就不能帮我们解决线程安全问题，因为创建产品的代理对象没有意义。而在上述的Servlet问题中，我们并不关心线程间操作<code>request</code>的顺序是什么样的，我们只需要各线程能且只能看到自己的数据而已。</li><li><font color="brown"><strong>个人的理解</strong></font><br>·　根据我的理解，<code>threadLocal</code>被设计出来主要是用来解决并发条件下的数据隔离问题，是用空间换取时间的一种手段。<strong>其实归根结底，threadLocal用来解决Servlet的线程安全问题，理念上就是用了多例模式而已(给共享变量创建副本)，只不过这多出来的‘例’仅对当前线程可见</strong>。不过也不尽然，如果我们非要把与某个线程绑定的对象再与其他线程绑定也是没有问题的，但这就失去了使用<code>threadLocal</code>的意义，我们一般只会把某个对象与特定的一个<code>thread</code>绑定，这样我们就可以通过这个<code>thread</code>在任何时刻访问到这个对象，而其他<code>thread</code>无法做到。这意味着<strong>threadLocal使用场景并不局限在解决线程安全的问题上</strong> ：我们从数据库连接池获取连接的时候，我们只希望一条线程在它的生命周期内只能获取到一个连接对象，且这个连接对象在线程死亡前不会被释放。这就需要我们用threadLocal在当前线程第一次申请连接时，将某个池里的连接与当前线程绑定，以后每次要申请连接，该线程都只会得到这个连接，在线程死亡后，连接被归还。</li><li><font color="red">**一句话总结：两种情况下需要用`threadLocal`**</font></li></ul><ol><li>每个线程希望操作自己独有的对象，如<code>Request</code>对象</li><li>在一个线程中，同一个对象需要在多个方法中共享，如进行事务管理时，某个业务操作需要用到多个DAO方法，这些方法我们希望使用同一个<code>Connection</code>对象。</li></ol><h1 id="ThreadLocal结构的简单说明"><a href="#ThreadLocal结构的简单说明" class="headerlink" title="ThreadLocal结构的简单说明"></a>ThreadLocal结构的简单说明</h1><ul><li><font color="brown"><strong>什么是ThreadLocal</strong></font><br>·　一句话总结：本地线程副本<br>·　这句话有一层重要含义：<code>threadLocal</code>不特定属于某个线程，它用来管理所有的本地线程。也就是说，<font color="red"><strong>threadLocal本身是一个全局变量，每个线程通过它来获得仅对自己可见的局部变量</strong>。</font><br>·　用刚才Servlet的问题来举个例子（并不准确，但是便于理解）：出现安全问题是因为多线程共同访问了同一个Request对象，但是我们使用了ThreadLocal之后，<strong>每个线程都只会去访问一个<code>ThreadLocal&lt; Request &gt;</code>对象，并从这个对象中获取只对当前线程可见的Request代理对象。</strong><br>·　这意味着，一个线程其实可以从多个ThreadLocal对象中获取相对应的多个值。即：每个线程既可以通过ThreadLocal&lt; Request &gt;对象获得自己的Request代理对象，也可以同时通过<code>ThreadLocal&lt; Connection &gt;</code>对象获取自己的数据库连接对象。只不过这两者的使用理念不同，<strong>前者主要是为了保证多线程之间的数据隔离，后者主要是为了保证对象在单线程中对多方法共享</strong>。</li></ul><h2 id="对象是如何与线程相绑定的"><a href="#对象是如何与线程相绑定的" class="headerlink" title="对象是如何与线程相绑定的"></a>对象是如何与线程相绑定的</h2><p>·　 一句话总结：通过ThreadLocal的内部类<code>ThreadLocalMap</code>。<br>·　 下面是Thread源码的一部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class="line"><span class="comment"> * by the ThreadLocal class. */</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>·　　由源码可知，在Thread内部有一个由ThreadLocal维护的<code>ThreadLocalMap</code>对象。因此我们可知，实现绑定的关键在于这个<code>ThreadLocalMap</code>类，下面是其一部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The entries in this hash map extend WeakReference, using</span></span><br><span class="line"><span class="comment">        * its main ref field as the key (which is always a</span></span><br><span class="line"><span class="comment">        * ThreadLocal object).  Note that null keys (i.e. entry.get()</span></span><br><span class="line"><span class="comment">        * == null) mean that the key is no longer referenced, so the</span></span><br><span class="line"><span class="comment">        * entry can be expunged from table.  Such entries are referred to</span></span><br><span class="line"><span class="comment">        * as "stale entries" in the code that follows.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">           <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">           Object value;</span><br><span class="line"></span><br><span class="line">           Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">               <span class="keyword">super</span>(k);</span><br><span class="line">               value = v;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">/**</span></span><br><span class="line"><span class="comment">        * The table, resized as necessary.</span></span><br><span class="line"><span class="comment">        * table.length MUST always be a power of two.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       <span class="keyword">private</span> Entry[] table;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　由源码可知，<strong><code>ThreadLocalMap</code>本质上是一个<code>Entry</code>数组</strong>，Entry又是其内部类。这个内部类的key是一个threadLocal的弱引用(super(k))，value是我们要与当前线程绑定的对象。<br>·　　因此，我们可以简要的画出ThreadLocal的结构图：<br><img src="https://img-blog.csdnimg.cn/20190924110421984.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>·　在这个图里有几点必要重要的信息：</p><ol><li>全局的<code>ThreadLocal</code>对象在整个存储的结构中，是作为一个key而存在的，而且还是这个key的弱引用。</li><li>Map是每个线程独有的，和全局的ThreadLocal不存在从属关系，也就是说，这个map里可以存放多个不同的ThreadLocal对象作为key，这些ThreadLocal对象对于线程的ThreadLocalMap而言是同级的。(虽然很基础，但是我还是提一嘴，这个内部类是静态的，所以ThreadLocalMap本质上不特定属于某一个ThreadLocal对象)</li></ol><h2 id="深入理解的注意事项"><a href="#深入理解的注意事项" class="headerlink" title="深入理解的注意事项"></a>深入理解的注意事项</h2><p>·　　在讲ThreadLocal如何进行线程的绑定等一系列操作前，我们还是先缕清一些问题。</p><ul><li><font color="brown"> <strong>为什么使用弱引用</strong></font><br>·　本人在做了一些研究之后，给大家简单地解释一下：在上图中，我们可以明显的看到<strong>ThreadLocal对象有两条对其的引用，一条来自外界的引用，一条来自内部Entry对其的引用</strong>，因为内部引用的释放我们一般是不愿意去操作的（因为太底层了），因此我们<strong>希望只要释放ThreadLocal的外部引用，这个ThreadLocal实例就能被垃圾回收</strong>。但是，如果内部引用是强引用，那么即使外部引用被释放了，也有一条强引用链：<strong>“CurrentThread Ref —- CurrentThread —- ThreadLocalMap —- Entry —- Entry.key —- ThreadLocal”</strong> 这样我们就无法有效地回收ThreadLocal了，久而久之GC如果一直回收不掉这个实例，而我们又不使用这个ThreadLocal了，那就导致了内存泄漏，很容易造成OutOfMemory异常。<strong>但是，如果这条强引用链最后的引用变成了弱引用，那GC就能顺利释放掉ThreadLocal对象了（GC会回收掉只有弱引用引用的对象）</strong>。如果想进一步了解Java内存泄漏的情况，可以看一下我的另一篇博客：<a href="https://memoforward.github.io/2019/09/25/HashMap%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E5%87%BA%E7%8E%B0%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AJava%E4%B8%AD%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%AD%98%E5%82%A8%E4%BD%8D%E7%BD%AE/" target="_blank" rel="noopener">HashMap为什么会出现内存泄漏问题 以及 Java中引用类型的存储位置</a>。</li><li><p><font color="brown"><strong>使用了弱应用就不存在内存泄漏的问题了吗</strong></font><br>·　显然不是，从图中很容易看出，即使ThreadLocal对象被释放掉了，与线程绑定的Entry的Value并没有被释放掉，而我们也不会再使用这个Entry了，这同样也是内存泄漏的问题（这里的强引用链就不写了）。为了避免这样的问题，<strong>在释放掉ThreadLocal的外部引用前，我们一般会利用ThreadLocal对象先把这个Entry对Value的强引用释放掉</strong>，这就是在下一章要提到的threadLocal.remove()方法。</p></li><li><p><font color="brown"><strong>为什么要使用ThreadlLocal进行对象与线程的绑定</strong></font><br>·　仔细想一想，如果让我们自己设计，我们可能会想着直接用线程去绑定某个对象：在线程内部维护一个<code>List&lt;HashMap&lt;T,V&gt;&gt;</code>的结构：T表示要绑定的对象类型，V是这个对象实例的引用。但是仔细一想，这样做实在是不精明，因为首先这个结构过于复杂，其次并非所有线程都需要这个List来保存本地变量副本的(如用synchronized去保证线程安全的情况)，而HashMap的构造必需分配内存空间，当线程量多的时候造成的内存空间浪费将会十分严重。而我们反观ThreadLocalMap的设计，首先结构简单，其实Thread类维护的这个Map采用懒加载的方式，不使用的话就不会在堆空间中分配内存，可谓是鬼斧神工。</p></li></ul><h1 id="ThreadLocal部分源码"><a href="#ThreadLocal部分源码" class="headerlink" title="ThreadLocal部分源码"></a>ThreadLocal部分源码</h1><p>·　　本节内容十分简单，主要涉及到ThreadLocal自身的<strong>set(), get(), remove()</strong> 方法。假设我们的对象为<code>ThreadLocal&lt;?&gt; tl = new ThreadLocal&lt;&gt;();</code> 代码的详解，请参考这篇博客：<a href="https://blog.csdn.net/fengcaho0616/article/details/79154697" target="_blank" rel="noopener">(转载)ThreadLocal实现原理</a>，我这里仅仅只是概括而已。</p><ul><li><font color="brown"> **tl.set()**</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　这源码再清晰不过了：获取当前线程对象，并得到其内部维护的map，并把要绑定的对象放入map，其键为this，表示threadLocal对象的弱引用。createMap(t, value)体现了懒加载的特性，源码就不贴了，就是分配内存空间，这里主要看一下<strong>map.set(this，value)</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(ThreadLocal&lt;?&gt; key, Object value)</span> </span>&#123;</span><br><span class="line">          <span class="comment">// We don't use a fast path as with get() because it is at</span></span><br><span class="line">          <span class="comment">// least as common to use set() to create new entries as</span></span><br><span class="line">          <span class="comment">// it is to replace existing ones, in which case, a fast</span></span><br><span class="line">          <span class="comment">// path would fail more often than not.</span></span><br><span class="line">          Entry[] tab = table;</span><br><span class="line">          <span class="keyword">int</span> len = tab.length;</span><br><span class="line">          <span class="keyword">int</span> i = key.threadLocalHashCode &amp; (len-<span class="number">1</span>);</span><br><span class="line">          <span class="keyword">for</span> (Entry e = tab[i];</span><br><span class="line">               e != <span class="keyword">null</span>;</span><br><span class="line">               e = tab[i = nextIndex(i, len)]) &#123;</span><br><span class="line">              ThreadLocal&lt;?&gt; k = e.get();</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">                  e.value = value;</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                  replaceStaleEntry(key, value, i);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          tab[i] = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">          <span class="keyword">int</span> sz = ++size;</span><br><span class="line">          <span class="keyword">if</span> (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)</span><br><span class="line">              rehash();</span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure><p>·　这里再详细的源码就不贴了，我说明一下map.set做了什么事情：</p><ol><li><font color="red">这里必须说明一下，threadLocalMap采用线性探测的方式向Entry数组里填入数据</font>，至于什么线性探测这里不细说了，这是解决hash冲突的最简单的方式。</li><li>如果Entry数组中有key（代码里是k）与set的key一样，则直接用新value覆盖掉原value</li><li>如果发现有Entry数组中无效槽<code>k==null</code>，则替换掉这个无效槽，并把key，value填入</li><li>若Entry数组中所有槽均有效，则在连续段末尾处放入key，value，随后检测一下这个Entry数组是否需要扩容。</li><li>至于<code>key.threadLocalHashCode</code>，这是一个魔数，这里不细说。数学是美妙的，一般底层程序中经常会出现类似的魔数。</li></ol><ul><li><font color="brown"> **tl.get()**</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> setInitialValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　这个代码就更简单了：当前线程的Map通过这个threadLocal对象获得了与其绑定的值，这与我们第二节的理解完全一致，<strong>不过再强调一遍加深印象：一个threadLocal实例只能保证一个对象与当前线程绑定，这个线程要与多个对象绑定，最好把这些对象封装起来(比如Servlet的域对象们，SpringMVC的源码似乎就是这么做的)。</strong><br>·　　如果这个map还没有初始化的话，会执行：<code>setInitialValue();</code>，该操作新建一个表，并把此null赋值给<code>Entry.value</code></p><ul><li><font color="brown"> **tl.remove()**</font></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　这里同样不继续看<code>m.remove(this)</code>的源码了，这里的remove主要就干一件事：<code>Entry.value = null</code>。保证了这个Value对象能被垃圾回收器及时回收。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　ThreadLocal的设计十分巧妙，通过自身的对象去实现线程与数据之间的绑定，而这个绑定又以自己的弱应用作为key，这极大程度上简化了本应该很复杂的数据结构，因为这巧妙地解决了与线程绑定的对象数据类型不确定这个问题，否则就要用我上面提到的<code>List&lt;HashMap&lt;T,V&gt;&gt;</code>来存储。我仍不是很清楚设计师是怎么想出来这种设计模式的，也不知道这种设计理念是什么，总之路漫漫其修远兮，吾将上下而求索。</p><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇文章深入探讨了ThreadLocal的实现以及使用场景&lt;br&gt;本文章全部基于个人理解，如有错误请邮箱联系本人，多谢&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>SpringJDBC模板的使用以及实现事务管理</title>
    <link href="http://yoursite.com/2019/09/04/SpringJDBC%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/04/SpringJDBC%E6%A8%A1%E6%9D%BF%E7%9A%84%E4%BD%BF%E7%94%A8%E4%BB%A5%E5%8F%8A%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</id>
    <published>2019-09-04T06:20:44.000Z</published>
    <updated>2020-03-07T12:25:14.099Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文主要涉及如下知识点：</p><ol><li>SpringJDBC模板实战</li><li>Spring基于XML配置实现事务管理</li><li>Spring基于注解配置实现事务管理</li></ol></blockquote><a id="more"></a><h1 id="SpringJDBC模板"><a href="#SpringJDBC模板" class="headerlink" title="SpringJDBC模板"></a>SpringJDBC模板</h1><p>·　　当还未接触到SpringJDBC模板以及Mybatis等框架时，我们一直在使用DButils来对JDBC进行封装操作，SpringJDBC模板和DButils的操作可以说是十分相似。所以我们操作起来几乎没有难度，相比DBUtils需要额外引入连接池才可以使用，Spring自己内置了连接池（<font color="red">DriverManagerDataSource</font>），可以说是十分方便。<br>·　　使用SpringJDBC模板需要的jar包是：<strong>spring-jdbc</strong><br>·　　与数据库交互需要使用:<strong>mysql-connection-java</strong></p><h2 id="使用SpringJDBC模板"><a href="#使用SpringJDBC模板" class="headerlink" title="使用SpringJDBC模板"></a>使用SpringJDBC模板</h2><p>·　　使用SpringJDBC模板特别简单，只需要两个步骤：</p><ol><li>配置DriverManagerDataSource连接池，并注入jdbcTemplate对象</li><li>使用JdbcTemplate对象来进行数据库的交互<ul><li>JdbcTemplate的使用几乎和dbutils一样，查询用query，增删改用update，参数也是差不多。其中查询操作，DButils使用的返回值接口是ResultSetHandle&lt; T &gt;,而Spring所用的接口是RowMapper&lt; T &gt;，我们一般用其实现类<font color="red">BeanPropertyRowMaper&lt; T &gt; </font></li></ul></li></ol><h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><ul><li>引入jar包,Maven依赖如下</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--用于Spring整合tesng测试--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.testng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testng<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用SpringJDBCTemplate--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>把DataSource和jdbcTemplate交给SpringIOC去管理（非自己定义的bean用xml创建），同时开启组件扫描，xml完整配置如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contxt</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contxt:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springaop"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>创建数据库springaop，并创建客户表t_account</li></ul><div class="table-container"><table><thead><tr><th>id</th><th>aname</th><th>money</th></tr></thead><tbody><tr><td>1</td><td>cxy</td><td>2000.0</td></tr><tr><td>2</td><td>lhw</td><td>2000.0</td></tr></tbody></table></div><ul><li>编写Account端的操作，只编写通过客户姓名查询以及更新客户的操作（因为事务管理要用）</li></ul><p><strong>//AccountDao</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.memoforward.domain.Account;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>//AccountDaoImpl</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>...;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"accountDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">AccountDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Account <span class="title">findAccountByName</span><span class="params">(String accountName)</span> </span>&#123;</span><br><span class="line">        List&lt;Account&gt; aList = jdbcTemplate.query(<span class="string">"select * from t_account where aname = ?"</span>, <span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account<span class="class">.<span class="keyword">class</span>), <span class="title">accountName</span>)</span>;</span><br><span class="line">        <span class="keyword">if</span>(aList.size() != <span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"查询失败..."</span>);</span><br><span class="line">        <span class="keyword">return</span> aList.get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">        jdbcTemplate.update(<span class="string">"update t_account set aname=?,money=? where id = ?"</span>,account.getAname(),account.getMoney(),account.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>`　　可见，SpringTemplate还是相当简单的，没有什么特殊的思想，对开发来说并没有方便很多，这里就不进行测试了。<br>·　　<font color="red">这里注意一下：</font><del>JDBC实现了threadLocal，所以即使它是单例的，也是线程安全的 (说实话我不是很懂….，以后成长起来再来解释一下)</del>，它会根据当前的线程去取数据库的连接。</p><h1 id="Spring实现事务管理"><a href="#Spring实现事务管理" class="headerlink" title="Spring实现事务管理"></a>Spring实现事务管理</h1><p>·　　有关事务管理的内容，不是本博客的重点，本篇文章只是略微介绍一下Spring事务管理的使用（因为这个是相当的方便）。Spring事务管理是基于AOP的，用来增强业务层的业务逻辑，有兴趣可以参考我关于AOP的教程：<a href="https://memoforward.github.io/2019/08/31/SpringIOC%E5%AE%9E%E6%88%98%EF%BC%88xml-%E6%B3%A8%E8%A7%A3%EF%BC%89/" target="_blank" rel="noopener">SpringAOP实战</a>。</p><h2 id="进行事务管理的原因"><a href="#进行事务管理的原因" class="headerlink" title="进行事务管理的原因"></a>进行事务管理的原因</h2><p>·　　虽然不着重讲事务管理的细节，但是这里给出一个特别经典的案例：<strong>转帐案例</strong>，来表明事务管理的重要性。<br>·　　我们在业务层实现一个转账方法，并设置一点小细节：模拟在转账过程中的停电事件，停电的时间点在：甲方已经转账成功，但乙方还未收到钱。停电事件用一个flag控制。<br>业务层实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>...;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Double money, <span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">        Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">        source.setMoney(source.getMoney() - money);</span><br><span class="line">        target.setMoney((target.getMoney() + money));</span><br><span class="line">        accountDao.update(source);</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"断电了...."</span>);</span><br><span class="line">        accountDao.update(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们设置flag为true，并进行转账：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testTranser</span><span class="params">()</span></span>&#123;</span><br><span class="line">    accountService.transfer(<span class="string">"cxy"</span>,<span class="string">"lhw"</span>,<span class="number">1000.0</span>,<span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据库里的金额就变成了：可见1号的钱少了，结果2号的钱没多。</p><div class="table-container"><table><thead><tr><th>id</th><th>aname</th><th>money</th></tr></thead><tbody><tr><td>1</td><td>cxy</td><td>1000.0</td></tr><tr><td>2</td><td>lhw</td><td>2000.0</td></tr></tbody></table></div><p>造成这种现象的原因很简单，因为<B>：业务层会调用持久层（DAO）的方法，默认情况是：每次dao层的方法执行结束之后，事务都被自动提交了。</B><br>·　　因此，就需要对这个转账方法进行事务的管理：开启事务，如果异常就回滚，不异常就用提交，最后是释放连接。我在之前的文章里，用动态代理实现了事务管理，有兴趣可以参考一下：<a href="https://memoforward.github.io/2019/09/01/Java%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%A7%A3%E9%87%8A/" target="_blank" rel="noopener">Java两种动态代理实战+动态代理死循环的解释</a>。<br>·　　因为Spring中声明事务管理是基于aop的，所以很显然，事务管理的内容必然就是一个advice通知。而相比普通的切面，事务管理很常用，因此spring就自己把其封装了。</p><h2 id="xml的事务管理配置"><a href="#xml的事务管理配置" class="headerlink" title="xml的事务管理配置"></a>xml的事务管理配置</h2><ul><li>首先还是要引入相应的jar包：<strong>spring-tx和aspectjweaver</strong>，一个是事务管理的依赖，一个是用于识别切入点表达式。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置步骤：</li></ul><ol><li>配置事务管理器(DataSourceTransactionManagement)并注入Datasource。（事务管理器的接口是PlatformTransactionManagement）</li><li>配置事务通知&lt; tx:advice &gt;并将事务管理器添加至标签属性</li><li>配置aop，写切入点表达式并用&lt; aop: advisor &gt;引入事务通知</li><li>在事务通知下配置子标签&lt; tx:attributes &gt; ，在&lt; tx:attrributes &gt;标签下用&lt; tx:method &gt;配置业务方法（只有配置了切入点才能知道增强哪个包的方法，因此这步在最后）</li></ol><ul><li>xml配置如下：注意事务管理是业务层的和持久层没有关系。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contxt</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contxt:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 1.配置事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManagement"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 2.配置事务通知并引入事务管理器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"txAdvice"</span>  <span class="attr">transaction-manager</span>=<span class="string">"txManagement"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 4.配置事务增强属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 6.对不同的方法进行不同的事务管理--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 3.开启aop并引入事务通知--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.memoforward.service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"txAdvice"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springaop"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>关于&lt; tx:method &gt;的属性：这个标签是针对不同的方法进行不用的事务增强而设计出来的，spring为其提供了6种属性：</li></ul><div class="table-container"><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>isolation</td><td>用于指定事务的隔离级别。默认是数据库的默认隔离级别。</td></tr><tr><td>propagation</td><td>用于指定事务的传播行为。默认值是：REQUIRED，表示一定会开启事务。也有SUPPORTS表示支持当前事务（如果当面没有事务，则不开启事务），一般用于查询方法。</td></tr><tr><td>read-only</td><td>用于指定事务是否只读。只有查询方法才能是true。</td></tr><tr><td>timeout</td><td>用于指定事务的超时时间，默认是-1，表示永不超时。设置的单位级别是秒。</td></tr><tr><td>rollback-for</td><td>用于指定一个异常，当产生该异常时，事务回滚，产生其他异常，事物不回滚。不设置则所有异常都回滚 。</td></tr><tr><td>no-rollback-for</td><td>用于指定一个异常，当产生该异常时，事务不回滚，产生其他异常，事物回滚。不设置则所有异常都回滚 。</td></tr></tbody></table></div><ul><li>结果：这就不进行测试了，因为非常简单。当配置了如上的事务后，在“转账”操作未结束的时候，所有的dao方法都不会提交，因此保证了转账的安全性。</li></ul><h2 id="注解配置"><a href="#注解配置" class="headerlink" title="注解配置"></a>注解配置</h2><p>·　　Spring事务管理同样也可以进行注解配置，注解配置比较简单，但是有不方便的地方。<br>·　　Spring进行注解配置的步骤是：</p><ol><li>配置事务管理器</li><li>开启Spring对注解配置事务的支持（&lt; tx:annotation-driven &gt;）,纯注解配置的话在配置类上用@EnableTransactionManagement来开启。</li><li>在需要事务支持的地方使用@Transactional，其属性就是上述标签&lt; tx:method &gt; 的属性。这个注解用在类上表示此种事务对该类的所有方法都生效；用在方法上表示：此种事务仅对该方法生效。<font color="red">注意：</font>我还不太清楚如果使用该注解对不同的事务管理器进行操作。</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:contxt</span>=<span class="string">"http://www.springframework.org/schema/context"</span> <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">contxt:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"txManagement"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"txManagement"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springaop"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其业务层改为如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"accountService"</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@Transactional</span>(readOnly = <span class="keyword">true</span>, propagation = Propagation.SUPPORTS)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">AccountService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    AccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="meta">@Transactional</span>(readOnly = <span class="keyword">false</span>, propagation = Propagation.REQUIRED)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(String sourceName, String targetName, Double money, <span class="keyword">boolean</span> flag)</span> </span>&#123;</span><br><span class="line">        Account source = accountDao.findAccountByName(sourceName);</span><br><span class="line">        Account target = accountDao.findAccountByName(targetName);</span><br><span class="line">        source.setMoney(source.getMoney() - money);</span><br><span class="line">        target.setMoney((target.getMoney() + money));</span><br><span class="line">        accountDao.update(source);</span><br><span class="line">        <span class="keyword">if</span>(flag) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"断电了...."</span>);</span><br><span class="line">        accountDao.update(target);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果：进行了该注解配置后，转账操作也正常回滚了。</li></ul><h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>·　　Spring声明式事务管理十分有用，用起来很方便，就是需要记忆的部分有点多，不过孰能生巧，多练多写才是王道。这里Spring有关业务层的内容就全部结束。我最近也变的很忙，关于java后台的学习笔记也要稍微停滞一段时间。闲暇之余可能会更新一些有关深度学习的内容（<del>为了毕业</del>），加油吧。</p><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文主要涉及如下知识点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SpringJDBC模板实战&lt;/li&gt;
&lt;li&gt;Spring基于XML配置实现事务管理&lt;/li&gt;
&lt;li&gt;Spring基于注解配置实现事务管理&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringAOP实战</title>
    <link href="http://yoursite.com/2019/09/02/SpringAOP%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2019/09/02/SpringAOP%E5%AE%9E%E6%88%98/</id>
    <published>2019-09-02T13:19:11.000Z</published>
    <updated>2020-03-07T12:24:54.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文主要涉及如下知识点</p><ol><li>SpringAOP的基本概念</li><li>基于XML配置的SpringAOP实战</li><li>基于注解配置的SpringAOP实战</li><li>环绕通知</li></ol></blockquote><a id="more"></a><h1 id="AOP的概念"><a href="#AOP的概念" class="headerlink" title="AOP的概念"></a>AOP的概念</h1><p>·　　AOP(Aspect Oriented Programming)面向切面编程，是OOP面向对象编程的升级，AOP是基于OOP的。OOP比较好理解，生活中万物都是对象，但是AOP乍一看不是很好理解。不过没关系，我稍微一点拨，肯定就能懂。<br>·　　说到底，其实就是“切面”这个概念我们不熟悉，我的理解是这样的：<strong>切面是某种对象的共同特征</strong>。什么意思呢？我举个简单的例子：我们一生中会玩很多的游戏，每个游戏都在不同的平台，那我们每次玩游戏，都要登录某个平台。<strong>面向对象编程的思维是这样的</strong>：我们这个人，就是一个对象，而我们玩游戏，就是这个对象使用了某种方法，所以在编程时我们把<B>“人”这个概念抽取成了对象，把“玩游戏”这个概念抽取成一个个不同的方法</B>。而在这个基础上，<strong>面向切面的编程方式</strong> 被提出了，因为我们发现，我们有无数种对应玩游戏的方法，但是每一种方法我们都需要进行登录的操作，所以我们把<B>“登录”这个操作抽取出来，称作是所有”玩游戏”方法的切面，而每个玩游戏的方法，就是一个个切入点</B>。<br>·　 　可见，“登录”是所有“玩游戏”方法的共同特征，所以切面这个概念不如对象一般直观，因为，所有的切面都是人为抽取出来的，具有一定的思考性。而<strong>面向切面编程</strong>最重要的两个优势在于：1.可以简化代码量；2.可以让业务代码仅关注业务逻辑，使代码结构更清晰。<br>·　　不管是哪一种优势，对于开发来说，都是至关重要的。</p><h1 id="切面的一些专业术语"><a href="#切面的一些专业术语" class="headerlink" title="切面的一些专业术语"></a>切面的一些专业术语</h1><p>·　　SpringAOP的实现是基于动态代理的，本人写过一遍有关动态代理的教程：<a href="https://memoforward.github.io/2019/09/01/Java%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%A7%A3%E9%87%8A/" target="_blank" rel="noopener">Java两种动态代理实战+动态代理死循环的解释</a>。<br>·　　要会看的懂SpringAOP的相关文档就必须懂有关切面的相关术语，<strong>首先Aspect就是切面</strong>的意思。这<del>个要是不知道，就快先去把6级考了再说。**</del><br><strong>术语如下：</strong></p><div class="table-container"><table><thead><tr><th>术语</th><th>含义</th></tr></thead><tbody><tr><td>joinpoint 连接点</td><td>可以被拦截到的方法，但不一定会被增强</td></tr><tr><td>pointcut 切入点</td><td>被增强的方法（可见切入点一定是连接点，而反之则不然）</td></tr><tr><td>advice 通知（增强）</td><td>指在拦截到切入点后，如何增强某个方法</td></tr><tr><td>target</td><td>指被代理的对象</td></tr><tr><td>weaving 织入</td><td>指一个过程：增强某个类并形成代理类的过程</td></tr><tr><td>proxy 代理</td><td>一个类被织入后，就生成了一个代理类</td></tr><tr><td>aspect 切面</td><td>指切入点和通知的结合</td></tr></tbody></table></div><p>·　　如果你能把上述玩游戏的例子和这里的术语对应上，那你术语部分就过关啦！<br><strong>其中advice术语是实现aop的关键，其有五种通知类型：</strong></p><ul><li>１．前置通知（before）：只在原方法之前调用的增强</li><li>２．后置通知（after-returning）：原方法完成之后调用的增强</li><li>３．异常通知（after-throwing）：原方法出异常后调用的增强</li><li>４．最终通知（after）：不管怎么样都会调用的增强，最后才会调用</li><li>５．环绕通知（around）：通过写代码来实现对切入点的管理（以上一般都是用配置，来决定顺序），环绕通知一般用于注解开发。</li></ul><h1 id="SpringAOP实战"><a href="#SpringAOP实战" class="headerlink" title="SpringAOP实战"></a>SpringAOP实战</h1><p>·　　本来想搞利用aop实现事务的管理的，不过既然在开头用了玩游戏的例子，那么索性，这里的案例就用玩游戏了。<br>·　　<strong>需求如下</strong>：玩家只需要关注玩游戏就行。代理类的任务在于：在玩游戏<strong>之前实现登录操作</strong>，游戏结束<strong>后执行退出操作</strong>，如果玩游戏途中<strong>出现了游戏BUG，就执行回档操作（异常）</strong>，最终不管怎么样，玩游戏是要钱的，<strong>最后要执行扣钱操作。</strong></p><h2 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h2><p>·　　引入jar包，<strong>aop需要的jar包是aspectjweaver</strong>，用于解析切入点表达式（下文会讲）以及spring-aop（这个一般引入spring-context依赖就会自己引入了），然后什么ioc的包等等，我就不说了，这次案例会用到一点点的IOC的知识，如果不会，可以参考我的IOC教程<a href="https://memoforward.github.io/2019/08/31/SpringIOC%E5%AE%9E%E6%88%98%EF%BC%88xml-%E6%B3%A8%E8%A7%A3%EF%BC%89/" target="_blank" rel="noopener">SpringIOC实战（xml+注解）</a>。</p><ul><li>依赖如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置玩家类(由Spring进行管理)<br>可见我们希望切面能增强所有玩游戏的方法，而不增强吃饭这个方法，其中我们看见玩LOL时会出现异常。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.player;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Player</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playLOL</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩英雄联盟..."</span>);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"LOL崩溃了...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playDota2</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩Dota2..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playWOW</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩魔兽世界..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">playTaiWu</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"玩太吾绘卷..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"游戏玩累了，吃饭..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>配置通知类（由Spring进行管理）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"playerAdvice"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerAdvice</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.登录</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---1.游戏登录---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//2.退出</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---2.游戏退出---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//3/异常回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---3.游戏回档---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//4.扣钱</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loseMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---4.游戏扣费---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="用XML配置切面"><a href="#用XML配置切面" class="headerlink" title="用XML配置切面"></a>用XML配置切面</h2><p>·　　使用SpringAOP需要在xml文件中引入aop的约束，这里就不贴了。<br>·　　关于XML配置，共有如下的几个标签需要用到。</p><div class="table-container"><table><thead><tr><th>标签名</th><th>属性</th><th>作用</th><th>层级</th></tr></thead><tbody><tr><td>aop:config</td><td>无</td><td>开启aop的控制</td><td>1</td></tr><tr><td>aop:pointcut</td><td>id：指切入点表达式的id；expression：写切入点表达式</td><td>告诉切面将增强哪些方法（切入点）</td><td>2或3</td></tr><tr><td>aop:aspect</td><td>id：该切面的id；ref：该切面对应的通知类</td><td>声明一个切面</td><td>2</td></tr><tr><td>aop : before</td><td>method：该前置通知对应在通知类中的方法；pointcut-ref：切入点表达式id / pointcut：切入点表达式</td><td>声明一个前置通知</td><td>3</td></tr><tr><td>aop : after-returning</td><td>和上面类似</td><td>声明一个后置通知</td><td>3</td></tr><tr><td>aop : after-throwing</td><td>和上面类似</td><td>声明一个异常通知</td><td>3</td></tr><tr><td>aop : after</td><td>和上面类似</td><td>声明一个最终通知</td><td>3</td></tr></tbody></table></div><ul><li><strong>有关切入点表示的补充</strong><br>·　 切入点表达式有关键字：execution。在关键字内部写表达式，规则是：<strong>（访问修饰符 返回值 全限定类名.方法名）</strong>，且不同的execution之间可以用<strong>and、or、！</strong>等关键字来增强表达式的逻辑。</li></ul><p><strong>举个例子</strong>：如果要切入点要选Player类中的playLOL方法，则表达式可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(<span class="keyword">public</span> <span class="keyword">void</span> com.memoforward.player.Player.playLOL())</span><br></pre></td></tr></table></figure><p>·　　显然这么写太复杂了，因此有如下的简化措施：</p><ol><li>访问修饰符可省略</li><li>返回值可以用通配符<B> * </B> 表示任意返回值类型</li><li>包名可以用 <B> * </B>表示任意一个包；用 <B> *. </B>表示当前包及其所有子包</li><li>类名和方法名都可以用<B> * </B>表示任意类和任意方法</li><li>可用 <B>(．.) </B>表示任意参数和任意参数类型（如果不想用用任意类型，基础类型可以直接写，引用类型用 ‘包名.类名’ 的方式）</li></ol><p>`　　因此有全通配写法：该项目下所有包的所有方法（不推荐使用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">execution(* *..*.*(..))</span><br></pre></td></tr></table></figure><ul><li>一般情况下：我们只需要切到业务层实现类下的所有方法就可以了。</li></ul><h2 id="xml配置文件如下"><a href="#xml配置文件如下" class="headerlink" title="xml配置文件如下"></a>xml配置文件如下</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--&lt;aop:pointcut id="pt2" expression="..."/&gt;--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"playerAdvice"</span> <span class="attr">ref</span>=<span class="string">"playerAdvice"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt1"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.memoforward.player.*.*(..)) and !execution(* com.memoforward.player.*.eat(..))"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"login"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-returning</span> <span class="attr">method</span>=<span class="string">"quit"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after-throwing</span> <span class="attr">method</span>=<span class="string">"rollback"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"loseMoney"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><strong>注意事项：</strong><ol><li>用了两个execution语句实现了增强 除了eat方法外的所有方法。</li><li>注意切入点表达式的位置：如果在&lt; aop: aspect &gt;标签内，则这个表达式只对这个切面生效；如果在切面标签外，则对所有切面生效，但其必须要声明在切面之前。</li></ol></li></ul><h2 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:beans.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testSpringAOP</span> <span class="keyword">extends</span> <span class="title">AbstractTestNGSpringContextTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Player player;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAOP01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player.eat();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playDota2();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playTaiWu();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playWOW();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playLOL();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果如下：可见除了eat方法，其他方法都被增强了，而且出异常的LOL也成功进行了游戏回档。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">游戏玩累了，吃饭...</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩Dota2...</span><br><span class="line">--<span class="number">-2.</span>游戏退出---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩太吾绘卷...</span><br><span class="line">--<span class="number">-2.</span>游戏退出---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩魔兽世界...</span><br><span class="line">--<span class="number">-2.</span>游戏退出---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩英雄联盟...</span><br><span class="line">--<span class="number">-3.</span>游戏回档---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: LOL崩溃了....</span><br></pre></td></tr></table></figure><h2 id="基于注解的AOP开发"><a href="#基于注解的AOP开发" class="headerlink" title="基于注解的AOP开发"></a>基于注解的AOP开发</h2><ul><li>基于注解的开发有两个步骤：</li></ul><ol><li>在配置文件中开启aop自动代理权限</li><li>配置切面的通知类</li></ol><ul><li>配置文件开启权限</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>配置切面通知类：@Aspect；@Pointcut；以及各种通知注解，很简单。<br><strong>注意：切入点表达式需要把 and 换成 &amp;&amp;</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(<span class="string">"playerAdvice02"</span>)</span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PlayerAdvice02</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Pointcut</span>(<span class="string">"execution(* com.memoforward.player.*.*(..)) &amp;&amp; !execution(* com.memoforward.player.*.eat(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">pt1</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//1.登录</span></span><br><span class="line">    <span class="meta">@Before</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---游戏登录---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//2.退出</span></span><br><span class="line">    <span class="meta">@AfterReturning</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---游戏退出---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//3/异常回滚</span></span><br><span class="line">    <span class="meta">@AfterThrowing</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---游戏回档---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//4.扣钱</span></span><br><span class="line">    <span class="meta">@After</span>(<span class="string">"pt1()"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loseMoney</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"---游戏扣费---"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试如下：此时已经换成了PlayerAdvice02切面。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> ...;</span><br><span class="line"></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:beans.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testSpringAOP</span> <span class="keyword">extends</span> <span class="title">AbstractTestNGSpringContextTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    Player player;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAOP</span><span class="params">()</span></span>&#123;</span><br><span class="line">        player.eat();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playTaiWu();</span><br><span class="line">        System.out.println(<span class="string">"*************"</span>);</span><br><span class="line">        player.playLOL();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结果如下</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">游戏玩累了，吃饭...</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩太吾绘卷...</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">--<span class="number">-2.</span>游戏退出---</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩英雄联盟...</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">--<span class="number">-3.</span>游戏回档---</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: LOL崩溃了....</span><br></pre></td></tr></table></figure><ul><li><font color="red"><b>问题</b></font><br>·　　仔细一点就能发现，<strong>最终通知和后置通知的顺序反了</strong>，这是注解开发的一个大问题，目前还没有被修复，因此如果要用注解开发的话，一般使用<strong>环绕通知</strong>的方式，所谓环绕通知和动态代理的实现方法基本没什么区别。下面将简单介绍一下：</li></ul><h2 id="环绕通知"><a href="#环绕通知" class="headerlink" title="环绕通知"></a>环绕通知</h2><p>·　　环绕通知和动态代理的内部几乎是一样的写法，不同的点在于：动态代理的参数包含了被代理类的字节码对象；而在环绕通知中，因为Spring已经管理的被代理的类，因此就不必我们手动提供了，取而代之的，是<strong>Spring提供的的一个接口：ProceedingJoinPoint</strong>，此接口有两个方法，一个是获取被代理类方法的参数，一个是调用被代理类的方法。<br>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Around</span>(<span class="string">"pt1()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">playerAdvice</span><span class="params">(ProceedingJoinPoint pjp)</span></span>&#123;</span><br><span class="line">    Object obj = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        login();</span><br><span class="line">        obj = pjp.proceed(args);</span><br><span class="line">        quit();</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    <span class="comment">//注意pjp对象的方法需要用Throwable来处理异常</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        rollback();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(throwable);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        loseMoney();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果如下：可见执行顺序已经恢复正常</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">游戏玩累了，吃饭...</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩太吾绘卷...</span><br><span class="line">--<span class="number">-2.</span>游戏退出---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line">*************</span><br><span class="line">--<span class="number">-1.</span>游戏登录---</span><br><span class="line">玩英雄联盟...</span><br><span class="line">--<span class="number">-3.</span>游戏回档---</span><br><span class="line">--<span class="number">-4.</span>游戏扣费---</span><br><span class="line"></span><br><span class="line">java.lang.RuntimeException: java.lang.RuntimeException: LOL崩溃了....</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　SpringAOP说难不难，但是重要的是这种面向切面的编程思想以及动态代理。Spring还剩最后一项事务管理。我会在下一次博客把它补上。</p><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文主要涉及如下知识点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SpringAOP的基本概念&lt;/li&gt;
&lt;li&gt;基于XML配置的SpringAOP实战&lt;/li&gt;
&lt;li&gt;基于注解配置的SpringAOP实战&lt;/li&gt;
&lt;li&gt;环绕通知&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java两种动态代理实战+动态代理死循环的解释</title>
    <link href="http://yoursite.com/2019/09/01/Java%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%A7%A3%E9%87%8A/"/>
    <id>http://yoursite.com/2019/09/01/Java%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%A7%A3%E9%87%8A/</id>
    <published>2019-09-01T03:17:39.000Z</published>
    <updated>2020-03-07T12:22:19.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇文章主要涉及两个知识点</p><ol><li>Java中基于接口和子类的动态代理实现</li><li>动态代理死循环的出现原因以及解决方法</li></ol></blockquote><a id="more"></a><h1 id="动态代理的概念和作用"><a href="#动态代理的概念和作用" class="headerlink" title="动态代理的概念和作用"></a>动态代理的概念和作用</h1><p>·　　动态代理是SpringAOP的实现方式，因此要深入理解SpringAOP就必须要深入理解动态代理机制。<br>·　　<strong>什么是代理</strong>：谈动态的代理，不得不谈代理概念，而<strong>动态代理就是在运行阶段创建代理对象（通过字节码创建，十分有效率）</strong>。代理可以理解成中介的意思，当我们买电脑的时候不去电脑的生产厂商买，而是去淘宝买的时候，这里的淘宝就是代理，其代理的对象就是电脑厂商。当有了代理之后，用户一般就只和代理交互了。<br>·　　代理最大的两个作用就是：１．在不改变原来对象的代码上，对该对象进行增强。２．业务层的对象只需要考虑业务逻辑，而不必考虑其他的逻辑。举个简单的例子：我们在操作数据库的时候，都需要进行事务的管理，而事务的逻辑和业务层的逻辑显然是不同的，因此可以用代理的模式去实现两个逻辑的分离。<br>·　　<strong>本博客的案例就是</strong>：用动态代理的方式去增强业务层的方法，实现业务层的事务管理。</p><p>·　　要看死循环问题的朋友请戳：<a href="#pro">动态代理的死循环问题</a></p><h1 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h1><h2 id="动态代理的实现方式"><a href="#动态代理的实现方式" class="headerlink" title="动态代理的实现方式"></a>动态代理的实现方式</h2><p>·　　动态代理有两种实现方式：</p><ol><li>第一种是JDK提供的基于接口的动态代理，要求被代理的类必须至少实现一个接口</li><li>第二种是第三方cglib提供的基于子类的动态代理，要求被代理类不能被final修饰（因为被final修饰的类不能被继承）导入cglib依赖(asm包)。</li></ol><h2 id="编写必要的类"><a href="#编写必要的类" class="headerlink" title="编写必要的类"></a>编写必要的类</h2><ul><li>1．业务层接口和实现类：该类的编写与<a href="https://memoforward.github.io/2019/08/31/SpringIOC%E5%AE%9E%E6%88%98%EF%BC%88xml-%E6%B3%A8%E8%A7%A3%EF%BC%89/" target="_blank" rel="noopener">SpringIOC实战（xml+注解）</a>中StudentService一模一样。这里就不贴了。<br>使用Spring注入数据源和QuerryRunner，配置文件如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springioc"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li><p>2．线程绑定获取连接的工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtils</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    DataSource ds;</span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Connection&gt; tl = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getConnection</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection conn = tl.get();</span><br><span class="line">        <span class="keyword">if</span>(conn == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                conn = ds.getConnection();</span><br><span class="line">                tl.set(conn);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> conn;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeThread</span><span class="params">()</span></span>&#123;</span><br><span class="line">        tl.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>3．有关事务管理的类</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注入连接工具</span></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    ConnectionUtils connUtils;</span><br><span class="line">    <span class="comment">//开启事务</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">beginTransaction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Connection conn = connUtils.getConnection();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//提交</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connUtils.getConnection().commit();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//回滚</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rollback</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            connUtils.getConnection().rollback();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//释放连接</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            connUtils.getConnection().close();</span><br><span class="line">            <span class="comment">//线程解绑</span></span><br><span class="line">            connUtils.removeThread();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用动态代理实现业务管理"><a href="#使用动态代理实现业务管理" class="headerlink" title="使用动态代理实现业务管理"></a>使用动态代理实现业务管理</h1><h2 id="不使用代理如何实现？"><a href="#不使用代理如何实现？" class="headerlink" title="不使用代理如何实现？"></a>不使用代理如何实现？</h2><ul><li>如果不使用动态代理，业务层的代码是这样写的（注入了txManager）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">findAllStudents</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        txManager.beginTransaction();</span><br><span class="line">        List&lt;Student&gt; stuList = stuDao.findAllStudents();</span><br><span class="line">        txManager.commit();</span><br><span class="line">        <span class="keyword">return</span>  stuList;</span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        txManager.rollback();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        txManager.release();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们希望在业务层只实现业务层的逻辑，即：我们希望只写这样的代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">findAllStudents</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> stuDao.findAllStudents();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>·　这就需要我们使用动态代理的技术，在不改变源码的基础上对Service类进行增强了。</p><h2 id="基于接口的动态代理的实现"><a href="#基于接口的动态代理的实现" class="headerlink" title="基于接口的动态代理的实现"></a>基于接口的动态代理的实现</h2><ul><li>1．使用<strong>Proxy类中的newProxyInstance静态方法</strong>来创建代理，被代理类至少要实现是一个接口。</li><li>2．该方法有三个参数一个返回值：</li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>作用</th><th>如何构造</th></tr></thead><tbody><tr><td>Classloader</td><td>用于加载代理对象的字节码，与被代理对象的类加载器相同</td><td>被代理对象.getClass().getClassLoader()</td></tr><tr><td>Class[]</td><td>用于让代理对象实现被代理对象的所有方法</td><td>被代理对象.getClass().getInterfaces()</td></tr><tr><td>InvocationHandle接口对象</td><td>用代理对象对原对象的方法进行增强</td><td><strong>实现该接口对象的invoke方法来对原方法进行增强（一般用匿名内部类的方式实现）</strong></td></tr><tr><td>返回值 return</td><td>返回一个Object对象，需要强转成被代理的对象类型。<del>可以把代理对象看成是一个与被代理对象实现相同接口的增强类（可以这么理解，但实际上还有些区别）</del></td><td>\</td></tr></tbody></table></div><p>·　　其中，invoke方法有三个入参，分别是：</p><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>Object proxy</td><td>代理对象的引用</td></tr><tr><td>Method method</td><td>通过字节码获得的需要被增强的方法的引用</td></tr><tr><td>Object[] args</td><td>被增强的方法的入参</td></tr></tbody></table></div><p><strong>值得注意的是：</strong> 通过method.invoke调用的方法，始终会返回一个Object类型。也就是说，如果原方法返回void就放回null，如果原方法放回基本类型，就返回包装类。</p><ul><li>实现动态的ServiceProxy类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.proxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceProxy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentService stuService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TransactionManager txManager;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类似用&lt;bean factory-bean&gt;来创建bean</span></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"stuServiceProxy"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentService <span class="title">getStuServiceProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (StudentService)Proxy.newProxyInstance(</span><br><span class="line">        stuService.getClass().getClassLoader(), </span><br><span class="line">        stuService.getClass().getInterfaces(),</span><br><span class="line">                <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                        Object obj = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">try</span>&#123;</span><br><span class="line">                        <span class="comment">//开启事务</span></span><br><span class="line">                            txManager.beginTransaction();</span><br><span class="line">                            <span class="comment">//执行业务逻辑</span></span><br><span class="line">                            obj = method.invoke(stuService,args);</span><br><span class="line">                            <span class="comment">//提交事务</span></span><br><span class="line">                            txManager.commit();</span><br><span class="line">                            <span class="keyword">return</span> obj;</span><br><span class="line">                        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                        <span class="comment">//异常回滚</span></span><br><span class="line">                            txManager.rollback();</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//释放连接</span></span><br><span class="line">                            txManager.release();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>为了观测到业务层的方法被执行，将业务层代码改为：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">findAllStudents</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"方法被执行了...."</span>);</span><br><span class="line">    <span class="keyword">return</span> stuDao.findAllStudents();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试：注入代理的对象的bean之后就可以直接使用了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpringAnnotation</span> <span class="keyword">extends</span> <span class="title">AbstractTestNGSpringContextTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"stuServiceProxy"</span>)</span><br><span class="line">    StudentService stuServiceProxy;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProxy</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">       stuServiceProxy.findAllStudents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果如下：可见事务管理被执行了，而业务层的代码并没有改变</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开启事务...</span><br><span class="line">方法被执行了....</span><br><span class="line">提交事务...</span><br><span class="line">释放连接...</span><br></pre></td></tr></table></figure><h2 id="基于子类的动态代理实现"><a href="#基于子类的动态代理实现" class="headerlink" title="基于子类的动态代理实现"></a>基于子类的动态代理实现</h2><p>·　　基于接口的代理要求被代理类必须实现至少一个接口，多多少少有些不方便。因此才有了这种基于接口的代理实现。<br>·　　其实，创建代理的方式和基于接口的代理步骤极为相似：</p><ul><li>1．使用<strong>Enhancer类的create静态方法</strong>创建代理对象</li><li>2．该方法有三个参数一个返回值</li></ul><div class="table-container"><table><thead><tr><th>参数</th><th>作用</th><th>如何构造</th></tr></thead><tbody><tr><td>Class</td><td>获得代理对象的字节码，有了字节码被代理类的所有信息都能得到</td><td>被代理对象.getClass()</td></tr><tr><td>Callback接口对象</td><td>用代理对象对原对象的方法进行增强</td><td><strong>一般实现其子类接口MethodIntereptor方法拦截器（实现有intercept方法）</strong></td></tr><tr><td>返回值 return</td><td>返回一个Object对象，需要强转成被代理的对象类型。</td><td>/</td></tr></tbody></table></div><p>·　　其中，intercept方法有三个入参，分别是：</p><div class="table-container"><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>Object o</td><td>代理对象的引用</td></tr><tr><td>Method method</td><td>通过字节码获得的需要被增强的方法的引用</td></tr><tr><td>Object[] objects</td><td>被增强的方法的入参</td></tr><tr><td>MethodProxy methodProxy</td><td>代理对象的方法对象，用来执行父类（即被代理的对象）的方法</td></tr></tbody></table></div><div id="pro"></div><h3 id="关于动态代理的死循环问题"><a href="#关于动态代理的死循环问题" class="headerlink" title="关于动态代理的死循环问题"></a>关于动态代理的死循环问题</h3><p>·　　我们看到基于子类的动态代理在实现拦截的时候，拦截方法多了一个入参：<strong>MethodProxy</strong>。这个方法从作用上讲，是和Method一样的：<br>·　１.　Method method是<strong>被代理对象的方法字节码</strong>对象。使用方法是：method.invoke(被代理对象，方法参数)<br>·　２．MethodProxy methodProxy是<strong>代理对象的方法字节码</strong>对象。使用方法是：methodProxy.invokeSuper(代理对象，方法参数）<br>使用methodProxy有两点好处：<br>·　１．不需要给代理对象传入被代理对象，效率更高。<br>·　２．不会出现死循环的问题。<br>·　　第一点无需解释了，invoke方法的入参就说明了这个问题。主要是第二点：让我们来回顾一下，什么时候态代理会出现死循环的问题？<strong>答：在实现拦截器的时候，又调用了代理对象的方法。</strong> 这是什么意思呢？用刚才基于接口的动态代理为例，如果我在inovke拦截放法中增加<strong>proxy.toString()</strong> 这一句话：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Proxy.newProxyInstance(xxx, xxx,</span><br><span class="line">              <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">                  <span class="meta">@Override</span></span><br><span class="line">                  <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                  ...</span><br><span class="line">                  proxy.toString();</span><br><span class="line">                  ...</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;);</span><br></pre></td></tr></table></figure><p>·　　就立刻会出现死循环的问题。为什么呢？<strong><font color="red">答案其实很简单:</font></strong> 因为，代理对象是没有自己的方法的，它的所有方法都是基于被代理对象，<strong>而调用代理对象方法的时候，都会经过拦截器方法。因此，如果在拦截器中再调用代理对象的方法，就会再次进入拦截器，这样就形成了死循环。</strong><br>·　　而基于子类的动态实现，是构建一个继承被代理对象的对象来实现代理的，因此其<strong>可以使用代理对象父类的方法（就是被代理对象）而不必经过拦截器</strong>，这就是上面所用的invokeSuper方法，用这种方法既可以不用注入被代理对象，又避免了死循环的问题，非常推荐使用！！<br>·　　<strong>但是这个方法有一个细节</strong>：不能用代理对象去使用没有在被代理对象中声明的方法，即使这个方法是其父类的，比如toString方法。即：如果代理对象想运行诸如toString这种方法，应当在被代理类中重写toString。因为：如果使用了父类的toString方法，methodProxy会自动去找父类Object，于是又生成了一次Object类的代理对象。语言比较枯燥，具体如下图：<br><img src="https://img-blog.csdnimg.cn/20190901173012817.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="问题"><br>·　可见，toString方法会被执行两次，两个输出的都不是同一个值，一个是根据Object的字节码输出的值，一个是根据被代理对象的字节码生成的值。因此，如果要使用原被代理对象父类的方法，则这个方法至少被增强两次。值得注意的是：在第8步中，有可能走到final也有可能走到exception。在本案例中，会在第7步时会抛出异常，<strong>因为在第6步执行完之后，该线程的连接被释放了，于是当方法执行完后，事务提交时会再申请一个没有被开启事务的链接（因为新的链接autoCommit默认是true）</strong>，因此提交会失败。</p><h3 id="生成代理对象的类"><a href="#生成代理对象的类" class="headerlink" title="生成代理对象的类"></a>生成代理对象的类</h3><p>·　　因为，基于子类的动态代理不需要接口，所以我们让StudentServiceImpl不再实现StudentService接口，从而直接获得StudentServicImpl对象（<del>其实就是因为我懒了，不想再写一个类了…</del> ）。生成代理类的工厂如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.cglib;</span><br><span class="line"><span class="keyword">import</span>...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServiceProxy</span> </span>&#123;</span><br><span class="line"><span class="comment">//  不再注入被代理对象</span></span><br><span class="line"><span class="comment">//    @Autowired</span></span><br><span class="line"><span class="comment">//    StudentServiceImpl stuService;</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    TransactionManager txManager;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(<span class="string">"stuServiceProxy02"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentServiceImpl <span class="title">createStuServiceProxy</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (StudentServiceImpl) Enhancer.create(StudentServiceImpl<span class="class">.<span class="keyword">class</span>, <span class="title">new</span> <span class="title">MethodInterceptor</span>() </span>&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                Object obj = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span>&#123;</span><br><span class="line">                    txManager.beginTransaction();</span><br><span class="line"><span class="comment">//                    obj = method.invoke(stuService,objects);</span></span><br><span class="line"><span class="comment">//可以对比一下这两种方式的优劣</span></span><br><span class="line">                    obj = methodProxy.invokeSuper(o,objects);</span><br><span class="line">                    txManager.commit();</span><br><span class="line">                    <span class="keyword">return</span> obj;</span><br><span class="line">                &#125;<span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">                    txManager.rollback();</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                    txManager.release();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试类注入新的代理对象并运行：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpringAnnotation</span> <span class="keyword">extends</span> <span class="title">AbstractTestNGSpringContextTests</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier</span>(<span class="string">"stuServiceProxy02"</span>)</span><br><span class="line">    StudentServiceImpl stuServiceProxy02;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testProxy02</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        stuServiceProxy02.findAllStudents();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果如下：成功！</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">开启事务...</span><br><span class="line">方法被执行了....</span><br><span class="line">提交事务...</span><br><span class="line">释放连接...</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　动态代理还是比工厂模式难很多的，但是这种面向切面的变成方式确实简化了重复无用的劳动，十分有趣。看到上面的两种实现方法，虽然大同小异，但是第三方的cglib肯定是要比原JDK的方法要先进一些的（<del>不然这个第三方还有什么存在的必要</del> ），而Spring的AOP也使用cglib来进行动态代理的。<br>·　　其实在写动态代理的时候，我们就已经感觉到了，虽然理解起来不是很难，但是写起来确实是很复杂啊，所以Spring用配置的方式来简化了我们的代码量，可谓功德无量。下一篇博客，我就会简单的讲解一下SpringAOP的使用。</p><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇文章主要涉及两个知识点&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Java中基于接口和子类的动态代理实现&lt;/li&gt;
&lt;li&gt;动态代理死循环的出现原因以及解决方法&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>SpringIOC实战（xml+注解）</title>
    <link href="http://yoursite.com/2019/08/31/SpringIOC%E5%AE%9E%E6%88%98%EF%BC%88xml-%E6%B3%A8%E8%A7%A3%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/31/SpringIOC%E5%AE%9E%E6%88%98%EF%BC%88xml-%E6%B3%A8%E8%A7%A3%EF%BC%89/</id>
    <published>2019-08-31T02:12:44.000Z</published>
    <updated>2020-03-07T12:25:18.573Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇文章涉及到了如下知识点：</p><ol><li>SpringIOC的概念和作用</li><li>通过XML配置进行SpringIOC实战</li><li>通过注解配置进行SpringIOC实战</li></ol></blockquote><a id="more"></a><h1 id="SpringIOC的概念及作用"><a href="#SpringIOC的概念及作用" class="headerlink" title="SpringIOC的概念及作用"></a>SpringIOC的概念及作用</h1><p>·　　<a href="https://baike.baidu.com/item/%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/1158025?fromtitle=ioc&amp;fromid=4853&amp;fr=aladdin" target="_blank" rel="noopener">百度百科的定义</a>：控制反转（Inversion of Control，缩写为IoC），是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。<br>·　　在我的上一篇博客<a href="https://memoforward.github.io/2019/08/29/Java%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/" target="_blank" rel="noopener">Java工厂模式实战</a>中讲到，工厂可以用来降低程序之间的耦合程度，而利用工厂来创建单例对象就是在工厂中构建了一了Map集合。SpringIOC就是这样的一个工厂，叫做<strong>IOC容器，本质上就是一个存放Bean对象的Map集合</strong>。与<a href="https://memoforward.github.io/2019/08/29/Java%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/" target="_blank" rel="noopener">Java工厂模式实战</a>博客中不同的是，SpringIOC是通过构造函数来读取配置文件的，这样的设定更加灵活。<br>·　　而SpringIOC的工厂接口就是ApplicationContext（在BeanFactory的基础上做了升级），其具体的实现类用来执行不同配置选项的加载。很显然，IOC容器是工厂模式附属品，作用自然就是给我们的程序解耦。<strong>其叫做控制翻转的真正含义就是</strong>：在书写程序时，我们放弃了创建对象的控制权（即：new一个新对象），把这个控制权转交给了Spring工厂去创建。注：在web项目中，我们创建的对象一般被叫做JavaBean，Bean不仅仅指一些实体对象，而是指<strong>所有可重复使用的</strong>的对象。<br>·　　注：本篇博客不涉及源码的解读，仅仅只是将IOC的配置和作用做了个总结。</p><h1 id="IOC的环境依赖"><a href="#IOC的环境依赖" class="headerlink" title="IOC的环境依赖"></a>IOC的环境依赖</h1><h2 id="需要导入的jar包"><a href="#需要导入的jar包" class="headerlink" title="需要导入的jar包"></a>需要导入的jar包</h2><p>·　　spring-context包，版本用最新的5.0以上。<br>·　　当引入这个依赖后之后，Maven会自动把所有的关键包都导入，如果要手动添加，需要添加的包如下图所示：<br><img src="https://img-blog.csdnimg.cn/20190830081015364.PNG" alt="jar包"><br>·　　这些包看名字就大致能知道是有什么作用，ioc需要用到的包是：beans（IOC管理），context（扩展），core（核心），expression（SpEL表达式）。而AOP是SpringAOP的必备包，而JCL是Spring整合JVM日志的一个包（一般不用）。</p><h2 id="本次案例的需求"><a href="#本次案例的需求" class="headerlink" title="本次案例的需求"></a>本次案例的需求</h2><p>·　　大家都知道Spring是用作web开发的框架，因此本次案例就针对业务层和持久层，利用Spring进行Bean的管理，来实现对数据库的增删改查。以下是要创建的类和数据库对象（为了方便，使用dbUtils包操作数据库）：</p><ul><li>数据库：springioc（包含t_stu表，字段为：sid（主键），sname，grade）<br><img src="https://img-blog.csdnimg.cn/20190830142331834.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="数据库"></li><li>持久层接口：StudentDao</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>持久层实现：StudentDaoImpl</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao.impl;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDaoImpl</span> <span class="keyword">implements</span> <span class="title">StudentDao</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StudentDaoImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"StudnetDaoImpl被创建了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学生被保存了...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务层接口：StudentService(调用持久层方法来实现业务逻辑，在数据CRUD中，两部分的功能是一模一样的)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service;</span><br><span class="line"><span class="keyword">import</span> com.memoforward.dao.StudentDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务层实现：StudentServiceImpl</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service.impl;</span><br><span class="line"><span class="keyword">import</span> com.memoforward.dao.StudentDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentServiceImpl</span> <span class="keyword">implements</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line">StudentDao stuDao;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentServiceImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"StudentServiceImpl被创建了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stuDao.save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="使用XML进行SpringIOC的配置"><a href="#使用XML进行SpringIOC的配置" class="headerlink" title="使用XML进行SpringIOC的配置"></a>使用XML进行SpringIOC的配置</h1><p>·　　既然IOC容器是用工厂进行了Bean的管理，那么我们自然就会想到用配置文件来告知Spring创建何种类的对象。<br>·　　Spring配置文件的基本约束和格式如下（理论上文件名可以任取，但一般是applicationContext.xml）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--创建Bean--&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>·　　在用加载配置文件，生成ApplicationContext工厂接口后就可以使用IOC来获取bean对象了。<br><strong>注意</strong>：<font color="red">使用ApplicationContext加载配置文件的同时，所有在配置文件中的单例bean就被创建了。</font></p><h2 id="bean的三种创建方式"><a href="#bean的三种创建方式" class="headerlink" title="bean的三种创建方式"></a>bean的三种创建方式</h2><ul><li>1．<strong>利用无参构造方法</strong>创建，给定全限定类名就行了。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1. 通过调用构造函数加载--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentDao01"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.dao.impl.StudentDaoImpl"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>2．如果<strong>另有一个类的方法可以生成这个bean</strong>，比如如下的：DaoFactory中的createStudentDao</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.memoforward.dao.StudentDao;</span><br><span class="line"><span class="keyword">import</span> com.memoforward.dao.impl.StudentDaoImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DaoFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> StudentDao <span class="title">createStudentDao</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StudentDao <span class="title">createStudentDaoByStaticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> StudentDaoImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>则可以有如下配置创建bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--2. 通过其他类的方法创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"daoFactory"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.factory.DaoFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentDao02"</span> <span class="attr">factory-bean</span>=<span class="string">"daoFactory"</span> <span class="attr">factory-method</span>=<span class="string">"createStudentDao"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>3．第三种方法是通过<strong>其他类的静态方法</strong>来创建，如DaoFactory的createStudentDaoByStaticMethod<br>则配置如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--3. 通过其他类的静态方法创建--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentDao03"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.factory.DaoFactory"</span> <span class="attr">factory-method</span>=<span class="string">"createStudentDaoByStaticMethod"</span>/&gt;</span></span><br></pre></td></tr></table></figure><ul><li>测试如下：加载配置后，三个bean都被创建成功了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBeanTest01</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试结果</span></span><br><span class="line">StudnetDaoImpl被创建了...</span><br><span class="line">StudnetDaoImpl被创建了...</span><br><span class="line">StudnetDaoImpl被创建了...</span><br></pre></td></tr></table></figure><h2 id="Bean的作用范围与生命周期"><a href="#Bean的作用范围与生命周期" class="headerlink" title="Bean的作用范围与生命周期"></a>Bean的作用范围与生命周期</h2><p>·　　这里的Bean的作用范围和生命周期与我的上一篇博客<a href="https://memoforward.github.io/2019/08/29/Java%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/" target="_blank" rel="noopener">Java工厂模式实战</a>里的对象一模一样，这里就不细讲了。<br>·　　在bean标签里表示作用范围的属性是：<strong>scope</strong>。值只需要记住两个：singleton（单例），prototype（多例）。<br>·　　能体现生命周期的属性是：init-method和destroy-method，分别表示该bean在创建和销毁时会调用的方法，一般不用。</p><h2 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h2><p>·　　我们在StudentServiceImpl中需要有一个StudentDao来带给业务层以持久层的逻辑，这时就需要我们把StudentDao的Bean注入到StudnetServiceImpl的对象中。<br>·　　利用XML配置文件的方式实现注入有两种方式：</p><ul><li>1．<strong>利用构造函数进行注入</strong><br>·　　在StudentServiceImpl中添加有参构造：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StudentServiceImpl</span><span class="params">(StudentDao stuDao)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.stuDao = stuDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　添加如下的配置，<strong>注入</strong>上面id为<strong>studentDao01</strong>的bean（设置成多例，测试方便）：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--1. 通过构造函数注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentService01"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.service.impl.StudentServiceImpl"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"stuDao"</span> <span class="attr">ref</span>=<span class="string">"studentDao01"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：&lt; constructor-arg &gt;标签有两种属性：<br>·　　 1)（表示要注入什么数据）name，index，type：分别表示要注入的数据的名称，在构造函数中的位置，数据的类型。我们一般用name属性。<br>·　　2)（表示数据具体的内容）value：注入String和基本数据类型；ref：注入其他的bean。</p><ul><li>2.　<strong>利用set方法来进行注入</strong><br>·　　在StudentServiceImpl方法中添加set方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setStuDao</span><span class="params">(StudentDao stuDao)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"StudentServiceImpl有参构造被调用了...."</span>);</span><br><span class="line">    <span class="keyword">this</span>.stuDao = stuDao;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　添加如下的配置，<strong>注入</strong>上面id为<strong>studentDao02</strong>的bean：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--2.通过set方法来注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentService02"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.service.impl.StudentServiceImpl"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"stuDao"</span> <span class="attr">ref</span>=<span class="string">"studentDao02"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>：&lt; property &gt;标签只有两种属性，其一是name，表示set的数据名称；其二是value/ref，和上述一样。</p><ul><li>测试如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDI</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">       System.out.println(<span class="string">"******************"</span>);</span><br><span class="line">       StudentService studentService01 = ac.getBean(<span class="string">"studentService01"</span>, StudentService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       studentService01.save();</span><br><span class="line">       System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">       StudentService studentService02 = (StudentService) ac.getBean(<span class="string">"studentService02"</span>);</span><br><span class="line">       studentService02.save();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试结果如下</span></span><br><span class="line">StudnetDaoImpl被创建了...</span><br><span class="line">StudnetDaoImpl被创建了...</span><br><span class="line">StudnetDaoImpl被创建了...</span><br><span class="line">******************</span><br><span class="line">StudentServiceImpl有参构造被调用了....</span><br><span class="line">学生被保存了....</span><br><span class="line">-----------------</span><br><span class="line">StudentServiceImpl被创建了...</span><br><span class="line">学生被保存了....</span><br></pre></td></tr></table></figure><ul><li><p>测试结果分析：<br>·　　单例的Bean会在配置文件被加载的同时被创建，多例bean会在被调用的时候被创建。同时，两种依赖也被成功注入了。</p></li><li><p>3．复杂类型的注入(不做测试了)<br>·　　配置框架如下：</p></li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--3.复杂类型的注入--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"xxx"</span> <span class="attr">class</span>=<span class="string">"xxx.xx.xxx"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"yyy"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>zzz<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>zzz<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>zzz<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"xx"</span> <span class="attr">value-type</span>=<span class="string">"?"</span> <span class="attr">value</span>=<span class="string">"yy"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key-ref</span>=<span class="string">"xxx"</span> <span class="attr">value-ref</span>=<span class="string">"xxx"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>·　　其中list,set,array实现基本一样，因此标签互换也是没有关系的；复杂数据类型的注入就是套路，记住就好了。</p><h2 id="XML配置总结"><a href="#XML配置总结" class="headerlink" title="XML配置总结"></a>XML配置总结</h2><p>·　　XML配置优点就是直观；但是缺点也比较明显：写起来比较复杂。<br>·　　为了能够简化配置文件，加快开发速度，IOC的注解开发也是不错的选择。</p><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a><font color="red">注意</font></h2><p>·　　当一个类中有被Spring注入的属性，那就不要自己再去new这个类的实例了，因为自己new出来的实例，里面的属性Spring并不会自动帮你注入,Spring只在它自己管理的Bean中注入属性。</p><h1 id="使用注解进行SpringIOC的配置"><a href="#使用注解进行SpringIOC的配置" class="headerlink" title="使用注解进行SpringIOC的配置"></a>使用注解进行SpringIOC的配置</h1><p>·　　使用注解和使用XML本质上一模一样，都是为了降低程序间的耦合。<br>·　　使用注解之后，一般就不必在配置文件中配置Bean了，但是需要在配置文件开启组件扫描，让Spirng在程序主方法运行前去扫描可能带有注解的包，并创建实例对象或者进行依赖的注入。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>·　　扫描包需要加入context约束，配置如下(扫描com.memoforward包及其子包)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><div class="table-container"><table><thead><tr><th>注解</th><th>功能</th><th>属性</th><th>作用位置</th></tr></thead><tbody><tr><td><font color="Blue"><strong>创建Bean的注解如下：</strong></font></td></tr><tr><td>@Componnet</td><td>创建对象的注解，和&lt; bean &gt;的功能相同</td><td>value：创建的beanId，默认为类名（首字母变小写）</td><td>一般作用在类上</td></tr><tr><td>@Controller/@Serivce/@Repository</td><td>针对MVC模式设计出来，功能同上，只是名字不一样</td><td>value：创建的beanId，默认为类名</td><td>一般作用在类上</td></tr><tr><td><font color="Blue"><strong>依赖注入的注解如下：</strong></font></td></tr><tr><td>@Autowired（最常用）</td><td>自动按类型注入，只要该类型在IOC容器中有唯一的bean对象</td><td>无</td><td>一般作用在成员变量和方法上（注入方法参数）</td></tr><tr><td>@Qulaifier</td><td>在按类型注入的基础上，再按照名称注入</td><td>value：beanId</td><td>能单独在方法上注入参数，但不能直接在类上使用（与@Autowired同用）</td></tr><tr><td>@Resource</td><td>直接按照bean 的id注入</td><td>name：beanId</td><td>类和方法上</td></tr><tr><td>@Value</td><td>注入String和基本类型</td><td>value：SpEL表达式</td><td>成员变量和方法上</td></tr><tr><td><font color="red"><strong>注意：集合类型只能xml注入</strong></font></td></tr><tr><td><font color="Blue"><strong>作用范围和生命周期相关的注解：</strong></font></td></tr><tr><td>@Scope</td><td>作用和&lt; bean &gt;中scope属性一样</td><td>value：singleton和prototype</td><td>作用在类上</td></tr><tr><td>@PreDestroy和@PostConstruct</td><td>bean对象创建和销毁时调用的方法</td><td>无</td><td>作用在方法上</td></tr></tbody></table></div><h2 id="修改上述的代码，改用注解"><a href="#修改上述的代码，改用注解" class="headerlink" title="修改上述的代码，改用注解"></a>修改上述的代码，改用注解</h2><ul><li>持久层接口：StudentDao</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>持久层实现：StudentDaoImpl（<strong>加上@Repository注解，表示这是一个持久层的Bean</strong>）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao.impl;</span><br><span class="line"><span class="keyword">import</span>...</span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"stuDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDaoImpl</span> <span class="keyword">implements</span> <span class="title">StudentDao</span></span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">StudentDaoImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"StudnetDaoImpl被创建了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学生被保存了...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务层接口：StudentService(调用持久层方法来实现业务逻辑，在数据CRUD中，两部分的功能是一模一样的)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service;</span><br><span class="line"><span class="keyword">import</span> com.memoforward.dao.StudentDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>业务层实现：StudentServiceImpl（<strong>加上@Service注解，表示这是一个业务层的Bean；@Autowired自动注入StudentDao属性</strong>）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service.impl;</span><br><span class="line"><span class="keyword">import</span>...</span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"stuService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentServiceImpl</span> <span class="keyword">implements</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentDao stuDao;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StudentServiceImpl</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"StudentServiceImpl被创建了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stuDao.save();</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="meta">@Test</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSpringIOCAnnotation</span><span class="params">()</span></span>&#123;</span><br><span class="line">       ApplicationContext ac = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"classpath:applicationContext.xml"</span>);</span><br><span class="line">       System.out.println(<span class="string">"******************"</span>);</span><br><span class="line">       StudentService stuService = ac.getBean(<span class="string">"stuService"</span>, StudentService<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       stuService.save();</span><br><span class="line">       System.out.println(<span class="string">"------------------"</span>);</span><br><span class="line">       StudentDao stuDao = ac.getBean(<span class="string">"stuDao"</span>, StudentDao<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">       stuDao.save();</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果如下：</span></span><br><span class="line">StudnetDaoImpl被创建了...</span><br><span class="line">StudentServiceImpl被创建了...</span><br><span class="line">******************</span><br><span class="line">学生被保存了....</span><br><span class="line">------------------</span><br><span class="line">学生被保存了....</span><br></pre></td></tr></table></figure><p>·由上述例子可见：配置文件被加载时，所有加上与@Component功能一致的注解的Bean被创建，且是单例的。同时@Autowired确实成功注入了对象。</p><h1 id="使用注解和XML的建议"><a href="#使用注解和XML的建议" class="headerlink" title="使用注解和XML的建议"></a>使用注解和XML的建议</h1><p>·　　实际工程中，建议使用“XML+注解”的开发模式，因为这种模式比较简单和直观。<br>·　　如果是我们自己创建的Bean对象，推荐使用注解。<br>·　　如果是jar包中的Bean对象，推荐使用XML进行开发。<br>·　　<strong>因此，我们的配置文件中一般会有两个内容：一个是需要开启组件扫描，另一个是第三方的bean（比如数据库的DataSource）</strong><br>·　　在第三章，我们介绍了纯XML的开发，在这篇博客的最后，我们再简单介绍一下纯注解式开发。接下来，我们将使用“XML+注解”实现第二章的案例需求。</p><h1 id="案例实现"><a href="#案例实现" class="headerlink" title="案例实现"></a>案例实现</h1><h2 id="添加增删改查方法"><a href="#添加增删改查方法" class="headerlink" title="添加增删改查方法"></a>添加增删改查方法</h2><p>·　　主要改动的地方有三处：添加学生Bean，修改StudentDao即它的实现类，修改StudentService即它的实现类。</p><ul><li>创建Student类，并提供set、get以及toString方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer sid;</span><br><span class="line">    <span class="keyword">private</span> String sname;</span><br><span class="line">    <span class="keyword">private</span> Double grade;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getSid</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSid</span><span class="params">(Integer sid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sid = sid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSname</span><span class="params">(String sname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sname = sname;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Double <span class="title">getGrade</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> grade;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setGrade</span><span class="params">(Double grade)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.grade = grade;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"sid="</span> + sid +</span><br><span class="line">                <span class="string">", sname='"</span> + sname + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", grade="</span> + grade +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>StudentService及实现</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.查询所有学生</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">findAllStudents</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.查询某个学生</span></span><br><span class="line">    <span class="function">Student <span class="title">findStudentBySid</span><span class="params">(Integer sid)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.添加某个学生</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(Student stu)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.删除某个学生</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteStudentBySid</span><span class="params">(Integer sid)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.修改某个学生</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(Student stu)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">注意：StudentServiceImpl类中注入了stuDao属性。</font><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"stuService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentServiceImpl</span> <span class="keyword">implements</span> <span class="title">StudentService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentDao stuDao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">findAllStudents</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuDao.findAllStudents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">findStudentBySid</span><span class="params">(Integer sid)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stuDao.findStudentBySid(sid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(Student stu)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        stuDao.addStudent(stu);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteStudentBySid</span><span class="params">(Integer sid)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        stuDao.deleteStudentBySid(sid);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(Student stu)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        stuDao.updateStudent(stu);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>StudentDao及它的实现类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.查询所有学生</span></span><br><span class="line">    <span class="function">List&lt;Student&gt; <span class="title">findAllStudents</span><span class="params">()</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.查询某个学生</span></span><br><span class="line">    <span class="function">Student <span class="title">findStudentBySid</span><span class="params">(Integer sid)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.添加某个学生</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(Student stu)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.删除某个学生</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deleteStudentBySid</span><span class="params">(Integer sid)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//5.修改某个学生</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(Student stu)</span> <span class="keyword">throws</span> SQLException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><font color="red">注意：StudentDaoImpl类中注入了QueryRunner对象</font>，该对象在第三方jar中，且其构造函数要传入数据库的数据源，因此在配置文件中<strong>还要创建两个bean，一个是QueryRunner，一个是C3p0的数据源对象</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Repository</span>(<span class="string">"stuDao"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StudentDaoImpl</span> <span class="keyword">implements</span> <span class="title">StudentDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    QueryRunner runner;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Student&gt; <span class="title">findAllStudents</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        List&lt;Student&gt; stuList = runner.query(<span class="string">"select * from t_stu"</span>, <span class="keyword">new</span> BeanListHandler&lt;Student&gt;(Student<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">        <span class="keyword">return</span> stuList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Student <span class="title">findStudentBySid</span><span class="params">(Integer sid)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        Student stu = runner.query(<span class="string">"select * from t_stu where sid = ?"</span>, <span class="keyword">new</span> BeanHandler&lt;Student&gt;(Student<span class="class">.<span class="keyword">class</span>), <span class="title">sid</span>)</span>;</span><br><span class="line">        <span class="keyword">return</span> stu;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addStudent</span><span class="params">(Student stu)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        runner.update(<span class="string">"insert into t_stu(sname,grade) values(?,?)"</span>,stu.getSname(),stu.getGrade());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteStudentBySid</span><span class="params">(Integer sid)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        runner.update(<span class="string">"delete from t_stu where sid = ?"</span>, sid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateStudent</span><span class="params">(Student stu)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        runner.update(<span class="string">"update t_stu set sname=?,grade=? where sid=?"</span>,stu.getSname(),stu.getGrade(),stu.getSid());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>QueryRunner的使用并不是我们今日讨论的重点，就不说了。</p><ul><li>由StudentDaoImpl的实现可知，我们的xml配置文件需要做出一点修改，完整的配置如下：</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"ds"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springioc"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>现在我们就万事具备，只欠测试了！但是在测试前，为了测试的方便我还是要讲一个小知识点：<strong>Spring整合TestNG</strong>，实现在测试类中自动注入。</li></ul><h1 id="Spring整合TestNG"><a href="#Spring整合TestNG" class="headerlink" title="Spring整合TestNG"></a>Spring整合TestNG</h1><p>·　　一般情况下，测试模块是不与Spring框架直接联系的，因为例如Junit和TestNG都集成了main方法，这个主方法去检测测试类中的方法上有没有@Test注解，来判断是否执行该方法。这个过程是通过反射的，不会注意到<strong>例如@Autowired这类的注解</strong>，为了测试的方便（不然每个测试的方法都要new一个StudentService），Spring提供了与TestNG整合的方法。方法如下：<br>（<strong>注：为什么不整合Junit，因为testNG在功能和性能上都比junit好很多</strong>）</p><ul><li>1．添加必要的依赖：spring-text和testng</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.testng<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>testng<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>7.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>2．<strong>使测试类继承AbstractTestNGSpringContextTests类</strong></li><li>3．在测试类上添加注解@ContextConfiguration：开启测试类对配置的加载<ul><li>该注解有两个属性数组：location，表示配置文件的位置；classes，表示配置类的位置（纯注解开发使用） </li></ul></li></ul><p>·　　完成以上三步后，就可以在测试中注入IOC容器中的Bean了。<br>·　　使用如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ContextConfiguration</span>(locations = <span class="string">"classpath:applicationContext.xml"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSpringAnnotation</span> <span class="keyword">extends</span> <span class="title">AbstractTestNGSpringContextTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentService stuService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="案例测试"><a href="#案例测试" class="headerlink" title="案例测试"></a>案例测试</h1><h2 id="测试代码和结果"><a href="#测试代码和结果" class="headerlink" title="测试代码和结果"></a>测试代码和结果</h2><ul><li>1．”查”方法的测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tsetFind</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;Student&gt; stuList = stuService.findAllStudents();</span><br><span class="line">        <span class="keyword">for</span>(Student student : stuList)&#123;</span><br><span class="line">            System.out.println(student);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"-----------------"</span>);</span><br><span class="line">        Student stu = stuService.findStudentBySid(<span class="number">3</span>);</span><br><span class="line">        System.out.println(stu);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>“查”方法测试结果：可见查方法是没有问题的</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Student&#123;sid&#x3D;1, sname&#x3D;&#39;cxy&#39;, grade&#x3D;100.0&#125;</span><br><span class="line">Student&#123;sid&#x3D;2, sname&#x3D;&#39;lhw&#39;, grade&#x3D;99.5&#125;</span><br><span class="line">Student&#123;sid&#x3D;3, sname&#x3D;&#39;cwh&#39;, grade&#x3D;86.5&#125;</span><br><span class="line">Student&#123;sid&#x3D;4, sname&#x3D;&#39;sd&#39;, grade&#x3D;59.9&#125;</span><br><span class="line">-----------------</span><br><span class="line">Student&#123;sid&#x3D;3, sname&#x3D;&#39;cwh&#39;, grade&#x3D;86.5&#125;</span><br></pre></td></tr></table></figure><ul><li>2．”增”方法测试：增加了cxx学生，成绩为75.9</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">    stu.setSname(<span class="string">"cxx"</span>);</span><br><span class="line">    stu.setGrade(<span class="number">75.9</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stuService.addStudent(stu);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>“增”方法测试结果：可见cxx已经成功被添加（sid为7是因为我之前自己做过测试）<br><img src="https://img-blog.csdnimg.cn/20190831095054662.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="增"></li><li>3．”改”方法测试：将cxx的成绩改成40</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testUpdate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">    stu.setSid(<span class="number">7</span>);</span><br><span class="line">    stu.setSname(<span class="string">"cxx"</span>);</span><br><span class="line">    stu.setGrade(<span class="number">40.0</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stuService.updateStudent(stu);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>“改”方法测试结果：修改成功<br><img src="https://img-blog.csdnimg.cn/20190831095203528.PNG" alt="改"></li><li>4．”删”方法测试</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDelete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        stuService.deleteStudentBySid(<span class="number">7</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>“删”方法测试结果：删除成功<br><img src="https://img-blog.csdnimg.cn/20190831095238618.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="删"><h2 id="该案例存在的一点问题"><a href="#该案例存在的一点问题" class="headerlink" title="该案例存在的一点问题"></a>该案例存在的一点问题</h2>·　　很明显的一个问题，该案例没有实现<strong>事务管理</strong>。因为业务层的逻辑较为单一，所以对这个案例毫无影响，但是当业务层逻辑较为复杂时，就必须实现事务管理了，笔者的下一篇文章会介绍一下java的动态代理技术来对业务层的方法进行增强，从而实现事务管理（开启，提交，回滚，释放连接），文章已经写好了：<a href="https://memoforward.github.io/2019/09/01/Java%E4%B8%A4%E7%A7%8D%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E6%88%98-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E8%A7%A3%E9%87%8A/" target="_blank" rel="noopener">Java 两种动态代理实战 + 动态代理死循环的解释</a>。</li></ul><h1 id="IOC的纯注解开发（个人不喜欢用）"><a href="#IOC的纯注解开发（个人不喜欢用）" class="headerlink" title="IOC的纯注解开发（个人不喜欢用）"></a>IOC的纯注解开发（个人不喜欢用）</h1><h2 id="配置类"><a href="#配置类" class="headerlink" title="配置类"></a>配置类</h2><p>·　　看过一本书叫做《Spring实战》，作者建议使用纯注解开发，于是我专门去学习了一下。其实纯注解的意思就是把配置文件变成了配置类，就像配置文件不一定只有一个一样，配置类也可以有多个。<br>·　　配置类中有哪些内容呢？之前我们讲过，使用注解开发之后，在配置文件中一般有两个内容：一个是开启扫描组件，另一个是声明第三方的jar包。因此在配置类中，我们主要的就是解决这两个问题。<br>·　　加载配置类的方法是AnnotationConfigApplicationContext(参数是注解类们的字节码)，其实和ClassPathXmlAoolicationContext没什么不同嘛。</p><h2 id="Spring有关配置类的注解"><a href="#Spring有关配置类的注解" class="headerlink" title="Spring有关配置类的注解"></a>Spring有关配置类的注解</h2><div class="table-container"><table><thead><tr><th>注解</th><th>功能</th><th>属性</th><th>作用位置</th></tr></thead><tbody><tr><td>@Configuration</td><td>表示该类是一个配置类，当被ApplicationContext加载时可不写</td><td>无</td><td>作用在类上</td></tr><tr><td>@ComponentScan</td><td>需要扫描的包</td><td>value/basePackages：指定包（可以是多个）</td><td>作用在类上</td></tr><tr><td>@Bean</td><td>把当前方法的返回值作为bean对象存入spring的ioc容器中</td><td>name：指定bean的Id</td><td>作用在方法上(如果该方法有参数，则Spring会自动去IOC容器中查找Bean，没有则无法返回)</td></tr><tr><td>@import</td><td>导入其他的配置类</td><td>value(class):其他配置类的字节码（被import的是子类）</td><td>作用在类上</td></tr><tr><td>@PropertySource</td><td>引入property配置文件</td><td>value：“classpath：文件的配置”</td><td>作用在类上</td></tr></tbody></table></div><h2 id="配置文件转化成配置类"><a href="#配置文件转化成配置类" class="headerlink" title="配置文件转化成配置类"></a>配置文件转化成配置类</h2><ul><li>1．原始配置文件如下：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.memoforward"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"ds"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///springioc"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"123"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li>２．为了能把所有的注解都用上，建两个配置类，并把Datasource用properties文件存储。</li><li>配置文件：jdbc.properties</li></ul><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">jdbc.driverClass</span>=<span class="string">com.mysql.jdbc.Driver</span></span><br><span class="line"><span class="meta">jdbc.jdbcUrl</span>=<span class="string">jdbc:mysql:///springioc</span></span><br><span class="line"><span class="meta">jdbc.user</span>=<span class="string">root</span></span><br><span class="line"><span class="meta">jdbc.password</span>=<span class="string">123</span></span><br></pre></td></tr></table></figure><ul><li>JDBC配置类：JDBCConfig</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> ...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过配置文件注入属性</span></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driverClass&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String driverClass;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.jdbcUrl&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String jdbcUrl;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.user&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String user;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryRunner <span class="title">createQueryRunner</span><span class="params">(DataSource ds)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QueryRunner(ds);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">        ComboPooledDataSource ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ds.setDriverClass(driverClass);</span><br><span class="line">            ds.setJdbcUrl(jdbcUrl);</span><br><span class="line">            ds.setUser(user);</span><br><span class="line">            ds.setPassword(password);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>总配置类：IOCConfig</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span>...</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"com.memoforward"</span>)</span><br><span class="line"><span class="meta">@Import</span>(JDBCConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">IOCConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用时加载配置类（测试时如何使用？）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//@ContextConfiguration(locations = "classpath:applicationContext.xml")</span></span><br><span class="line"><span class="comment">//改用加载配置类的方式</span></span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = IOCConfig<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">TestSpringAnnotation</span> <span class="keyword">extends</span> <span class="title">AbstractTestNGSpringContextTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果没有整合就用如下的方式加载配置类</span></span><br><span class="line">    <span class="comment">//ApplicationContext ac = new AnnotationConfigApplicationContext(IOCConfig.class);</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    StudentService stuService;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下是测试代码</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　测试可以正常运行，说明我们配置成功了。这种方式，甚至比xml还要繁琐，而且也不是那么的简单易懂，我个人是很不喜欢这样用。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　IOC是Spring框架的重中之重，但是说白了就是一个Map集合的工厂类而已，这种设计理念是真的不错，我们要站在巨人的肩膀上，多加思考，让写代码变得越来越简单，目标就是在：让天下没有秃顶的程序员！</p><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇文章涉及到了如下知识点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;SpringIOC的概念和作用&lt;/li&gt;
&lt;li&gt;通过XML配置进行SpringIOC实战&lt;/li&gt;
&lt;li&gt;通过注解配置进行SpringIOC实战&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="SSM" scheme="http://yoursite.com/tags/SSM/"/>
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Java工厂模式实战</title>
    <link href="http://yoursite.com/2019/08/29/Java%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2019/08/29/Java%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E5%AE%9E%E6%88%98/</id>
    <published>2019-08-29T07:11:11.000Z</published>
    <updated>2020-03-07T12:22:16.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇主要涉及如下知识点：</p><ol><li>工厂模式设计概念</li><li>Java实现一个简单的工厂类</li><li>对工厂类实现优化，使其能够支持单例和多例</li></ol></blockquote><a id="more"></a><h1 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>·　　工厂模式（Factory Pattern）是 Java 中最常用的设计模式之一。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。简而言之，工厂模式就是改变了我们创建对象的方法。</p><ul><li>传统创建对象的方法是：new 出一个实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person student = <span class="keyword">new</span> Student()；</span><br></pre></td></tr></table></figure><ul><li>而工厂模式创建实例的方式可能如下:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student student = (Student)BeanFactory.getPerson(<span class="string">"student"</span>);</span><br></pre></td></tr></table></figure><p>·　　这意味着两点：<strong>其一</strong>，工厂模式创建的实例是隐藏细节的，我们并不完全知道工厂创建的到底是什么实例（上述代码可能返回的是一个Teacher对象，而被强转成了Student）；<strong>其二</strong>，工厂模式降低了类之间的耦合（依赖）。使用传统模式来创建实例，一旦实例出现了问题（比如Student类的构造方法被改变），则代码不可能编译成功，整个项目就会面临崩溃；而工厂模式创建对象，其依赖仅仅只是一个字符串而已，即使不能运行成功，至少其编译是没问题的，类之间的依赖程度大大减少。</p><h1 id="工厂模式创建对象实战"><a href="#工厂模式创建对象实战" class="headerlink" title="工厂模式创建对象实战"></a>工厂模式创建对象实战</h1><h2 id="工厂模式创建对象原理"><a href="#工厂模式创建对象原理" class="headerlink" title="工厂模式创建对象原理"></a>工厂模式创建对象原理</h2><p>·　　最常见的工厂模式创建对象的流程如下：“<strong>创建工厂——读取配置文件——获取配置属性对应的值(全限定类名)——根据类名使用反射创建实例对象</strong>”。对应的知识点为<a href="https://memoforward.github.io/2019/08/27/Java%E4%B8%ADXML%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%88Dom4j-Xpath%EF%BC%89/" target="_blank" rel="noopener">读取XML文件</a> 以及 <a href="https://memoforward.github.io/2019/08/24/Java%E5%8F%8D%E5%B0%84%E8%AE%B2%E8%A7%A3%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/" target="_blank" rel="noopener">Java 反射讲解与案例实战</a>，具体的知识点可以参考链接的这两篇博客。</p><h2 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h2><p>·　　<strong>目标</strong>：使用工厂PersonFactory得到Student和Teacher类的两个对象。<br>·　　需要导入支持xml读取的dom4j包和jaxen包；以及用于测试的testng包。</p><ul><li>两个类实现了Person接口，具体如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">code</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String number;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Student对象被创建了...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"学生码代码..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Teacher</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Teacher对象被创建了..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">code</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"老师码代码...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>写配置文件persons.xml</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">persons</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.Student"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">"teacher"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.Teacher"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>编写工厂</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonFactory01</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Document document = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//静态代码块读取配置文件</span></span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            document = reader.read(PersonFactory01.class.getClassLoader().getResourceAsStream("persons.xml"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getPerson</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        Object obj = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//获取到配置文件中需要找到的标签</span></span><br><span class="line">        Element element = (Element) document.selectSingleNode(<span class="string">"/persons/person[@id='"</span>+ id +<span class="string">"']"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//通过该标签的class属性值获取类名，并通过反射创建实例</span></span><br><span class="line">            obj = Class.forName(element.attributeValue(<span class="string">"class"</span>)).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactoryTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPersonFactory01</span><span class="params">()</span></span>&#123;</span><br><span class="line">        PersonFactory01 personFactory = <span class="keyword">new</span> PersonFactory01();</span><br><span class="line">        Student student = (Student)personFactory.getPerson(<span class="string">"student"</span>);</span><br><span class="line">        student.code();</span><br><span class="line">        Teacher teacher = (Teacher)personFactory.getPerson(<span class="string">"teacher"</span>);</span><br><span class="line">        teacher.code();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果如下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Student对象被创建了....</span><br><span class="line">学生码代码...</span><br><span class="line">Teacher对象被创建了...</span><br><span class="line">老师码代码....</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Passes: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>·　　可见学生对象和老师对象都被BeanFactory成功的创建了。</p><h1 id="上例的工厂模式改进"><a href="#上例的工厂模式改进" class="headerlink" title="上例的工厂模式改进"></a>上例的工厂模式改进</h1><h2 id="上例的问题"><a href="#上例的问题" class="headerlink" title="上例的问题"></a>上例的问题</h2><p>·　　理论上，上例已经可以解决很多的问题了，但是会面临一个问题：<strong>当我每一次构造对象，我都会用newInstance创建一个新的实例对象。</strong> 如果某个类我只希望创建一个实例对象（每次getPerson都获得同一个对象），上述的工厂就不再适用了。举个简单的例子：一个班只有一个老师，我每次找老师都只想找到同一个老师。<br>·　　上面的问题就是我们熟知的<strong>单例</strong>和<strong>多例</strong>的问题，有的时候我们并不想用多例的模式去操作Bean，因此对上例工厂模式的改进就是：把多例模式的工厂转换为单例模式的工厂。</p><ul><li>多例测试代码：如果连续获取5次Teacher对象，得到5个不同的实例。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">Teacher teacher = (Teacher)personFactory.getPerson(<span class="string">"teacher"</span>);</span><br><span class="line">System.out.println(teacher);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试结果如下：</span></span><br><span class="line">Teacher对象被创建了...</span><br><span class="line">com.memoforward.Teacher@<span class="number">11758f</span>2a</span><br><span class="line">Teacher对象被创建了...</span><br><span class="line">com.memoforward.Teacher<span class="meta">@e</span>720b71</span><br><span class="line">Teacher对象被创建了...</span><br><span class="line">com.memoforward.Teacher@<span class="number">1</span>b26f7b2</span><br><span class="line">Teacher对象被创建了...</span><br><span class="line">com.memoforward.Teacher@<span class="number">491</span>cc5c9</span><br><span class="line">Teacher对象被创建了...</span><br><span class="line">com.memoforward.Teacher@<span class="number">74</span>ad1f1f</span><br></pre></td></tr></table></figure><h2 id="工厂类的改写"><a href="#工厂类的改写" class="headerlink" title="工厂类的改写"></a>工厂类的改写</h2><p>·　　之前我们在工厂类中，使用了静态代码块去加载了配置文件，创造了单例的静态document树对象。因此，创造单例模式的工厂的思路就是：<strong>构建单例的静态Map集合去存储不同类的实例对象</strong>。很显然，对Map对象的赋值操作也是在静态代码块中实现的，这意味着，每个类的实例对象都是在配置文件被加载的同时被创建的。</p><ul><li>单例Person工厂的代码如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonFactory02</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Document document;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; beanMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String beanId = <span class="keyword">null</span>;</span><br><span class="line">            Object obj;</span><br><span class="line">            document = reader.read(PersonFactory02.class.getClassLoader().getResourceAsStream("persons.xml"));</span><br><span class="line">            <span class="comment">//选取persons的所有子元素</span></span><br><span class="line">            List&lt;Element&gt; elements = document.selectNodes(<span class="string">"/persons/person"</span>);</span><br><span class="line">            <span class="keyword">for</span>(Element element : elements)&#123;</span><br><span class="line">                beanId = element.attributeValue(<span class="string">"id"</span>);</span><br><span class="line">                obj = Class.forName(element.attributeValue(<span class="string">"class"</span>)).newInstance();</span><br><span class="line">                beanMap.put(beanId,obj);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getPerson</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beanMap.get(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试如下：分别获取3个Student和3个Teacher对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPersonFactory02</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PersonFactory02 pf = <span class="keyword">new</span> PersonFactory02();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++)&#123;</span><br><span class="line">        Student student = (Student)pf.getPerson(<span class="string">"student"</span>);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">        Teacher teacher = (Teacher)pf.getPerson(<span class="string">"teacher"</span>);</span><br><span class="line">        System.out.println(teacher);</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果如下：每次得到的都是同一个对象，且对象只创建一次。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Student对象被创建了....</span><br><span class="line">Teacher对象被创建了...</span><br><span class="line">com.memoforward.Student@77ec78b9</span><br><span class="line">com.memoforward.Teacher@1a3869f4</span><br><span class="line">---------------------------------</span><br><span class="line">com.memoforward.Student@77ec78b9</span><br><span class="line">com.memoforward.Teacher@1a3869f4</span><br><span class="line">---------------------------------</span><br><span class="line">com.memoforward.Student@77ec78b9</span><br><span class="line">com.memoforward.Teacher@1a3869f4</span><br><span class="line">---------------------------------</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Passes: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><ul><li><strong>补充</strong>：单例模式对象的初始化操作在加载配置文件的时候就完成了，即在new PersonFactory02()的时候，两个对象就被创建了吗，而静态代码块只会执行一次，因此这两个对象永远不会改变。</li></ul><h2 id="工厂的再改进"><a href="#工厂的再改进" class="headerlink" title="工厂的再改进"></a>工厂的再改进</h2><p>·　　以上的两个工厂类明显都不太行，一个只能支持多例，一个只能支持单例。因此最理想的工厂应该根据用户的需求自己判断创建多例和单例的对象。这当然呀没有什么难度，但是需要在配置文件中声明其对象的作用范围。</p><ul><li>配置文件修改：加入scope属性，值为singleton的时候为单例，值为prototype的时候为多例；如果不写此属性，则默认为单例。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">persons</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.Student"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">person</span> <span class="attr">id</span>=<span class="string">"teacher"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.Teacher"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">persons</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>工厂类如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonFactory</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Document document;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; beanMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String beanId = <span class="keyword">null</span>;</span><br><span class="line">            Object obj;</span><br><span class="line">            document = reader.read(PersonFactory.class.getClassLoader().getResourceAsStream("persons.xml"));</span><br><span class="line">            <span class="comment">//选取persons的所有子元素</span></span><br><span class="line">            List&lt;Element&gt; elements = document.selectNodes(<span class="string">"/persons/person"</span>);</span><br><span class="line">            <span class="keyword">for</span>(Element element : elements)&#123;</span><br><span class="line">                Attribute attr = element.attribute(<span class="string">"scope"</span>);</span><br><span class="line">                String scope = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">if</span>(attr != <span class="keyword">null</span>)&#123;</span><br><span class="line">                    scope = attr.getStringValue();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(scope.equals(<span class="string">"singleton"</span>) || scope.equals(<span class="string">""</span>) || scope == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    beanId = element.attributeValue(<span class="string">"id"</span>);</span><br><span class="line">                    obj = Class.forName(element.attributeValue(<span class="string">"class"</span>)).newInstance();</span><br><span class="line">                    beanMap.put(beanId,obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getPerson</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(beanMap.get(id) != <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> beanMap.get(id);</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            Object obj = <span class="keyword">null</span>;</span><br><span class="line">            Element element = (Element) document.selectSingleNode(<span class="string">"/persons/person[@id='"</span>+ id +<span class="string">"']"</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                obj = Class.forName(element.attributeValue(<span class="string">"class"</span>)).newInstance();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试如下：分别获取两次Teacher和两个Student。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testPersonFactory</span><span class="params">()</span></span>&#123;</span><br><span class="line">    PersonFactory pf = <span class="keyword">new</span> PersonFactory();</span><br><span class="line">    System.out.println(<span class="string">"****************"</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)&#123;</span><br><span class="line">        Student student = (Student)pf.getPerson(<span class="string">"student"</span>);</span><br><span class="line">        System.out.println(student);</span><br><span class="line">        Teacher teacher = (Teacher)pf.getPerson(<span class="string">"teacher"</span>);</span><br><span class="line">        System.out.println(teacher);</span><br><span class="line">        System.out.println(<span class="string">"---------------------------------"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果如下：可以看到：配置加载时，只有Teacher对象被创建；每次获得Teacher和Student时，都会创建新的Studnet对象，而Teacher的对象不变。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Teacher对象被创建了...</span><br><span class="line">****************</span><br><span class="line">Student对象被创建了....</span><br><span class="line">com.memoforward.Student@1b26f7b2</span><br><span class="line">com.memoforward.Teacher@491cc5c9</span><br><span class="line">---------------------------------</span><br><span class="line">Student对象被创建了....</span><br><span class="line">com.memoforward.Student@74ad1f1f</span><br><span class="line">com.memoforward.Teacher@491cc5c9</span><br><span class="line">---------------------------------</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Passes: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><h1 id="单例和多例对象的生命周期"><a href="#单例和多例对象的生命周期" class="headerlink" title="单例和多例对象的生命周期"></a>单例和多例对象的生命周期</h1><p>·　　这个问题只要弄懂了原理就特别简单：单例对象是在工厂类被加载时被创建的，因此生命周期与工厂类是一样的；而多例对象本质与被new出来的对象没有区别，因此当没有任何引用指向这个对象时，会被垃圾回收器回收。</p><ul><li>单例生命周期<ol><li>出生：当工厂被创建时被创建</li><li>存在：工厂类存在，单例对象一直存在</li><li>死亡：工厂类销毁或关闭时，单例对象被释放</li></ol></li><li>多例生命周期<ol><li>出生：当要调用该对象时被创建</li><li>存在：只要该对象还在使用，就一直存在</li><li>死亡：没有任何引用指向该对象时（该对象不再使用），被垃圾回收器回收</li></ol></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　Java的工厂模式算是一种有名的设计模式了，个人十分喜欢这种设计思路，而且Spring的IOC也是这样来实现的，笔者的下一篇文章会在这篇文章的基础上讲一讲Spring的IOC。</p><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇主要涉及如下知识点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;工厂模式设计概念&lt;/li&gt;
&lt;li&gt;Java实现一个简单的工厂类&lt;/li&gt;
&lt;li&gt;对工厂类实现优化，使其能够支持单例和多例&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>slf4j+log4j2使用及log4j2配置文件解析</title>
    <link href="http://yoursite.com/2019/08/28/slf4j-log4j2%E4%BD%BF%E7%94%A8%E5%8F%8Alog4j2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2019/08/28/slf4j-log4j2%E4%BD%BF%E7%94%A8%E5%8F%8Alog4j2%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%A7%A3%E6%9E%90/</id>
    <published>2019-08-28T12:20:14.000Z</published>
    <updated>2020-03-07T12:21:53.298Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇文章主要涉及以下知识点：</p><ol><li>常用的日志框架（日志门面以及日志实现）</li><li>slf4j+log4j2的使用</li><li>log4j2的傻瓜通用配置</li></ol></blockquote><a id="more"></a><h1 id="一些问题的修改与更新"><a href="#一些问题的修改与更新" class="headerlink" title="一些问题的修改与更新"></a>一些问题的修改与更新</h1><h2 id="将日志自动保存到不同的日志文件（19-10-03更新）"><a href="#将日志自动保存到不同的日志文件（19-10-03更新）" class="headerlink" title="将日志自动保存到不同的日志文件（19-10-03更新）"></a>将日志自动保存到不同的日志文件（19-10-03更新）</h2><p>·　　自己在做项目的时候遇到了一个问题：<strong>重新运行项目，如何把日志保存到不同的log文件？</strong><br>·　　我之前写的那个模板有一个重大的问题：每次运行程序，只要日志文件没超过maxSize，log都只会记录到这个文件。但是调试的时候，这种操作令人十分不爽，因此，在查询了官网之后，给模板进行了修改。</p><p><font color="red"><strong>修改如下：</strong></font><br>·　　<strong>因为在普通的字符串里无法使用pattern的语法，因此使用<code>fileName=&quot;$${date:MM-dd-HH-ss}&quot;</code> 作为保存的日志名称，这样每次运行程序，日志必然会保存在不同的文件下。</strong><br>·　　实际上，我们完全可以构造两个FileAppender，这样就可以根据我们的需要来使用不同的日志文件记录方式了：本文的模板已更新，不喜可删。</p><h1 id="什么是slf4j和log4j2"><a href="#什么是slf4j和log4j2" class="headerlink" title="什么是slf4j和log4j2"></a>什么是slf4j和log4j2</h1><p>·　　目前开源的日志框架有很多，如logback，log4j等，这面临了一个问题：当使用不同的日志框架或者这些日志框架面临了重大更新的时候，如果其实现函数有所改变，那么旧版本的框架就会崩溃，这很不利于项目的维护和新框架的推广。因此才诞生了例如slf4j这样的<strong>日志门面</strong>。<br>·　　日志门面，顾名思义就是日志框架对外的表现形式，理论上只要日志框架实现了日志门面的接口，不管其怎么更新，开发者都不需要对项目的依赖，或者项目的代码做出过多的改变。目前还在坚持更新且性能良好的日志门面非slf4j莫属，因此强烈建议使用slf4j作为我们书写日志的接口。<br>·　　日志框架方面，logback是log4j的升级版，这两个框架与slf4j是一个开发者开发出来的，因此其整合十分之稳定。但是log4j2作为apache最新推出的日志框架，在异步记录日志的方面性能比logback要更加的优异，<del>因此本着要用就用最好的的原则</del> ，使用lo4gj2作为日志记录的框架。<br>注：log4j2只是假借了log4j之名而已，log4j的真正升级版是logback。</p><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>·　　日志的环境依赖总共有4部分，分别是<strong>slf4j接口</strong>部分，<strong>log4j2的日志框架</strong>实现部分，<strong>log4j2异步日志</strong>插件部分以及s<strong>lf4j与log4j2的桥接</strong>部分。</p><div class="table-container"><table><thead><tr><th>包名</th><th>作用</th></tr></thead><tbody><tr><td>slf4j-api</td><td>目前的版本1.7就可。slf4j的接口包，我们对日志进行的所有操作都用的是这个包的API</td></tr><tr><td>log4j-core</td><td>版本必须在2.1以上，是log4j2的核心包</td></tr><tr><td>log4j-api</td><td>版本与核心包一致，log4j2的接口包，用来直接调用log4j2框架的，必须导入，不然无法与slf4j对接</td></tr><tr><td>log4j-web</td><td>版本与核心包一致，用于web项目的log4j2，阻止web项目出现警告</td></tr><tr><td>com.lmax.disruptor</td><td>版本随意，开启log4j2的异步日志记录的功能</td></tr><tr><td>log4j-slf4j-impl</td><td>版本与核心包一致，用于slf4j与log4j对接，即用slf4j的接口实现操作日志</td></tr></tbody></table></div><p>这里给出一份Maven完整依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">log4j2.version</span>&gt;</span>2.11.2<span class="tag">&lt;/<span class="name">log4j2.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slf4j.version</span>&gt;</span>1.7.28<span class="tag">&lt;/<span class="name">slf4j.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-core --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j2.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j2.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-web --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j2.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/com.lmax/disruptor --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.lmax<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>disruptor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.4.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.slf4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>slf4j-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;slf4j.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- https://mvnrepository.com/artifact/org.apache.logging.log4j/log4j-slf4j-impl --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.logging.log4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>log4j-slf4j-impl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;log4j2.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>·　　看多很多的博客，都没有官网的配置全面，因此给出官网传送门：<a href="https://logging.apache.org/log4j/2.x/manual/configuration.html" target="_blank" rel="noopener">log4j2官网详细配置说明</a><br>·　　本博客给出一种粘贴复制即可用的配置，并给出一些个人认为比较重要的说明。</p><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><p>·　　基本上所有的配置都写在了Properties里，因此，只需要改Properties就可以用了（建议自定义Logger，不建议修改Appenders）。<br>Apperders里定义了两种日志记录的格式：1. 在控制台输出name=“Console”，2. 在文件输出name=“File”。使用RollingRandomAccessFileAppender是因为其性能最好，且支持日志自动归档。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- https://www.cnblogs.com/hafiz/p/6170701.html--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span> <span class="attr">status</span>=<span class="string">"WARN"</span> <span class="attr">name</span>=<span class="string">"MyApp"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志文件保存的路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filePath"</span> <span class="attr">value</span>=<span class="string">"src/logs/$$&#123;date:MM-dd-HH-mm-ss&#125;-untitled.log"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filePath_onlyOne"</span> <span class="attr">value</span>=<span class="string">"src/logs/untitled.log"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志文件归档后保存的压缩文件路径--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"filePattern"</span> <span class="attr">value</span>=<span class="string">"src/logs/$$&#123;date:yyyy-MM&#125;/untitled-%d&#123;yyyy-MM-dd-HH&#125;-%i.log.zip"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志文档超过多大时执行翻转（即：将旧文件压缩，并用新日志文件记录）--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxSize"</span> <span class="attr">value</span>=<span class="string">"250 MB"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--记录的日志文件超过多少时，旧文件会被删除--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxFile"</span> <span class="attr">value</span>=<span class="string">"50"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--打印日志的时候是否标注日志在项目的位置信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"useLocation"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!--日志输出格式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"layoutPattern"</span> <span class="attr">value</span>=<span class="string">"%date %p %c&#123;1.&#125; [%thread] %location %message %exception%n"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">"Console"</span> <span class="attr">target</span>=<span class="string">"SYSTEM_OUT"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;layoutPattern&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!----&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RollingRandomAccessFile</span> <span class="attr">name</span>=<span class="string">"File"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;filePath&#125;"</span> <span class="attr">filePattern</span>=<span class="string">"$&#123;filePattern&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;layoutPattern&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--基于时间的归档，一般不使用--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个6基于filePattern归档文件的时间，本文件归档的filePattern最后的HH表示小时，因此此文件每6个小时进行一次归档--&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- &lt;TimeBasedTriggeringPolicy interval="6" modulate="true"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--基于文件大小的归档--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"$&#123;maxSize&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"$&#123;maxFile&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RollingRandomAccessFile</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">RollingRandomAccessFile</span> <span class="attr">name</span>=<span class="string">"OneFile"</span> <span class="attr">fileName</span>=<span class="string">"$&#123;filePath_onlyOne&#125;"</span> <span class="attr">filePattern</span>=<span class="string">"$&#123;filePattern&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">"$&#123;layoutPattern&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--基于文件大小的归档--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">"$&#123;maxSize&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">"$&#123;maxFile&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RollingRandomAccessFile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--这个只能自行配置了--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--异步日志Root（与同步Root之间只能存在一个）--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;AsyncRoot level="DEBUG" includeLocation="$&#123;useLocation&#125;"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;AppenderRef ref="Console"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;AppenderRef ref="File"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;/AsyncRoot&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        同步Root--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">"INFO"</span> &gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"File"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">"Console"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--异步日志(与同步日志可同时存在)--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--name属性值请自定义--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;AsyncLogger name="AsyncLogger" level="DEBUG" includeLocation="$&#123;useLocation&#125;" additivity="false"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;AppenderRef ref="File"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;/AsyncLogger&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--同步日志--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;Logger name="com.memoforward.dao" level="DEBUG" includeLocation="$&#123;useLocation&#125;" additivity="false"&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;AppenderRef ref="Console"/&gt;--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--&lt;/Logger&gt;--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="配置的简单说明："><a href="#配置的简单说明：" class="headerlink" title="配置的简单说明："></a>配置的简单说明：</h2><h3 id="RollingRandomAccessFile标签"><a href="#RollingRandomAccessFile标签" class="headerlink" title="RollingRandomAccessFile标签"></a>RollingRandomAccessFile标签</h3><ul><li><p>RollingRandomAccessFile的三个属性的含义：</p><ol><li>name：这个Appender的引用名</li><li>fileName：日志文件的路径及名称（文件夹或文件不存在就自动创建）</li><li>filePattern：日志归档后的文件的保存路径和名称（如果加了.zip就自动压缩）</li></ol></li><li><p>RollingRandomAccessFile必须配置的两个字标签：</p><ol><li>TriggerPolicy：文件翻转触发机制。翻转的意思就是旧文件保存（归档），另起新文件进行记录。 <ul><li>在上述配置文件中，其触发机制是SizeBasedTriggeringPolicy，即：当文件大小超过一定阈值后，进行自动保存</li></ul></li><li>RolloverStrategy：文件翻转策略。<ul><li>在上述配置文件中，其策略是默认策略，当归档的文件数量达到一定数值后，就自动删除旧文件（如果不配置，则默认为7）</li></ul></li></ol></li></ul><ul><li><strong>测试代码如下</strong>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.testng.annotations.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4j2Test</span> </span>&#123;</span><br><span class="line"><span class="comment">//    private static final Logger logger = LoggerFactory.getLogger(Log4j2Test.class);</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(<span class="string">"AsyncLogger"</span>);</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testLog</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">500</span>; i++)&#123;</span><br><span class="line">            logger.error(Integer.toString(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>测试结果如下</strong><br>设置了保存的文件最大为1KB，最大保存文件数量为10，保存500条日志。每篇日志能保存9条语句。<br><img src="https://img-blog.csdnimg.cn/20190828194222737.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ul><ul><li><strong>untitled.log输出如下</strong>：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">2019-08-28 19:16:52,248 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 491 </span><br><span class="line">2019-08-28 19:16:52,248 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 492 </span><br><span class="line">2019-08-28 19:16:52,248 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 493 </span><br><span class="line">2019-08-28 19:16:52,248 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 494 </span><br><span class="line">2019-08-28 19:16:52,248 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 495 </span><br><span class="line">2019-08-28 19:16:52,248 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 496 </span><br><span class="line">2019-08-28 19:16:52,249 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 497 </span><br><span class="line">2019-08-28 19:16:52,250 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 498 </span><br><span class="line">2019-08-28 19:16:52,250 ERROR AsyncLogger [main] Log4j2Test.testLog(Log4j2Test.java:11) 499</span><br></pre></td></tr></table></figure><p>·　　可见，如果不设置翻转的机制，要么会在一个日志文件内记录所有的数据，要么仅会保存7条归档的日志。一般情况下，希望能把所有的归档日志文件都保存下来，因此RolloverStragety的值要设置的大一点。</p><h3 id="Logger的配置"><a href="#Logger的配置" class="headerlink" title="Logger的配置"></a>Logger的配置</h3><p>·　　Logger分为同步和异步，只有一个RootLogger。异步的实现就是我们之前引入的那个<strong>com.lmax.disruptor</strong>包，当我们启用异步日志记录的时候，就会新建一个Disruptor对象，具体的日志记录流程建议参考这位大佬的文章:<a href="https://www.cnblogs.com/yeyang/p/7944906.html" target="_blank" rel="noopener">Log4j2中的同步日志与异步日志</a>。</p><ul><li><p>Logger中属性的含义：</p><ol><li>name：在代码getLogger的名字，root没有此属性。</li><li>level：日志的打印级别为”<strong>OFF&gt;FATAL&gt;ERROR&gt;WARN&gt;INFO&gt;DEBUG&gt;TRACE</strong>“。logger在记录日志的时候，只会记录level界别及以上的日志内容(OFF永远不会打印)。如设置了ERROR，只会打印FATAL和ERROR。</li><li>includeLoacation：日志打印的时候是否会输出位置（打印位置会降低性能）。</li><li>additivity：root没有，配置此属性值为true来避免重复打印（如果为false，root会重复打印一次相同级别的日志），至于为什么会重复打印，还是建议大家看一下官方文档，这里不赘述了。</li></ol></li><li><p>Logger的子标签<br>  1.&lt; AppenderRef ref=”xxx” &gt; 表示这个logger将用到何种Appender，ref内写Appender的name属性值。</p></li></ul><h3 id="PatternLayout解释"><a href="#PatternLayout解释" class="headerlink" title="PatternLayout解释"></a>PatternLayout解释</h3><p>·　　本配置文件默认的layoutPattern为：<strong>%date %p %c{1.} [%thread] %location %message %exception%n</strong><br>·　　官网有特别特别详细的说明文档，我这个都是对着官网写出来的，特别好理解，强烈建议大家对看文档。传送门：<a href="https://logging.apache.org/log4j/2.x/manual/layouts.html" target="_blank" rel="noopener">log4j2的LayoutPattern</a>；本博客就只介绍一下上面的这行配置。</p><div class="table-container"><table><thead><tr><th>格式</th><th>说明</th></tr></thead><tbody><tr><td>%date</td><td>输出日期和时间：yyyy-MM-dd HH:mm:ss,SSS（年-月-日 时：分：秒，毫秒）</td></tr><tr><td>%p</td><td>输出日志的打印级别</td></tr><tr><td>%c{1.}</td><td>输出该日志所处的缩略类路径</td></tr><tr><td>%[thread]</td><td>打印执行该日志记录的线程名</td></tr><tr><td>%location</td><td>打印日志语句在项目代码中的位置</td></tr><tr><td>%message</td><td>日志内容</td></tr><tr><td>%exception</td><td>如果出现了异常，则打印异常</td></tr><tr><td>%n</td><td>类似于/n，是换行符</td></tr></tbody></table></div><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　日志记录一直是一个很尴尬的点，感觉不难，但一直理解不是很深刻，其实我们最常用的就是把日志输出到控制台或者输出到文件，私以为只要把这两个方面搞明白了就行。以后做项目，尽量就用slf4j+log4j2来记录日志啦。</p><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇文章主要涉及以下知识点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;常用的日志框架（日志门面以及日志实现）&lt;/li&gt;
&lt;li&gt;slf4j+log4j2的使用&lt;/li&gt;
&lt;li&gt;log4j2的傻瓜通用配置&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java - 日志框架" scheme="http://yoursite.com/tags/Java-%E6%97%A5%E5%BF%97%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java中XML文件的解析（Dom4j+Xpath）</title>
    <link href="http://yoursite.com/2019/08/27/Java%E4%B8%ADXML%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%88Dom4j-Xpath%EF%BC%89/"/>
    <id>http://yoursite.com/2019/08/27/Java%E4%B8%ADXML%E6%96%87%E4%BB%B6%E7%9A%84%E8%A7%A3%E6%9E%90%EF%BC%88Dom4j-Xpath%EF%BC%89/</id>
    <published>2019-08-27T13:03:56.000Z</published>
    <updated>2020-03-07T12:20:59.786Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇文章主要介绍了如何用Dom4j+Xpath解析XML文件<br>XML的解析在Java的框架源码中十分常用，因此学会解析XML文件是必要的</p></blockquote><a id="more"></a><h1 id="XML文件"><a href="#XML文件" class="headerlink" title="XML文件"></a>XML文件</h1><p>·　　XML文件是一种可扩展标记语言。做后台开发接触到的XML文件一般是以配置文件的身份登场，虽说现在几乎不用我们自行解析XML配置文件，但是技多不压身，万一哪天我们需要自己开发框架了，这门技能就成为了必须。</p><h2 id="XML文件格式"><a href="#XML文件格式" class="headerlink" title="XML文件格式"></a>XML文件格式</h2><p>·　　XML文件的格式非常简单，第一行是文件声明，后面就是我们自行添加的内容。书写XML文件有几点注意事项：</p><ul><li>必须有声明</li><li>标签区分大小写</li><li>只有一个根元素（根标签）</li><li>属性可以自定义，属性值必须添加引号</li><li>必须有结束标志(&lt;/&gt;)</li></ul><p>·示例如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span> <span class="comment">&lt;!-- 声明 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span><span class="comment">&lt;!-- 自定义根元素，有且仅有一个 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentService"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.service.StudentService"</span>&gt;</span> <span class="comment">&lt;!-- 自定义子元素，自定义属性名和属性值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"studentDao"</span> <span class="attr">ref</span>=<span class="string">"studentDao"</span>/&gt;</span> <span class="comment">&lt;!-- 子元素下依然可以有子元素，xml可以无限层--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span><span class="comment">&lt;!--结束标志--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"studentDao"</span> <span class="attr">class</span>=<span class="string">"com.memoforward.dao.StudentDao"</span>/&gt;</span> <span class="comment">&lt;!-- 结束标志的另一种写法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beanTest</span> &gt;</span>beanTestValue<span class="tag">&lt;/<span class="name">beanTest</span>&gt;</span><span class="comment">&lt;!--一般情况下，xml标签是有标签值的--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>·　　由上面的格式可知，其实XML与HTML相差并不大，我们访问和操作HTML文档使用的工具是HTML DOM 树。异曲同工，Dom4j也参照了这种方法，其使用SAXReader对象将整个XML文档读取，构建出了document树对象。通过这个树对象，配合上XPath工具，我们就可以很轻松地访问到整个文件的所有节点的数据了，其中节点（元素）就是Element对象，节点中的属性就是Atrribute对象。<br>·　　所以，解析XML的步骤就是：<strong>创建SAXReader对象 — SAXReader获取XML文件的Document树对象 — document树获取Element元素对象 — Element元素对象获取其元素的属性Attribute对象</strong>。这一套流程下来，基本想读取什么值都可以。</p><h1 id="解析XML文件"><a href="#解析XML文件" class="headerlink" title="解析XML文件"></a>解析XML文件</h1><p>·　　本博客使用Dom4j+Xpath来解释XML文件。使用这种方式需要引入两个jar包，一个是dom4j包，另一个是Xpath通用引擎包jaxen。注：如果xml文件不大，推荐使用此种方式解析xml文件（因为使用简单方便）；如果XML巨大，可以使用JDK自带的SAX解析器去“边读边写”提高效率，但因为其操作比较复杂，需要定义自己的处理器，本博客就不描述此种方法了。<br>其Maven依赖如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- https://mvnrepository.com/artifact/dom4j/dom4j --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>dom4j<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.6.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- https://mvnrepository.com/artifact/jaxen/jaxen --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jaxen<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Xpath"><a href="#Xpath" class="headerlink" title="Xpath"></a>Xpath</h2><p>·　　在正式开始解析之前，不得不介绍一下Xpath是为何物。<br>·　　XPath 是一门在 XML 文档中查找信息的语言，用于在 XML 文档中对元素和属性进行遍历。XPath 使用<strong>路径表达式</strong>来选取 XML 文档中的节点或者节点集。这些路径表达式和我们在常规的电脑文件系统中看到的表达式非常相似。<br>·　　由上述概念可知，我们解析XML文件的核心就在于：<strong>使用XPath的路径表达式在document树对象中检索节点。</strong><br>·　　树对象的获取在1.2节已经介绍了，非常简单，因此难点就在于路径表达式的语法了。</p><h3 id="路径表达式语法"><a href="#路径表达式语法" class="headerlink" title="路径表达式语法"></a>路径表达式语法</h3><p>·　　Xpath是W3C的一个标准，因此W3School的在线教程网站上就有，传送门如下：<a href="https://www.w3school.com.cn/xpath/xpath_syntax.asp" target="_blank" rel="noopener">W3CXpath语法</a><br>·<strong>最有用的路径表达式如下</strong>：</p><div class="table-container"><table><thead><tr><th>表达式</th><th>描述</th><th>使用(依据上图的示例)</th><th>含义</th></tr></thead><tbody><tr><td>nodename</td><td>选取此节点下所有的子节点</td><td>beans</td><td>表示beans元素下所有的子节点</td></tr><tr><td>/</td><td>表示从根节点开始选取</td><td>/beans/bean</td><td>表示从根节点开始找到所有beans下所有名为bean的子节点</td></tr><tr><td>//</td><td>不管节点在什么位置，选取该节点</td><td>//property</td><td>表示选取property节点，不管它在什么位置</td></tr><tr><td>.</td><td>选取当前节点</td><td>/</td><td>/</td></tr><tr><td>..</td><td>选取当前节点的父节点</td><td>/</td><td>/</td></tr><tr><td>@</td><td>选取属性</td><td>一般用于谓语中</td><td>/</td></tr></tbody></table></div><p>·<strong>谓语</strong><br>·　　谓语用来查找某个特定的节点或者包含某个指定的值的节点。谓语被嵌在方括号中。</p><div class="table-container"><table><thead><tr><th>路径表达式</th><th>结果</th></tr></thead><tbody><tr><td>/beans/bean[1]</td><td>选取beans子元素下的第一个bean元素</td></tr><tr><td>/beans/bean[@id=”studentDao”]</td><td>选取beans子元素下的属性值为studentDao的bean元素</td></tr></tbody></table></div><h2 id="解析XML文件实例"><a href="#解析XML文件实例" class="headerlink" title="解析XML文件实例"></a>解析XML文件实例</h2><ul><li>首先获取SAXReader对象，此对象在dom4j包中：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br></pre></td></tr></table></figure><ul><li>再从这个对象获取XML文件的document树对象：使用<strong>saxReader.read(…)</strong>；此函数可以传入两个对象，如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Document document = saxReader.read(File io);</span><br><span class="line">Document document = saxReader.read(InputStream in);</span><br></pre></td></tr></table></figure><p>·　　这个两个入参具体使用哪一个看个人喜好，我本人比较喜欢传入InputStream，因为传入File对象需要给出文件相对项目的路径或者绝对路径，不太方便移植。而文件流可以直接从类加载器中获得，只需要保证项目在类路径下即可。</p><ul><li>获取文件流代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XMLTest</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> InputStream in;</span><br><span class="line">    <span class="keyword">static</span>&#123;</span><br><span class="line">       in = XMLTest.class.getClassLoader().getResourceAsStream("beans.xml");</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">testDom4j</span><span class="params">()</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><ul><li>解析需求如下：</li></ul><blockquote><ol><li>获取所有的Bean标签，并获得其下面所有class属性值</li><li>获取id=studentSerivce的bean元素，并获得property的ref属性</li><li>得到beanTest元素的值</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">TestDom4j</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SAXReader saxReader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        Document document = saxReader.read(in);</span><br><span class="line">        <span class="comment">//1.获得bean标签，并得到他们class的属性值</span></span><br><span class="line">        ArrayList&lt;String&gt; beans = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//找到beans元素下的bean的节点</span></span><br><span class="line">        <span class="comment">//List里面的元素应该是Node，但是Element对象继承了Node，因此可以强制转换</span></span><br><span class="line">        List&lt;Element&gt; beanList = document.selectNodes(<span class="string">"/beans/bean"</span>);</span><br><span class="line">        <span class="keyword">for</span>(Element bean:beanList)&#123;</span><br><span class="line">            beans.add(bean.attributeValue(<span class="string">"class"</span>));</span><br><span class="line">            <span class="comment">//获取class属性值的第二种写法</span></span><br><span class="line"><span class="comment">//            Attribute attr = bean.attribute("class");</span></span><br><span class="line"><span class="comment">//            beans.add(attr.getStringValue());</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"bean中的class属性值为："</span> + beans);</span><br><span class="line">        <span class="comment">//2.获取id=studentService的bean元素,并获得其下元素property的属性name值为studentDao的属性ref的值</span></span><br><span class="line">        <span class="comment">//Node对象强制转化成Element</span></span><br><span class="line">        Element p01 = (Element)document.selectSingleNode(<span class="string">"/beans/bean[@id='studentService']/property[@name='studentDao']"</span>);</span><br><span class="line">        System.out.println(<span class="string">"property属性ref的值："</span> + p01.attributeValue(<span class="string">"ref"</span>));</span><br><span class="line">        <span class="comment">//3.得到beanTest元素的值</span></span><br><span class="line">        Element beanTest = (Element) document.selectSingleNode(<span class="string">"/beans/beanTest"</span>);</span><br><span class="line">        System.out.println(<span class="string">"beanTest的值"</span> + beanTest.getStringValue());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>测试结果如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[TestNG] Running:</span><br><span class="line">  C:\Users\handsomestar\.IntelliJIdea2019.1\system\temp-testng-customsuite.xml</span><br><span class="line">bean中的class属性值为：[com.memoforward.service.StudentService, com.memoforward.dao.StudentDao]</span><br><span class="line">property属性ref的值：studentDao</span><br><span class="line">beanTest的值beanTestValue</span><br><span class="line"></span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>·　　解析XML文件还是相当简单的，其实就是一个树的读取，很快就能上手。</p><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇文章主要介绍了如何用Dom4j+Xpath解析XML文件&lt;br&gt;XML的解析在Java的框架源码中十分常用，因此学会解析XML文件是必要的&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java注解学习笔记和案例使用</title>
    <link href="http://yoursite.com/2019/08/25/Java%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%92%8C%E6%A1%88%E4%BE%8B%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/08/25/Java%E6%B3%A8%E8%A7%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%92%8C%E6%A1%88%E4%BE%8B%E4%BD%BF%E7%94%A8/</id>
    <published>2019-08-25T06:02:42.000Z</published>
    <updated>2020-03-07T12:21:04.923Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本篇文章主要讲解了Java中注解的使用<br>本文比较基础<br>写本文的目的是为了在使用注解开发的时候知己知彼</p></blockquote><a id="more"></a><h1 id="Java中的注解"><a href="#Java中的注解" class="headerlink" title="Java中的注解"></a>Java中的注解</h1><p>·　　现在使用框架的趋势是使用注解式开发，注解式开发简单高效。但是知己知彼方能百战不殆，了解和熟悉注解能够让我们更加深入地看懂框架以及记住框架的使用方法。本文章对注解进行了一些简单的总结并实现了一个利用注解进行方法自动化测试的小案例。<br>本节内容涉及一点反射相关的知识，可移步：<a href="https://blog.csdn.net/qq_34294121/article/details/100045782" target="_blank" rel="noopener">反射讲解及案例</a> 进行查看。</p><h2 id="一句话概括"><a href="#一句话概括" class="headerlink" title="一句话概括"></a>一句话概括</h2><p>·　　注解和注释有异曲同工之妙。注释告诉程序员：一个类、一个方法或者一个变量有何作用；而注解则告诉计算机：一个类、一个方法或者一个变量需要进行何种操作。举一个最简单不过的例子：大家耳熟能详的@Override注解则是告诉计算机，某个方法重写了该类父类的方法，若计算机无法找到其父类对应的方法，那么IDE在运行时就会报错。</p><h2 id="JDK内置注解"><a href="#JDK内置注解" class="headerlink" title="JDK内置注解"></a>JDK内置注解</h2><ul><li>@Override：检测被注解标注的方法是否继承至父类</li><li>@Deprecated：表明被该注解标注的内容已过时</li><li>@SuppressWarnings(“all”)：压制被该注解标注内容的所有警告（常见的警告有：使用的方法已过时，声明的方法未使用等）</li></ul><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><h3 id="注解的声明"><a href="#注解的声明" class="headerlink" title="注解的声明"></a>注解的声明</h3><p>·　　Java中是支持自定义注解的，声明方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> xxx&#123;&#125;</span><br></pre></td></tr></table></figure><p>`　　这种声明方式的本质是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">xxx</span> <span class="keyword">extends</span> <span class="title">java</span>.<span class="title">lang</span>.<span class="title">annotation</span>.<span class="title">Annotation</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>·　　说明注解的本质其实是一个接口。有接口就会有方法：规定在接口中定义的方法叫做属性。后面可以看到，这些接口的方法本质上是要传值的。我们用@SuppressWarnins(“all”)为例，可以看到，这个注解被人为传入了值，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　该注解上面的两个注解我们会在下文提到，现在只需要关注在SuppressWarnings注解里定义的属性，该方法返回一个String数组，如果我们在使用SuppressWarings时给该数组传入特定的值，则IDE在运行时就知道该压制何种类型的警告。不过针对@SuppressWarings，我们只需记住传入“all”来压制所有警告就行。注意，其实在@SuppressWarings（“all”）中，我们的书写方式有所省略，完整的书写格式应该如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarings</span>(value = &#123;<span class="string">"all"</span>&#125;)</span><br></pre></td></tr></table></figure><p>·　　原则上，属性名（即方法名）需要在注解声明时写出，如果返回值是数组，需要将值用{}包裹。但是这里有特殊情况，即：属性有且仅有一个，且名为“value”，则属性名可忽略写；如果需要传入数组的值只有一个，则{}也可以省略。</p><h3 id="注解属性的返回值"><a href="#注解属性的返回值" class="headerlink" title="注解属性的返回值"></a>注解属性的返回值</h3><p> ·　　注解属性的返回值类型只可以是以下几种：</p><blockquote><ul><li>基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul></blockquote><p> ·　　只有以上的几种类型可以作为注解属性存在，我们自定义注解一般只会使用String，或者干脆不写属性。</p><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p>·　　元注解是描述注解的注解，用于注解之上，刚才我们查看的@SuppressWarings注解的源码就可以看到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　此时可以看到在SuppressWarnings上有两个注解，这就是元注解。<br>·　　元注解一般使用四个，分别是：</p><ul><li><strong>@Target</strong>：用于描述注解可以作用的位置，其属性值是一个枚举类型Element的数组。一般使用该枚举类型的值有三个：<br>  　　- ElementType.TYPE：该注解只能作用在类上<br>  　　- ElementType.METHOD：该注解只能作用在方法上<br>  　　- ElementType.FIELD：该注解只能作用在成员变量上</li><li><strong>@Retention</strong>：用于描述注解被保留的阶段（Source阶段，Class阶段，Runtime阶段，这三个阶段在我之前讲反射的文章中有提及，可以去<a href="https://blog.csdn.net/qq_34294121/article/details/100045782" target="_blank" rel="noopener">反射讲解</a>中学习），这个注解的属性值是一个枚举类型RetentionPolicy的数组。其枚举类型的值只有三个，分别是：<br>  　　- RetentionPolicy.SOURCE<br>  　　- RetentionPolicy.CLASS<br>  　　- <strong>RetentionPolicy.RUNTIME</strong> （我们自定义注解，一般只是用RUNTIME）</li><li><strong>@Document</strong>：用于描述该注解是否会会被文档给记录。（使用文档注释后，在命令行使用javadoc命令就可以生成代码文档，但是注解默认是不保留在文档里的，如果想要被文档记录，则应加上该注解）</li><li><strong>@Inherited</strong>：描述该注解是否会自动被子类继承</li></ul><h2 id="为何要用方法传递值？"><a href="#为何要用方法传递值？" class="headerlink" title="为何要用方法传递值？"></a>为何要用方法传递值？</h2><p>·　　在接口中，可以声明值，也可以声明方法，声明代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">xxx</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String = <span class="string">"常量"</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title">getChangeableValue</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　可见，在接口中只能声明常量，如果要传入不同的属性值来降低代码的重复率，只能采用调用方法的形式。因此注解的声明中不允许声明常量。</p><h2 id="注解的解析"><a href="#注解的解析" class="headerlink" title="注解的解析"></a>注解的解析</h2><p>·　　之前我们提到，注解是给计算机“看”的，那么计算机是如何识别注解的呢？该节运用到了一些反射的知识，可以去<a href="https://blog.csdn.net/qq_34294121/article/details/100045782" target="_blank" rel="noopener">反射讲解</a>学习反射。<br>·　　一般情况下，我们书写的注解都在RUNTIMME的阶段被解析，而在这个阶段，系统已经得到所有类的字节码Class对象，Class对象能直接从字节码中获得作用在它上面的注解对象，而在Class对象中，有Field，Method和Construct三个封装对象，这个三个对象也都可以在字节码文件中找到作用在它们上方的注解对象。而获取注解的属性值则是通过自动构建该注解的子类对象，并重写注解方法得到的。文字比较晦涩，还是代码看的清楚，下面将给出一个关于注解解析的小案例（通过注解方式构建某个类的对象）：</p><ul><li>首先构建需要操作的类对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.domain;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"江锦平"</span>;</span><br><span class="line">        <span class="keyword">this</span>.gender = <span class="string">"男"</span>;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String gender, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"长生不老+1+1+1...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">(String num)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"寿命延长："</span>+num+<span class="string">"s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Student&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", gender='"</span> + gender + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>构造注解</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD) <span class="comment">//表明该注解只能作用在方法上</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME) <span class="comment">//表明该注解的作用时间是在RUNTIME阶段</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Prop &#123;</span><br><span class="line">    <span class="function">String <span class="title">beanClass</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>写测试代码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@Prop</span>( beanClass = <span class="string">"com.memoforward.domain.Student"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnotationProp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//目的：获取到注解的值，并利用该值得到实例对象</span></span><br><span class="line">    <span class="comment">//第一步：获取该测试类的字节码对象</span></span><br><span class="line">    Class&lt;AnnotationTest&gt; clazz = AnnotationTest<span class="class">.<span class="keyword">class</span></span>; <span class="comment">//测试类的名称为Annotation</span></span><br><span class="line">    <span class="comment">//第二步：从字节码对象中获取到该方法</span></span><br><span class="line">    Method md = clazz.getMethod(<span class="string">"testAnnotationProp"</span>);</span><br><span class="line">    <span class="comment">//第三步，从此方法中获取到压在方法上的注解</span></span><br><span class="line">    <span class="comment">//此步骤会自动生成该注解的实现类，并重写注解的方法</span></span><br><span class="line">    Prop annotation = md.getAnnotation(Prop<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    <span class="comment">//得到类名</span></span><br><span class="line">    String beanClass = annotation.beanClass();</span><br><span class="line">    <span class="comment">//创建实例</span></span><br><span class="line">    Student stu = (Student) Class.forName(beanClass).newInstance();</span><br><span class="line">    System.out.println(stu);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试代码输出，可以看到Student对象已被成功创建，实际上，代码只需稍作修改后，该注解便可以创建任何类的对象，读者有兴趣可以自行操作。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[TestNG] Running:</span><br><span class="line">  C:\Users\handsomestar\.IntelliJIdea2019.1\system\temp-testng-customsuite.xml</span><br><span class="line">Student&#123;name&#x3D;&#39;江锦平&#39;, gender&#x3D;&#39;男&#39;, age&#x3D;999&#125;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><h2 id="注解的小案例"><a href="#注解的小案例" class="headerlink" title="注解的小案例"></a>注解的小案例</h2><p>·　　此案例旨在利用注解实现一个自动化测试的程序，目标是如果某个类的方法加上了@Check注解，那么这个程序就可以自动化实现对这个类的测试，并将测试的异常记录在log日志中。本案例使用的日志框架是slf4j+log4j2。</p><ul><li>@Check注解如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Check &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>需要测试的类如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.operate;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.memoforward.annotation.Check;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NeedToCheck</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">100</span> + <span class="number">100</span>;</span><br><span class="line">        System.out.println(<span class="string">"100 + 100 = "</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">        String str = <span class="keyword">null</span>;</span><br><span class="line">        System.out.println(str.toString());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">div</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">100</span> / <span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">"100 - 100 = "</span> + num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Check</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useArray</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">0</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        System.out.println(a[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">success</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"没有错误..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　上述的类共有5个方法，需要被Check的有4个方法，很显然这4个方法中共会出现三个异常：1. print()方法的空指针异常； 2. div()方法的除0异常；3. useArray()方法的数组越界异常</p><ul><li>自动化测试代码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAnnoatationCheck</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//创建需要被测试的类的实例</span></span><br><span class="line">    NeedToCheck ntc = <span class="keyword">new</span> NeedToCheck();</span><br><span class="line">    Class clazz = ntc.getClass();</span><br><span class="line">    <span class="comment">//得到该类的所有方法</span></span><br><span class="line">    Method[] mds = clazz.getMethods();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(Method md : mds)&#123;</span><br><span class="line">    <span class="comment">//检查该方法是否有@Check注解</span></span><br><span class="line">        <span class="keyword">if</span>(md.isAnnotationPresent(Check<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//如果标注了@Check注解，则检查该方法</span></span><br><span class="line">                md.invoke(ntc);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            <span class="comment">//若出现异常则打印异常</span></span><br><span class="line">                logger.error(md.getName() + <span class="string">"出现了异常"</span>);</span><br><span class="line">                logger.debug(<span class="string">"异常名称为："</span>+ e.getCause().getClass().getSimpleName());</span><br><span class="line">                logger.debug(<span class="string">"异常原因为："</span> + e.getCause().getMessage());</span><br><span class="line">                logger.debug(<span class="string">"-------------------------"</span>);</span><br><span class="line">                count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    logger.debug(<span class="string">"本次测试出现了"</span>+count+<span class="string">"次异常"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>·　　如果各位不想用日志框架就直接用System.out.println()打印异常也可以，证明这个测试时可用的就行。</p><ul><li>控制台输出结果如下，可以看到没有被@Check标注的success没有执行。</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[TestNG] Running:</span><br><span class="line">  C:\Users\handsomestar\.IntelliJIdea2019.1\system\temp-testng-customsuite.xml</span><br><span class="line">100 + 100 &#x3D; 200</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><ul><li>日志文件输出如下，所有异常均被捕获。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.696</span> ERROR AnnotationTest <span class="number">46</span> testAnnoatationCheck - print出现了异常</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.703</span> DEBUG AnnotationTest <span class="number">47</span> testAnnoatationCheck - 异常名称为：NullPointerException</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.703</span> DEBUG AnnotationTest <span class="number">48</span> testAnnoatationCheck - 异常原因为：<span class="keyword">null</span></span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.704</span> DEBUG AnnotationTest <span class="number">49</span> testAnnoatationCheck - -------------------------</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.704</span> ERROR AnnotationTest <span class="number">46</span> testAnnoatationCheck - useArray出现了异常</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.705</span> DEBUG AnnotationTest <span class="number">47</span> testAnnoatationCheck - 异常名称为：ArrayIndexOutOfBoundsException</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.705</span> DEBUG AnnotationTest <span class="number">48</span> testAnnoatationCheck - 异常原因为：<span class="number">2</span></span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.705</span> DEBUG AnnotationTest <span class="number">49</span> testAnnoatationCheck - -------------------------</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.705</span> ERROR AnnotationTest <span class="number">46</span> testAnnoatationCheck - div出现了异常</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.705</span> DEBUG AnnotationTest <span class="number">47</span> testAnnoatationCheck - 异常名称为：ArithmeticException</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.705</span> DEBUG AnnotationTest <span class="number">48</span> testAnnoatationCheck - 异常原因为：/ by zero</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.706</span> DEBUG AnnotationTest <span class="number">49</span> testAnnoatationCheck - -------------------------</span><br><span class="line"><span class="number">14</span>:<span class="number">22</span>:<span class="number">39.706</span> DEBUG AnnotationTest <span class="number">54</span> testAnnoatationCheck - 本次测试出现了<span class="number">3</span>次异常</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>·　　注解算是Java基础的一个增强，非常简单，但是如果没有理解的话，看源码还是有些许的头疼，不过一旦学会，应该不容易遗忘，希望今后在运用框架的时候能快速熟练掌握注解式开发这一技能。</p><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本篇文章主要讲解了Java中注解的使用&lt;br&gt;本文比较基础&lt;br&gt;写本文的目的是为了在使用注解开发的时候知己知彼&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java反射讲解与案例实战</title>
    <link href="http://yoursite.com/2019/08/24/Java%E5%8F%8D%E5%B0%84%E8%AE%B2%E8%A7%A3%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/"/>
    <id>http://yoursite.com/2019/08/24/Java%E5%8F%8D%E5%B0%84%E8%AE%B2%E8%A7%A3%E4%B8%8E%E6%A1%88%E4%BE%8B%E5%AE%9E%E6%88%98/</id>
    <published>2019-08-24T02:29:17.000Z</published>
    <updated>2020-03-07T12:22:14.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>本文章旨在讲解一下java的反射机制和概念，以及利用反射原理制造一个简单的框架<br>框架内容：能够用一个getBean(String id)方法，创建任何的Bean对象）。</p></blockquote><a id="more"></a><p>github源码传送门：<a href="https://github.com/MemoForward/ReflectDemo01" target="_blank" rel="noopener">github反射案例</a>　　</p><h2 id="反射的概念"><a href="#反射的概念" class="headerlink" title="反射的概念"></a>反射的概念</h2><p>·　反射是框架设计的灵魂，反射的机制是将一个类的<strong>各个组成部分</strong>封装成其他的对象保存在Class类对象中。<br>·　Java的类在计算机中会经历三个阶段：</p><ul><li><strong>源代码阶段</strong>：我们编写的某个类经过javac指令编译后生成了.class字节码文件，这些文件存储在硬盘上</li><li><strong>类对象阶段</strong>：类加载器ClassLoader将字节码文件加载进内存中，由一个Class类对象保存这个类<strong>各个组成部分</strong>的所有信息：<ul><li>该类的成员变量封装成 Field[] 对象</li><li>该类的构造方法封装成 Constructor[] 对象</li><li>该类的成员方法封装成 Method[] 对象</li></ul></li><li><strong>Runtime运行时阶段</strong>：通过类对象创建该类的实例并使用</li></ul><p>·　反射的优势：可以给代码解耦，提高程序的可扩展性。</p><h2 id="获取字节码Class对象"><a href="#获取字节码Class对象" class="headerlink" title="获取字节码Class对象"></a>获取字节码Class对象</h2><p>·　　由上一节可知，在运行阶段创建类的实例是需要通过Class对象的，要利用反射机制必然要使用这个对象，而获取这个对象有三种方式：</p><ul><li>使用 Class.forName(“全类名”)</li><li>使用 类名.class</li><li>使用 实例.getClass()<br>·　　一个 .class 字节码文件被ClassLoader加载进内存之后，类的所有信息（Class对象）都存在<strong>方法区</strong>中，一个类的信息只有会一块内存存储，<strong>因此，无论利用哪种方法获取到某个类的Class对象，该对象都只指向一块内存</strong>。注：方法区是不同于堆的一块内存空间，一般不会被垃圾回收器回收。<br>·　　以下是利用三种方法获取到class对象的代码，并判断了它们是否指向同一块内存。</li><li>类定义如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//该区域为所定义的类：所在的包为com.memoforward</span></span><br><span class="line"><span class="keyword">package</span> com.memforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"><span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String gender;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"江锦平"</span>;</span><br><span class="line">        <span class="keyword">this</span>.gender = <span class="string">"男"</span>;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, String gender, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"长生不老+1+1+1...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">live</span><span class="params">(String num)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"寿命延长："</span>+num+<span class="string">"s"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//toString</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试代码如下</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用了testNG进行了测试</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getClassTest</span><span class="params">()</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//方法一</span></span><br><span class="line">        Class clazz1 = Class.forName(<span class="string">"com.memforward.Student"</span>);</span><br><span class="line">        System.out.println(<span class="string">"clazz1:"</span> + clazz1);</span><br><span class="line">        <span class="comment">//方法二</span></span><br><span class="line">        Class clazz2 = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(<span class="string">"clazz2:"</span> + clazz2);</span><br><span class="line">        <span class="comment">//方法三</span></span><br><span class="line">        Class clazz3 = <span class="keyword">new</span> Student().getClass();</span><br><span class="line">        System.out.println(<span class="string">"clazz3:"</span> + clazz3);</span><br><span class="line">        <span class="comment">//判断是否指向同一个对象 ，都返回true</span></span><br><span class="line">        System.out.println(clazz1 == clazz2);</span><br><span class="line">        System.out.println(clazz2 == clazz3);</span><br><span class="line">        System.out.println(clazz1 == clazz3);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>其输出为：</strong><br>　　<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[TestNG] Running:</span><br><span class="line">  C:\Users\handsomestar\.IntelliJIdea2019.1\system\temp-testng-customsuite.xml</span><br><span class="line">clazz1:class com.memforward.Student</span><br><span class="line">clazz2:class com.memforward.Student</span><br><span class="line">clazz3:class com.memforward.Student</span><br><span class="line">true  </span><br><span class="line">true</span><br><span class="line">true</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure></p><h2 id="使用Class对象"><a href="#使用Class对象" class="headerlink" title="使用Class对象"></a>使用Class对象</h2><p>·　　Class对象中封装了一个类的<strong>成员变量、构造方法和成员方法</strong>。一般情况下，我们需要获得和使用的就是这三个部分的值，诚然一个Class对象中有很多的方法，但是我们最常用的只有以下几种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取成员变量</span></span><br><span class="line"> Field[] getFields() </span><br><span class="line"> Field[] getDeclaredFields() </span><br><span class="line"> <span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span>  </span></span><br><span class="line"><span class="function"> Field <span class="title">getDeclaredField</span><span class="params">(String name)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//获取构造方法</span></span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getConstructors</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getDeclaredConstructors</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(Class&lt;?&gt;... parameterTypes)</span></span></span><br><span class="line"><span class="function"><span class="comment">//获取成员方法</span></span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name, Class&lt;?&gt;... parameterTypes)</span> </span></span><br><span class="line"><span class="function"><span class="comment">//获取类名</span></span></span><br><span class="line"><span class="function">String <span class="title">getName</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"><span class="comment">//获取类加载器</span></span></span><br><span class="line"><span class="function">ClassLoader <span class="title">getClassLoader</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>·　看上面的方法可知，Class对象既可以得到该类的对应的<em>组成部分</em>的数组，也可以定向找到某项属性。声明了Declared的方法则可以得到该类的私有声明的信息。<br>·　该类的组成部分被封装在了Field、Constructor和Method对象，很显然这些对象有各自的用途：Field可以用来获取和设置某个实例成员变量的值；Constructor可以用来创建该类的实例对象；Method方法可以用来调用该类实例的方法。<br>以下为这三个对象的测试：</p><h3 id="Field对象的测试"><a href="#Field对象的测试" class="headerlink" title="Field对象的测试"></a>Field对象的测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Field对象的测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testField</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class clazz = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        System.out.println(<span class="string">"-----------getFields------------"</span>);</span><br><span class="line">        Field[] fields01 = clazz.getFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field: fields01) System.out.println(field);</span><br><span class="line">        System.out.println(<span class="string">"-----------getDeclaredFileds----"</span>);</span><br><span class="line">        Field[] fields02 = clazz.getDeclaredFields();</span><br><span class="line">        <span class="keyword">for</span> (Field field:fields02) System.out.println(field);</span><br><span class="line">        System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">        Field nameField = clazz.getField(<span class="string">"name"</span>);</span><br><span class="line">        Student stu = <span class="keyword">new</span> Student();</span><br><span class="line">        System.out.println(<span class="string">"原来的stu："</span> + stu);</span><br><span class="line">        <span class="comment">//通过Filed获得实例的值</span></span><br><span class="line">        String sname = (String)nameField.get(stu);</span><br><span class="line">        <span class="comment">//通过Field设置实例的值</span></span><br><span class="line">        nameField.set(stu, <span class="string">"胡近民"</span>);</span><br><span class="line">        <span class="comment">//如果要获取私有的值</span></span><br><span class="line">        Field ageField = clazz.getDeclaredField(<span class="string">"age"</span>);</span><br><span class="line">        <span class="comment">//操作私有的值必须要开启权限，暴力反射</span></span><br><span class="line">        ageField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        ageField.set(stu,<span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"修改后的stu："</span> + stu);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Field测试的输出：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[TestNG] Running:</span><br><span class="line">  C:\Users\handsomestar\.IntelliJIdea2019.1\system\temp-testng-customsuite.xml</span><br><span class="line">-----------getFields------------</span><br><span class="line">public java.lang.String com.memforward.Student.name</span><br><span class="line">public java.lang.String com.memforward.Student.gender</span><br><span class="line">-----------getDeclaredFileds----  &#x2F;&#x2F;这里可以看到private属性的age也被获取到了</span><br><span class="line">public java.lang.String com.memforward.Student.name</span><br><span class="line">public java.lang.String com.memforward.Student.gender</span><br><span class="line">private java.lang.Integer com.memforward.Student.age</span><br><span class="line">--------------------------------</span><br><span class="line">原来的stu：Student&#123;name&#x3D;&#39;江锦平&#39;, gender&#x3D;&#39;男&#39;, age&#x3D;999&#125;</span><br><span class="line">修改后的stu：Student&#123;name&#x3D;&#39;胡近民&#39;, gender&#x3D;&#39;男&#39;, age&#x3D;1000&#125;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><h3 id="Constructor对象的测试"><a href="#Constructor对象的测试" class="headerlink" title="Constructor对象的测试"></a>Constructor对象的测试</h3><p>小贴士：如果该类的构造是私有的，也是可以利用反射得到其构造器创建实例对象的，方法如Field，此测试就不写了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Constructor对象的测试</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testConstructor</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class clazz = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">//获取Constructor对象</span></span><br><span class="line">        <span class="comment">//1.1返回了无参构造</span></span><br><span class="line">        Constructor constructor01 = clazz.getConstructor();</span><br><span class="line">        Student stu01 = (Student) constructor01.newInstance();</span><br><span class="line">        System.out.println(<span class="string">"获得了无参构造器："</span> + stu01);</span><br><span class="line">        <span class="comment">//1.2 返回有参构造</span></span><br><span class="line">        Constructor constructor02 = clazz.getConstructor(String<span class="class">.<span class="keyword">class</span>,<span class="title">String</span>.<span class="title">class</span>,<span class="title">Integer</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        Student stu02 = (Student) constructor02.newInstance(<span class="string">"胡近民"</span>, <span class="string">"男"</span>, <span class="number">1000</span>);</span><br><span class="line">        System.out.println(<span class="string">"获得了有参构造器:"</span> + stu02);</span><br><span class="line">        <span class="comment">//无参构造器生成实例可以直接由Class对象获得</span></span><br><span class="line">        Student stu03 = (Student) clazz.newInstance();</span><br><span class="line">        System.out.println(<span class="string">"Class对象直接生成的实例："</span> + stu03);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br><strong>Constructor测试的输出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[TestNG] Running:</span><br><span class="line">  C:\Users\handsomestar\.IntelliJIdea2019.1\system\temp-testng-customsuite.xml</span><br><span class="line">获得了无参构造器：Student&#123;name&#x3D;&#39;江锦平&#39;, gender&#x3D;&#39;男&#39;, age&#x3D;999&#125;</span><br><span class="line">获得了有参构造器:Student&#123;name&#x3D;&#39;胡近民&#39;, gender&#x3D;&#39;男&#39;, age&#x3D;1000&#125;</span><br><span class="line">Class对象直接生成的实例：Student&#123;name&#x3D;&#39;江锦平&#39;, gender&#x3D;&#39;男&#39;, age&#x3D;999&#125;</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><h3 id="Method对象的测试"><a href="#Method对象的测试" class="headerlink" title="Method对象的测试"></a>Method对象的测试</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Method对象的测试</span></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMethod</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        Class clazz = Student<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">//获得方法</span></span><br><span class="line">        <span class="comment">//1.1获得无参方法</span></span><br><span class="line">        Method md01 = clazz.getMethod(<span class="string">"live"</span>);</span><br><span class="line">        <span class="comment">//调用方法（需要有实例才可以执行该方法）</span></span><br><span class="line">        md01.invoke(<span class="keyword">new</span> Student());</span><br><span class="line">        <span class="comment">//1.2获得有参的方法</span></span><br><span class="line">        Method md02 = clazz.getMethod(<span class="string">"live"</span>, String<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        md02.invoke(<span class="keyword">new</span> Student(),<span class="string">"1"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>Method测试的输出</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[TestNG] Running:</span><br><span class="line">  C:\Users\handsomestar\.IntelliJIdea2019.1\system\temp-testng-customsuite.xml</span><br><span class="line">长生不老+1+1+1....</span><br><span class="line">寿命延长：1s</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><h2 id="反射的案例"><a href="#反射的案例" class="headerlink" title="反射的案例"></a>反射的案例</h2><p>·　　需求：实现一个“框架类”，该类可以创建任意类的对象，并能使用该类对象。<br>·　　解决方案：此“框架类”通过加载配置文件，得到某个具体类的全类名，通过反射创建该类的实例即可。<br><strong>以下是配置文件：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//beansConfig.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"student"</span> <span class="attr">class</span>=<span class="string">"com.memforward.Student"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"person"</span> <span class="attr">class</span>=<span class="string">"com.memforward.Person"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>下面是新添加的Person类：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"习"</span>;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">999</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"：修身治国齐家平天下...."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saySomething</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name + <span class="string">"：TW必将光复，HK属于CN！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>以下是框架ReflectDemo，利用Dom4j读取XML文件</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memforward;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.dom4j.Attribute;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Document;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.DocumentException;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.Element;</span><br><span class="line"><span class="keyword">import</span> org.dom4j.io.SAXReader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Document document = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadProperties</span><span class="params">(String config)</span> </span>&#123;</span><br><span class="line">        SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Document document = reader.read(<span class="keyword">new</span> File(<span class="string">"src/main/resources/beansConfig.xml"</span>));</span><br><span class="line">            ReflectDemo.document = document;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (DocumentException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String id)</span></span>&#123;</span><br><span class="line">        Element bean = <span class="keyword">null</span>;</span><br><span class="line">        String className = <span class="keyword">null</span>;</span><br><span class="line">        Element root = document.getRootElement();</span><br><span class="line">        List&lt;Element&gt; beans = root.elements(<span class="string">"bean"</span>);</span><br><span class="line">        <span class="comment">//找到配置文件里的节点</span></span><br><span class="line">        <span class="keyword">for</span>(Element e : beans)&#123;</span><br><span class="line">            <span class="keyword">if</span>(e.attribute(<span class="string">"id"</span>).getValue().equals(id))&#123;</span><br><span class="line">                bean = e;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(bean == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没有你指定的类："</span> + id);</span><br><span class="line">        className = bean.attribute(<span class="string">"class"</span>).getValue();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class clazz = Class.forName(className);</span><br><span class="line">            Object obj = clazz.newInstance();</span><br><span class="line">            <span class="keyword">return</span> obj;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下面是测试代码：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReflectDemo</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ReflectDemo.loadProperties(<span class="string">"beansConfig.xml"</span>);</span><br><span class="line">    ReflectDemo rd = <span class="keyword">new</span> ReflectDemo();</span><br><span class="line">    Student stu = (Student) rd.getBean(<span class="string">"student"</span>);</span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    stu.live();</span><br><span class="line">    Person person = (Person) rd.getBean(<span class="string">"person"</span>);</span><br><span class="line">    <span class="comment">//调用方法</span></span><br><span class="line">    person.doSomething();</span><br><span class="line">    person.saySomething();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>下面是测试代码的输出，可见这个框架再加载了配置文件后，可以很方便的创建你所配置的任意类的对象，并使用该对象的方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[TestNG] Running:</span><br><span class="line">  C:\Users\handsomestar\.IntelliJIdea2019.1\system\temp-testng-customsuite.xml</span><br><span class="line">长生不老+1+1+1....</span><br><span class="line">习：修身治国齐家平天下....</span><br><span class="line">习：TW必将光复，HK属于CN！</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">Default Suite</span><br><span class="line">Total tests run: 1, Failures: 0, Skips: 0</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>·　　以上就是整个反射的概念以及最常用的几个方法，可见反射其实也不是难，但是其思想着实是一大飞跃。几乎所有的代码我都贴在了博客上，如果有小伙伴不想复制粘贴，可以去我的github上下载源码(所用的IDE是Intellj idea)：<a href="https://github.com/MemoForward/ReflectDemo01" target="_blank" rel="noopener">github反射案例</a></p><h2 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h2><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本文章旨在讲解一下java的反射机制和概念，以及利用反射原理制造一个简单的框架&lt;br&gt;框架内容：能够用一个getBean(String id)方法，创建任何的Bean对象）。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>学生管理系统（JSP+Servlet+MySQL）</title>
    <link href="http://yoursite.com/2019/08/13/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F(JSP-Servlet-MySQL)/"/>
    <id>http://yoursite.com/2019/08/13/%E5%AD%A6%E7%94%9F%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F(JSP-Servlet-MySQL)/</id>
    <published>2019-08-13T03:39:06.000Z</published>
    <updated>2020-03-07T12:08:01.088Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><blockquote><p>&#160; &#160; &#160; &#160;用了小半年的时间摸索了一下Java后端，最近在学框架的时候觉得之前学习的内容有所遗忘，因此想自己做一个特别简单但是功能还算齐全的学生管理系统，给自己加深一下对servlet的理解。本人平时用Eclipse比较多，为了熟悉一下其他的IDE，这次的项目就用IDEA开发了。笔者也是一个初学者，理解不到位的地方还请各位朋友指出。本项目不使用web.xml手动添加servlet和filter，均采用注解的方式添加，需要创建web3.0及以上的工程。</p></blockquote><a id="more"></a><p><strong>github传送门</strong>  ：<a href="https://github.com/MemoForward/StudentManagement" target="_blank" rel="noopener">https://github.com/MemoForward/StudentManagement</a> </p><h1 id="项目功能"><a href="#项目功能" class="headerlink" title="项目功能"></a>项目功能</h1><ul><li>实现对学生列表的增删改查</li></ul><h1 id="运用知识"><a href="#运用知识" class="headerlink" title="运用知识"></a>运用知识</h1><ul><li>mysql数据库增删改查语句（单表）</li><li>c3p0数据库连接池(c3p0-config.xml)</li><li>使用dbutils简化操作（QueryRunner）</li><li>使用BeanUtils封装数据(BeanUtils.populate(…))</li><li>MVC设计模式</li><li>servlet的使用</li><li>过滤器的使用(涉及一点点)</li><li>反射</li></ul><h1 id="前期准备工作"><a href="#前期准备工作" class="headerlink" title="前期准备工作"></a>前期准备工作</h1><p>&#160; &#160; &#160; &#160;工欲善其事，必先利其器。每个人都要以一名项目经理的角度要求自己，做项目之前先把框架搭好了：导入必要的环境配置以及构建好项目的架构。</p><h2 id="导入jar包"><a href="#导入jar包" class="headerlink" title="导入jar包"></a>导入jar包</h2><p>&#160; &#160; &#160; &#160;寻找jar包一直是最令人头疼的事情，所有还是推荐大家能尽快学习Maven，这次因为是最基础的Web工程，因此我就手动导入了，这里给出Maven的中心仓库，所有的jar包都可以在里面下载：<a href="http://mvnrepository.com" target="_blank" rel="noopener">http://mvnrepository.com</a>（千万别去CSDN上用积分下载，大部分在CSDN上用钱买的资源都是免费的），笔者用的jar都比较老旧，读者可以自行下载新版。所有的包都应放在项目web文件夹下的 WEB-INF/lib 中。</p><blockquote><p>c3p0-0.9.2-pre5.jar<br>commons-beanutils-1.8.3.jar<br>mysql-connector-java-5.1.39-bin.jar<br>commons-dbutils-1.4.jar<br>mchange-commons-java-0.2.3.jar // c3p0在0.9.2版本后会多出来一个辅助包<br>jstl.jar<br>standard.jar  // 使用jstl标签需要用到的包<br>commons-logging-1.1.1.jar </p></blockquote><h2 id="创建包"><a href="#创建包" class="headerlink" title="创建包"></a>创建包</h2><p>&#160; &#160; &#160; &#160;MVC：Model，View，Controller 分别代表Web工程中的三层结构。Model相当于持久层，主要用于与数据库交互，处理一些业务逻辑；View相当于展现层（WEB层），用于展现数据；Controller相当于控制层，用于处理Web层的数据并提供给持久层。<br>&#160; &#160; &#160; &#160;基于MVC架构，我们的项目也应该分成一个个的小的组件，而Web层都是jsp界面，因此在这里我们应该针对持久层和控制层建相应的包（src目录下）：</p><h3 id="持久层"><a href="#持久层" class="headerlink" title="持久层"></a>持久层</h3><pre><code>- dao（实现与数据库的交互 Data Access Object）- service（实现业务逻辑）- domain（存放Bean的包）</code></pre><h3 id="控制层（统一放在web包下）"><a href="#控制层（统一放在web包下）" class="headerlink" title="控制层（统一放在web包下）"></a>控制层（统一放在web包下）</h3><pre><code>- servlet- base（本项目使用了反射原理强化了普通servlet）- filter （过滤器）</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><pre><code>- utils（工具包）</code></pre><h2 id="创建配置文件"><a href="#创建配置文件" class="headerlink" title="创建配置文件"></a>创建配置文件</h2><p>&#160; &#160; &#160; &#160;主要需要两个配置文件：log4j.properties 和 c3p0-config.xml。分别是使用log4j和c3p0的依赖。这两个配置文件都应该放置在类路径下（src/）</p><h3 id="log4j-properties"><a href="#log4j-properties" class="headerlink" title="log4j.properties"></a>log4j.properties</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#参考资料：http:&#x2F;&#x2F;www.blogjava.net&#x2F;zJun&#x2F;archive&#x2F;2006&#x2F;06&#x2F;28&#x2F;55511.html</span><br><span class="line">log4j.rootLogger&#x3D;debug,stdout,D</span><br><span class="line">log4j.appender.stdout&#x3D;org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.Target&#x3D;System.out</span><br><span class="line">log4j.appender.stdout.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern&#x3D;%d&#123;ABSOLUTE&#125; %5p %c&#123;1&#125;:%L - %m%n</span><br><span class="line">#log4j.appender.D&#x3D;org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">##log4j.appender.D.File&#x3D;填写</span><br><span class="line">#log4j.appender.D.Append&#x3D;true</span><br><span class="line">#log4j.appender.D.Threshold&#x3D;DEBUG</span><br><span class="line">#log4j.appender.D.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">#log4j.appender.D.layout.ConversionPattern&#x3D;%d&#123;[yyyy&#x2F;MM&#x2F;dd HH:mm:ss,SSS]&#125; [%5p] [%c:%L] - %m%n</span><br><span class="line">#log4j.appender.D&#x3D;org.apache.log4j.DailyRollingFileAppender</span><br><span class="line">##log4j.appender.D.File&#x3D;填写</span><br><span class="line">#log4j.appender.D.Append&#x3D;true</span><br><span class="line">#log4j.appender.D.Threshold&#x3D;ERROR</span><br><span class="line">#log4j.appender.D.layout&#x3D;org.apache.log4j.PatternLayout</span><br><span class="line">#log4j.appender.D.layout.ConversionPattern&#x3D;%d&#123;[yyyy&#x2F;MM&#x2F;dd HH:mm:ss,SSS]&#125; [%5p] [%c:%L] - %m%n</span><br></pre></td></tr></table></figure><h3 id="c3p0-config-xml-最好不要修改名字"><a href="#c3p0-config-xml-最好不要修改名字" class="headerlink" title="c3p0-config.xml(最好不要修改名字)"></a>c3p0-config.xml(最好不要修改名字)</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version='1.0' encoding='UTF-8'?&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">c3p0-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">default-config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span>&gt;</span>jdbc:mysql://localhost:3306/数据库名<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span>密码<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        连接池用完后等待，超时则抛异常--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"checkoutTimeout"</span>&gt;</span>30000<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        每30秒检测连接池中的空闲连接--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"idleConnectionTestPeriod"</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        初始化连接个数--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"initialPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        最大空闲时间，大于30秒则释放连接--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxIdleTime"</span>&gt;</span>30<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxPoolSize"</span>&gt;</span>50<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"minPoolSize"</span>&gt;</span>10<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--        预缓存语句总计不超过200条--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxStatements"</span>&gt;</span>200<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"destroy-method"</span>&gt;</span>close<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">default-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">c3p0-config</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><p>&#160; &#160; &#160; &#160; 本项目只用到了一个表，所以非常的简单，学生表的字段只有6个，分别是：id（主键），学号，姓名，性别，年龄，生日。这里给出创建表的sql语句。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#96;stu&#96;DROP DATABASE IF EXISTS student_00;</span><br><span class="line">CREATE DATABASE student_00 DEFAULT CHARACTER SET utf8;</span><br><span class="line"></span><br><span class="line">USE student_00;</span><br><span class="line"></span><br><span class="line">CREATE&#96;stu&#96; TABLE stu(</span><br><span class="line">sid VARCHAR(255) NOT NULL PRIMARY KEY,</span><br><span class="line">snum INT(10),</span><br><span class="line">sname VARCHAR(255),</span><br><span class="line">sage INT(10),</span><br><span class="line">sgender VARCHAR(20),</span><br><span class="line">birthday DATE DEFAULT NULL</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h1 id="美工"><a href="#美工" class="headerlink" title="美工"></a>美工</h1><p>&#160; &#160; &#160; &#160;  在写代码之前，笔者比较喜欢先把界面做出一个雏形，这样调试起来比较直观。但是笔者的前端技术非常之差，接触代码也不过一年的时间，所以没有时间学，这次的界面做的比较糟糕，各种bootstrap的组件乱贴，代码估计也会有很多的冗余，这里只给出图片，具体的内容各位如果有兴趣可以去git上下载源码。各位朋友如果实在看不下去，笔者也十分渴望和各位多多交流。所有的资源都应放在项目的web文件夹下。（忽略年龄和出生日期不匹配的问题…）</p><h2 id="主界面"><a href="#主界面" class="headerlink" title="主界面"></a>主界面</h2><p><img src="https://img-blog.csdnimg.cn/20190812193517122.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="展示主界面"></p><h2 id="编辑学生和添加学生界面"><a href="#编辑学生和添加学生界面" class="headerlink" title="编辑学生和添加学生界面"></a>编辑学生和添加学生界面</h2><p><img src="https://img-blog.csdnimg.cn/20190812193648730.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="编辑学生"></p><h1 id="书写代码"><a href="#书写代码" class="headerlink" title="书写代码"></a>书写代码</h1><p>&#160; &#160; &#160; &#160;  这一部分的代码量还是挺多的，各位如果有兴趣可以去git上下载源码。这里主要介绍一下（JSP+Servlet+MySQL）的流程，其实网上优秀的教程还是很多的，各位不嫌弃的话在这里稍微看一下也无妨。除了基本的概念外，笔者还将介绍一下如何增强Servlet和实现过滤的操作，以及自己编写的工具类的介绍。</p><h2 id="Jsp-Servlet-MySQL"><a href="#Jsp-Servlet-MySQL" class="headerlink" title="Jsp+Servlet+MySQL"></a>Jsp+Servlet+MySQL</h2><p>&#160; &#160; &#160; &#160;  最典型的MVC设计模式莫过于Jsp+Servlet+JavaBean：Jsp负责传递用户的输入以及显示用户需要的数据；Servlet用来处理从Jsp界面中传递过来的请求（获取到用户输入的数据），将数据进行业务逻辑处理后，将需要展示的数据封装到域对象（一般是request，session）中；而Servlet处理数据的操作主要是通过JavaBean来与数据库进行对话。因此，可以很清晰的看到，Servlet在数据的交互的过程中，起到了一个中间层的控制作用。如下图所示，一般情况下，每一个不一样的Jsp的请求我们就需要去创建一个Servlet类去处理（这里注意一下本项目中Servlet是<strong>单例多线程</strong>的，因此会有线程安全的问题），所以我们需要去创建很多的Servlet类去实现功能。<br><img src="https://img-blog.csdnimg.cn/20190812201226637.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="JSP+Servlet+MySQL流程"><br>&#160; &#160; &#160; &#160;  这里必须说明一下Service和DAO的区别。Serive和DAO里面的内容都是业务逻辑，比如：查找某个学生，修改某个学生信息等。但是DAO层我们往往只关心单层逻辑，而在Service层中我们可以实现多层逻辑。这里举个比较直观的例子：<strong>在本项目中实现了分页的功能，我们抽取的页面Bean（PageBean：可以理解为一个页面往往不会只包含了学生的个人信息，因此需要将页面的模型抽取出来）中包含两个变量:一个是数据库中总的学生数量，一个是本页（可见上图的主界面）中包含的学生信息。我们在Servlet中希望得到的数据是一个包含这两个变量数据的PageBean，而获取PageBean中两个变量的操作对应了两条sql语句：</strong><code>select count(*) from stu</code><strong>和</strong><code>select * from stu limit ?,?</code><strong>这两条语句其实就是两个业务逻辑，对应两个DAO层的方法，而Service的作用就是组装这两个逻辑，实现多层的逻辑，即获取到整个页面的数据。</strong> 因为本项目过于简单，所以这两层其实也没有必要细分，不过以后一定会遇到更为复杂的项目的，所以还是建议各位养成良好的习惯。<br>&#160; &#160; &#160; &#160;  这里笔者还是稍加笔墨用一个简单的示例展现一下这个流程在本项目中的应用，如果用户想要<strong>删除学生</strong>:<br><img src="https://img-blog.csdnimg.cn/20190812205400910.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="删除学生流程"></p><h2 id="增强Servlet"><a href="#增强Servlet" class="headerlink" title="增强Servlet"></a>增强Servlet</h2><p>&#160; &#160; &#160; &#160; 上一小节我们介绍了一下Jsp+Servlet+MySQL的流程，这种流程还是非常简单易懂的，但是有一个特别不方便的地方在于，每一个来自页面的请求，我们往往都需要一个Servlet类去满足这个请求，这其实是不符合我们的生活习惯的，试想一下：如果存钱和取钱对应不同的ATM机，估计我们会被搞疯掉。我们更希望面对的情况是：一台ATM机会处理来自所有关于存款的操作。也就是说，我们希望用一个关于学生的StudentServlet去满足所有针对情况的请求，不同的请求对应不同的方法。而<strong>servlet的生命周期</strong>是这样的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- init() &#x2F;&#x2F;第一次创建 Servlet 时被调用,后续的请求不再调用</span><br><span class="line">- service(ServletRequest request, ServletResponse response) &#x2F;&#x2F;Servlet处理客户端请求所调用的方法</span><br><span class="line">- 在Service下有我们常见的doGet和doPost方法</span><br><span class="line"> - destory() &#x2F;&#x2F;只会被调用一次，在 Servlet 生命周期结束时被调用</span><br><span class="line"> - 被垃圾回收</span><br></pre></td></tr></table></figure><p>&#160; &#160; &#160; &#160; 可以看到，servlet最核心的部分就是service()方法，我们自己创建的Servlet都是要继承HttpServlet类，如果有阅读源码习惯的小伙伴可以看一下这个类中实现d的service()方法，这个方法会分析界面的请求类型，自动调用doGet和doPost方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String method = req.getMethod(); <span class="comment">//在这里取界面出传递过来的方法，一般就是GET或者POST</span></span><br><span class="line">        <span class="keyword">long</span> lastModified;</span><br><span class="line">        <span class="keyword">if</span> (method.equals(<span class="string">"GET"</span>)) &#123;</span><br><span class="line">            lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">if</span> (lastModified == -<span class="number">1L</span>) &#123;</span><br><span class="line">                <span class="keyword">this</span>.doGet(req, resp); </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">long</span> ifModifiedSince;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    ifModifiedSince = req.getDateHeader(<span class="string">"If-Modified-Since"</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">                    ifModifiedSince = -<span class="number">1L</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ifModifiedSince &lt; lastModified / <span class="number">1000L</span> * <span class="number">1000L</span>) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">                    <span class="keyword">this</span>.doGet(req, resp);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    resp.setStatus(<span class="number">304</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"HEAD"</span>)) &#123;</span><br><span class="line">            lastModified = <span class="keyword">this</span>.getLastModified(req);</span><br><span class="line">            <span class="keyword">this</span>.maybeSetLastModified(resp, lastModified);</span><br><span class="line">            <span class="keyword">this</span>.doHead(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"POST"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"PUT"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doPut(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"DELETE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doDelete(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"OPTIONS"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doOptions(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(<span class="string">"TRACE"</span>)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.doTrace(req, resp);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">            Object[] errArgs = <span class="keyword">new</span> Object[]&#123;method&#125;;</span><br><span class="line">            errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">            resp.sendError(<span class="number">501</span>, errMsg);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&#160; &#160; &#160; &#160;而我们去实现自己的子类Servlet的时候，就是在重写doGet方法，笔者在这里因为篇幅原因不加赘述。但是如果要实现我们的目标应该怎么做呢？<strong>由HttpServlet类中的service()方法得到启发：我们应该直接从界面传递要执行的Servlet请求方法，在service()方法中得到请求的方法名，从而直接利用反射调用子类的方法。因此我们需要重写service()方法，所以笔者建立了Base包来创造一个BaseServlet来重新实现service()方法</strong>。话不多说，上代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String method = req.getParameter(<span class="string">"method"</span>); <span class="comment">//客户端的请求应包含mehod的键来传递方法名</span></span><br><span class="line">        <span class="comment">//如果没有method键，则调用默认方法</span></span><br><span class="line">        <span class="keyword">if</span>(method == <span class="keyword">null</span> || method.equals(<span class="string">""</span>))&#123;</span><br><span class="line">            method = <span class="string">"excute"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果子类继承了这个类，则会创建子类的servlet，使用this会得到子类的类字节码</span></span><br><span class="line">        Class clazz = <span class="keyword">this</span>.getClass();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Method md = clazz.getMethod(method,HttpServletRequest<span class="class">.<span class="keyword">class</span>, <span class="title">HttpServletResponse</span>.<span class="title">class</span>)</span>;</span><br><span class="line">            <span class="keyword">if</span>(md != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="comment">//子类必须要返回一个供父类转发的页面路径，如果子类想重定向，则return null;</span></span><br><span class="line">                String jspPath = (String)md.invoke(<span class="keyword">this</span>, req, resp);</span><br><span class="line">                <span class="keyword">if</span>(jspPath != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">//子类的所有方法，统一由父类转发</span></span><br><span class="line">                    req.getRequestDispatcher(jspPath).forward(req,resp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">excute</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&#160; &#160; &#160; &#160;至此，我们只需要在一个Servlet类中编写所有的请求方法就可以了，如果页面想发送请求，则需要编写如下个格式的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--需要给出method参数，如果不给出则执行exctue默认方法--&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;$&#123;pageContext.request.contextPath&#125;&#x2F;studentServlet.do?method&#x3D;addStudent&quot; &gt;添加学生&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure><p>在StudentServlet中则对应如下的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addStudent</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span></span>&#123;</span><br><span class="line">        Student student = <span class="keyword">new</span> Student();</span><br><span class="line">        <span class="comment">//将从页面获取的数据通过工具类封装到Bean里</span></span><br><span class="line">        MyBeanUtils.populate(student,req.getParameterMap());</span><br><span class="line">        StudentService stuService = <span class="keyword">new</span> StudentServiceImpl();</span><br><span class="line">        student.setSid(UUIDUtils.getId());</span><br><span class="line"><span class="comment">//        System.out.println(student);</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            stuService.addStudent(student);</span><br><span class="line">            resp.sendRedirect(<span class="string">"index.jsp"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="过滤器的操作"><a href="#过滤器的操作" class="headerlink" title="过滤器的操作"></a>过滤器的操作</h2><p>&#160; &#160; &#160; &#160;众所周知，从客户端传递过来的数据，或有中文的编码问题，post和get方法对应的解决方法也不同，主要原因在于传递数据的途径不一样，post将所有的数据都封装在http请求头的消息体（entity-body）中，用户可以自定义编码的类型；而Get的数据则通过URL进行传递，由浏览器进行编码（大部分都是iso8859-1）传递给Servlet。因此，对于POST请求，我们需要自己设置编码类型，而对于GET请求，我们需要用iso8859-1进行解码，再编码成UTF-8进行使用。如果对每一个Servlet方法都进行编码设置的话，会有大量的重复代码，因此，我们需要通过一个过滤器去拦截所有的请求，统一这些请求的编码格式再传递给后端。过滤器的作用如下：<br><img src="https://img-blog.csdnimg.cn/20190812215823201.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM0Mjk0MTIx,size_16,color_FFFFFF,t_70" alt="过滤器"><br>&#160; &#160; &#160; &#160;过滤器的代码如下（过滤器也是需要注解配置的或者在web.xml中配置）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.memoforward.web.filter;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.*;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebFilter;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequestWrapper;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"><span class="comment">// /*表示拦截所有请求</span></span><br><span class="line"><span class="meta">@WebFilter</span>(filterName = <span class="string">"EncodingFilter"</span>, urlPatterns = <span class="string">"/*"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EncodingFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse resp, FilterChain chain)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        HttpServletRequest request = (HttpServletRequest)req;</span><br><span class="line">        HttpServletResponse response = (HttpServletResponse)resp;</span><br><span class="line">        <span class="comment">//这个方法是过滤器放行的方法，我们通过在通过增强request来保证Servlet中使用的request能够</span></span><br><span class="line">        <span class="comment">//自动处理编码问题</span></span><br><span class="line">        chain.doFilter(<span class="keyword">new</span> EnhancedRequest(request), response);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig config)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//web容器在使用HttpServletRequest接口时会自动创建HttpServletRequestWrapper实例（这里应该是通过依赖注入实现的 ，也不知道我理解的对不对）</span></span><br><span class="line"><span class="comment">//继承一下这个类提醒一下这个知识点，毕竟原来是从接口直接调用的方法</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">EnhancedRequest</span> <span class="keyword">extends</span> <span class="title">HttpServletRequestWrapper</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> HttpServletRequest request;</span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">EnhancedRequest</span><span class="params">(HttpServletRequest req)</span></span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(req);</span><br><span class="line">            <span class="keyword">this</span>.request = req;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getParameter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(name==<span class="keyword">null</span> || name.trim().length()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            String[] values = getParameterValues(name);</span><br><span class="line">            <span class="keyword">if</span>(values==<span class="keyword">null</span> || values.length==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> values[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * hobby=[eat,drink]</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> String[] getParameterValues(String name) &#123;</span><br><span class="line">            <span class="keyword">if</span>(name==<span class="keyword">null</span> || name.trim().length()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            Map&lt;String, String[]&gt; map = getParameterMap();</span><br><span class="line">            <span class="keyword">if</span>(map==<span class="keyword">null</span> || map.size()==<span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> map.get(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * map&#123; username=[tom],password=[123],hobby=[eat,drink]&#125;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">public</span> Map&lt;String,String[]&gt; getParameterMap() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 首先判断请求方式</span></span><br><span class="line"><span class="comment">             * 若为post  request.setchar...(utf-8)</span></span><br><span class="line"><span class="comment">             * 若为get 将map中的值遍历编码就可以了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            String method = request.getMethod();</span><br><span class="line">            <span class="keyword">if</span>(<span class="string">"post"</span>.equalsIgnoreCase(method))&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    request.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">                    <span class="keyword">return</span> request.getParameterMap();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"get"</span>.equalsIgnoreCase(method))&#123;</span><br><span class="line">                Map&lt;String,String[]&gt; map = request.getParameterMap();</span><br><span class="line">                <span class="keyword">if</span>(flag)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (String key:map.keySet()) &#123;</span><br><span class="line">                        String[] arr = map.get(key);</span><br><span class="line">                        <span class="comment">//继续遍历数组</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;arr.length;i++)&#123;</span><br><span class="line">                            <span class="comment">//编码</span></span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                arr[i]=<span class="keyword">new</span> String(arr[i].getBytes(<span class="string">"iso-8859-1"</span>),<span class="string">"utf-8"</span>);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">                                e.printStackTrace();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    flag=<span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//需要遍历map 修改value的每一个数据的编码</span></span><br><span class="line">                <span class="keyword">return</span> map;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.getParameterMap();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="工具类的说明"><a href="#工具类的说明" class="headerlink" title="工具类的说明"></a>工具类的说明</h2><p>&#160; &#160; &#160; &#160;其实用不用工具类都行，这些东西其实和项目的关系都不是很大了，自己编写工具类的好处就是用起来爽，有什么需要添加的功能直接在类里面写，真正在Servlet或者其他地方调用的时候显得简洁和清晰。笔者这里使用了三个工具类，具体代码还请给位看官移步github。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- 关于c3p0操作的C3O0Utils类，使用最多的就是获取连接操作。</span><br><span class="line">- 关于Bean封装的MyBeanutils类，增强了beanutils包，主要实现了对日期格式的转换</span><br><span class="line">- 关于学生唯一id生成的UUIDUtils类，增强了 UUID包，主要是因为UUID获得数据是UUID格式的，比较让人不爽</span><br></pre></td></tr></table></figure><h2 id="编写此项目的流程"><a href="#编写此项目的流程" class="headerlink" title="编写此项目的流程"></a>编写此项目的流程</h2><p>&#160; &#160; &#160; &#160; 在美工和数据库以及系统架构和环佩配置好了以后，就可以开始编写代码了，笔者比较喜欢的编码顺序是这样的：先把所有数据库中的实体Bean创建完毕（比如此项目中的Student），随后从美工界面出发一个个去将请求的Servlet方法编写完毕，servlet中调用的Service类就先定义出其接口。先把大逻辑搭建出来，等这个Servlet大逻辑编写完毕后再去实现低层的Service和Dao方法。当 “请求—servlet—service—dao” 的流程都都编写完成后，再去调试这个请求逻辑能不能跑通。当所有的请求都编写完后，这个项目就做完了。因为笔者比较菜，这个简单的项目用了一整天的时间才做完，期间也遇到了些许问题，如果有机会，希望能和各位多交流交流，各位如果有问题也可以在评论区问我。</p><h1 id="本项目出现过的问题"><a href="#本项目出现过的问题" class="headerlink" title="本项目出现过的问题"></a>本项目出现过的问题</h1><p>&#160; &#160; &#160; &#160; 在项目中遇到了两个比较非常棘手的问题： </p><ul><li><strong>关闭或重启服务器会提示有线程释放不掉，导致内存泄漏</strong>。其实这是tomcat的一个误报，因为c3p0的线程需要时间去关闭，具体答案请参考StarkOverlFlow：<a href="https://stackoverflow.com/questions/39988634/c3p0-connection-pool-memory-leak-redeploy-tomcat" target="_blank" rel="noopener">c3p0 Connection pool memory leak redeploy tomcat</a></li><li><strong>热部署的时候总是会提示 Illegal access: this web application instance has been stopped already.</strong> 这个问题似乎是因为tomcat缓存了该项目的旧版本，所以相当于一个tomcat启动了两个相同的项目所以报了异常。不影响项目的使用和调试，不过笔者水平有限，并没有解决这个问题，各位如果在运行本项目的时候遇到了这个问题，可以移步：<a href="https://stackoverflow.com/questions/4945153/illegal-access-this-web-application-instance-has-been-stopped-already" target="_blank" rel="noopener">Illegal access: this web application instance has been stopped already</a></li></ul><h1 id="交流"><a href="#交流" class="headerlink" title="交流"></a>交流</h1><blockquote><p>请联系邮箱：chenxingyu@bupt.edu.cn</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;&amp;#160; &amp;#160; &amp;#160; &amp;#160;用了小半年的时间摸索了一下Java后端，最近在学框架的时候觉得之前学习的内容有所遗忘，因此想自己做一个特别简单但是功能还算齐全的学生管理系统，给自己加深一下对servlet的理解。本人平时用Eclipse比较多，为了熟悉一下其他的IDE，这次的项目就用IDEA开发了。笔者也是一个初学者，理解不到位的地方还请各位朋友指出。本项目不使用web.xml手动添加servlet和filter，均采用注解的方式添加，需要创建web3.0及以上的工程。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="项目" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="Project" scheme="http://yoursite.com/tags/Project/"/>
    
  </entry>
  
</feed>
